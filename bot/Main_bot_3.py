"""
COPYRIGHT (c) TheHolyOneZ 2025

                CORE BOT IMPLEMENTATION LICENSE:
                The ZygnalBot class and its direct implementation (lines 106 - 451) are proprietary and protected under copyright.
                See copyright notice on line 7 for exceptions.
                
                - You may not modify the core implementation, except for changing Emojis and Status.
                - You may not edit or change any instance of the name zygnalbot, ZygnalBot, Zygnal, .gg/U8sssc6xbv, TheZ, TheHolyOneZ, https://zygnalbot.com.
                - You may not remove or alter this notice.
                - You may not remove, disable or modify any status tracking, analytics or reporting functionality.
                - Redistribution of the core implementation requires explicit written permission.
                
                GENERAL MIT LICENSE (All Other Code):
                Permission is hereby granted, free of charge, to any person obtaining a copy of the non-core portions of this
                software and associated documentation files, to use these portions without restriction, including, but not limited to,
                the rights to:
                
                - Use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software,
                  subject to the following conditions:
                
                1. The above copyright and dual-license notice must be included in all copies.
                2. The core implementation remains protected as specified above.
                3. Status tracking and analytics systems must remain intact and functional.
                
                THE SOFTWARE IS PROVIDED "AS IS," WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
                THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
                OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT,
                OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"""

# Libs

import string
import traceback
import typing
import wave
import numpy as np
import openai
import humanize
import pytz
import aiosqlite
import emoji
from typing import Union
import asyncio
import copy
import io
import json
import logging
import os
import platform
import random
import re
import shlex
import sqlite3
import time
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Tuple
import aiohttp
import discord
from discord import ButtonStyle, app_commands
from discord.ext import commands, tasks
from discord.ui import View, Button, Select, Modal, TextInput
from dotenv import load_dotenv
import requests
import yt_dlp 
import wget
import zipfile
import platform
import os
import subprocess
from io import BytesIO
import colorsys
from PIL import Image, ImageDraw, ImageFont
import io 
from enum import Enum
from dataclasses import dataclass
from anthropic import Anthropic
import anthropic
import uuid
from googletrans import Translator

# Local Modules (.py)
from update_checker import UpdateChecker
from cogs_manager import CogManager
from Z_Sort import ZSortCommands
from auto_config_loader import AutoConfigLoader
from RuleMaker import RuleMaker

from extension_marketplace import ExtensionMarketplace

logging.getLogger('discord').setLevel(logging.ERROR)
logging.getLogger('discord.client').setLevel(logging.ERROR) 
logging.getLogger('discord.gateway').setLevel(logging.ERROR)

load_dotenv()
ZygnalBot_Version = "V7.9.4"

def analyze_emoji_usage(content):
    emoji_count = {}
    for char in content:
        if char in emoji.EMOJI_DATA:
            emoji_count[char] = emoji_count.get(char, 0) + 1
    return emoji_count

class ZygnalBot(commands.Bot):
    def print_banner(self):
        banner = """
    \033[93m

   ooooooooooooo oooo                   oooooooooooo 
   8'   888   `8 `888                  d'""""""d888' 
        888       888 .oo.    .ooooo.        .888P   
        888       888P"Y88b  d88' `88b      d888'    
        888       888   888  888ooo888    .888P      
        888       888   888  888    .o   d888'    .P 
       o888o     o888o o888o `Y8bod8P' .8888888888P  
                                                                                          
    \033[0m
    """
        print(banner)
        
    def __init__(self):

        command_prefix = str(os.getenv('CMD_PREFIX', '!'))
        
        super().__init__(

            command_prefix=command_prefix,
        
            intents=discord.Intents.all(),
            activity=discord.Activity(
                type=discord.ActivityType.watching,
                name=str("⚡ Server Protection")
            ),
            help_command=None
        )
        self.webhook_logger = None
        self.ticket_counter = 0
        self.start_time = time.time()
        self.mod_logs = {}
        self.warning_system = {}
        self._cached_messages = {}
        self.auto_mod_config = {
            'caps_threshold': 0.7,
            'spam_threshold': 5,
            'spam_interval': 5,
            'banned_words': set(),
            'link_whitelist': set()
        }
        
        """
        Info: Below is a Status Tracker that will send a random token every 10 seconds to my website.
        This helps us track how many people are using the bot. It only sends your Discord ID to identify you, 
        ensuring that instances are not mixed up (for example, to check if you're the same user across different sessions).
        The `self.instance_token = str(uuid.uuid4())` generates a unique random token to act as an identifier.
        This way, the bot can report the status of your bot on multiple servers without getting instances mixed up.

        "#NOT ALLOWED TO EDIT" = Status Tracking Look above for infos! 
        """

        self.instance_token = str(uuid.uuid4())                                             
        self.status_url = "https://zygnalbot.de/status.php"                                 # Website to see Tracking: https://zygnalbot.de/status.html | We are not tracking you only if the bot is online etc. like mee6 shows on what servers its online on.
        self.status_update_task = tasks.loop(minutes=0.1)(self.periodic_status_update)      

    async def setup_cogs(self):
        await self.add_cog(CommandErrorHandler(self))
        print("✓ Loaded CommandErrorHandler")
        await self.add_cog(ModerationCommands(self))
        print("✓ Loaded ModerationCommands")
        await self.add_cog(TicketSystem(self))
        print("✓ Loaded TicketSystem")
        await self.add_cog(ServerManagement(self))
        print("✓ Loaded ServerManagement")
        await self.add_cog(ServerInfo(self))
        print("✓ Loaded ServerInfo")
        await self.add_cog(HelpSystem(self))
        print("✓ Loaded HelpSystem")
        await self.add_cog(AutoMod(self))
        print("✓ Loaded AutoMod")
        await self.add_cog(WelcomeSystem(self))
        print("✓ Loaded WelcomeSystem")
        await self.add_cog(RoleManager(self))
        print("✓ Loaded RoleManager")
        await self.add_cog(UserTracker(self))
        print("✓ Loaded UserTracker")
        await self.add_cog(BackupSystem(self))
        print("✓ Loaded BackupSystem")
        await self.add_cog(Config(self))
        print("✓ Loaded Config")
        await self.add_cog(OwnerOnly(self))
        print("✓ Loaded OwnerOnly")
        await self.add_cog(MinigamesCog(self))
        print("✓ Loaded MinigamesCog")
        await self.add_cog(Analytics(self))
        print("✓ Loaded Analytics")
        await self.add_cog(AdvancedInviteTracker(self))
        print("✓ Loaded AdvancedInviteTracker")
        await self.add_cog(Snipe(self))
        print("✓ Loaded Snipe")
        await self.add_cog(ReminderSystem(self))
        print("✓ Loaded ReminderSystem")
        await self.add_cog(MessagePurge(self))
        print("✓ Loaded MessagePurge")
        await self.add_cog(CustomLogging(self))
        print("✓ Loaded CustomLogging")
        await self.add_cog(LevelingSystem(self))
        print("✓ Loaded LevelingSystem")
        await self.add_cog(MuteSystem(self))
        print("✓ Loaded MuteSystem")
        await self.add_cog(VerificationSetup(self))
        print("✓ Loaded VerificationSystem")
        await self.add_cog(BotVerificationSystem(self))
        print("✓ Loaded BotVerificationSystem")
        await self.add_cog(RatingSystem(self))
        print("✓ Loaded RatingSystem")
        await self.add_cog(MoodTracker(self))
        print("✓ Loaded MoodTracker")
        await self.add_cog(IdeaSystem(self))
        print("✓ Loaded IdeaSystem")
        await self.add_cog(MusicPlayer(self))
        print("✓ Loaded MusicPlayer")
        await self.add_cog(ChannelManager(self))
        print("✓ Loaded ChannelManager")
        await self.add_cog(RoleBackup(self))
        print("✓ Loaded RoleBackup")
        # await self.add_cog(AiCommands(self))
        # print("✓ Loaded AiCommands")
        await self.add_cog(EnhancedMinigames(self))
        print("✓ Loaded EnhancedMinigames")
        await self.add_cog(AFKSystem(self))
        print("✓ Loaded AFKSystem")
        await self.add_cog(JSONEmbeds(self))
        print("✓ Loaded JSONEmbeds")
        await self.add_cog(TempChannels(self))
        print("✓ Loaded TempChannels")
        await self.add_cog(ProfileSystem(self))
        print("✓ Loaded ProfileSystem")
        await self.add_cog(WebhookManager(self))
        print("✓ Loaded WebhookManager")
        await self.add_cog(CustomVerification(self))
        print("✓ Loaded CustomVerification")
        await self.add_cog(ServerAdsHub(self))
        print("✓ Loaded ServerAdsHub")
        await self.add_cog(AdvancedUserAnalytics(self))
        print("✓ Loaded AdvancedUserAnalytics")
        await self.add_cog(AI_CHAT(self))
        print("✓ Loaded AI_CHAT")
        await self.add_cog(BMICalculator(self))
        print("✓ Loaded BMICalculator")
        await self.add_cog(MathPhysicsTools(self))
        print("✓ Loaded MathPhysicsTools")
        await self.add_cog(TimeTools(self))
        print("✓ Loaded TimeTools")
        await self.add_cog(CodingTools(self))
        print("✓ Loaded CodingTools")
        await self.add_cog(StudyTools(self))
        print("✓ Loaded StudyTools")
        await self.add_cog(URLShortener(self))
        print("✓ Loaded URLShortener")
        await self.add_cog(PasswordGenerator(self))
        print("✓ Loaded PasswordGenerator")
        await self.add_cog(MorseCodeTools(self))
        print("✓ Loaded MorseCodeTools")
        await self.add_cog(ASCIIArtGenerator(self))
        print("✓ Loaded ASCIIArtGenerator")
        await self.add_cog(URLStatusChecker(self))
        print("✓ Loaded URLStatusChecker")
        await self.add_cog(IPLookupTools(self))
        print("✓ Loaded IPLookupTools")
        await self.add_cog(FileSizeConverter(self))
        print("✓ Loaded FileSizeConverter")
        await self.add_cog(FileTypeIdentifier(self))
        print("✓ Loaded FileTypeIdentifier")
        await self.add_cog(DownloadCalculator(self))
        print("✓ Loaded DownloadCalculator")
        await self.add_cog(WordAnalytics(self))
        print("✓ Loaded WordAnalytics")
        await self.add_cog(AdvancedRNG(self))
        print("✓ Loaded AdvancedRNG")
        await self.add_cog(ChemicalElements(self))
        print("✓ Loaded ChemicalElements")
        await self.add_cog(ISBNLookup(self))
        print("✓ Loaded ISBNLookup")
        await self.add_cog(CitationGenerator(self))
        print("✓ Loaded CitationGenerator")
        await self.add_cog(AdvancedPollSystem(self))
        print("✓ Loaded AdvancedPollSystem")
        await self.add_cog(HackerCommands(self))
        print("✓ Loaded HackerCommands")
        await self.add_cog(RoastCommands(self))
        print("✓ Loaded RoastCommands")
        await self.add_cog(BotSassResponses(self))
        print("✓ Loaded BotSassResponses")
        await self.add_cog(AntiGhostPing(self))
        print("✓ Loaded AntiGhostPing")
        await self.add_cog(ClaudeAI(self))
        print("✓ Loaded ClaudeAI")
        await self.add_cog(Announcements(self))
        print("✓ Loaded Announcements")
        await self.add_cog(BeatUpCommands(self))
        print("✓ Loaded BeatUpCommands")
        await self.add_cog(ShootingCommands(self))
        print("✓ Loaded ShootingCommands")
        await self.add_cog(LoveCommands(self))
        print("✓ Loaded LoveCommands")
        await self.add_cog(TeamFightCommands(self))
        print("✓ Loaded TeamFightCommands")
        await self.add_cog(BlackjackGame(self))
        print("✓ Loaded BlackjackGame")
        await self.add_cog(RiotGamesAPI(self))
        print("✓ Loaded RiotGamesAPI")
        await self.add_cog(ClearChannel(self))
        print ("✓ Loaded ClearChannel Function")
        await self.add_cog(AntiNukeSystem(self))
        print("✓ Loaded AntiNukeSystem")
        await self.add_cog(TranslationSystem(self))
        print("✓ Loaded TranslationSystem")
        await self.add_cog(SecurityAudit(self))
        print("✓ Loaded SecurityAudit")
        await self.add_cog(Sudo(self))
        print("✓ Loaded sudo")
        await self.add_cog(GiveawaySystem(self))
        print("✓ Loaded GiveawaySystem")
        await self.add_cog(SocialMediaManager(self))
        print("✓ Loaded SocialMediaManager | Only Framework")
        await self.add_cog(BirthdayReminder(self))
        print("✓ Loaded BirthdayReminder")
        await self.add_cog(CustomCommands(self))
        print("✓ Loaded CustomCommands")
        await self.add_cog(CommandAliases(self))
        print("✓ Loaded CommandAliases")
        await self.add_cog(UserNotebook(self))
        print("✓ Loaded UserNotebook")
        await self.add_cog(EmotionalSupportCog(self))
        await bot.add_cog(UpdateChecker(bot))
        print("✓ Loaded UpdateChecker")
        await bot.add_cog(CogManager(bot))
        print("✓ Loaded CogManager")
        await bot.add_cog(ZSortCommands(bot))
        print("✓ Loaded ZSortCommands")
        self.config_manager = ConfigManager(self)  
        await self.add_cog(ServerConfig(self))
        print("✓ Loaded ServerConfig | Not Done | in Development")
        await self.add_cog(CreatorResponseCog(self))
        await bot.add_cog(AutoConfigLoader(bot))
        print("✓ AutoConfigLoader")
        await bot.load_extension("extension_loader")
        print("✓ Loaded ExtensionLoader")
        await self.add_cog(RuleMaker(self))
        print("✓ Loaded RuleMaker")
        await self.add_cog(ExtensionMarketplace(bot))
        print("✓ Loaded Ext. Marketplace")
        
        await self.add_cog(TrollFriend(self, target_user_id=524385308662562826))
        print("All Cogs Loaded!")
        print("-------------------------------------------------------")
        print("Waiting for bot to be ready...")
        print("-------------------------------------------------------")
        
    async def setup_hook(self):
        await self.setup_cogs()
        self.add_view(PersistentVerifyView())    
        self.config_manager = ConfigManager()
        await bot.tree.sync()
                                   
        await self.send_status_update("online")
                                    
    async def send_status_update(self, status):                                         
        data = {                                                                        
            "token": self.instance_token,                                               
            "server_id": [str(g.id) for g in self.guilds],                              
            "status": status,                                                           
            "version": ZygnalBot_Version,                                              
            "uptime": time.time() - self.start_time,                                    
            "servers_count": len(self.guilds),                                         
            "members_count": sum(g.member_count for g in self.guilds),                  
            "timestamp": datetime.now(timezone.utc).isoformat()                         
        }
        
        async with aiohttp.ClientSession() as session:                                  
            try:
                async with session.post(self.status_url, json=data) as response:                            

                    if response.status != 200:
                        print(f"Status update failed with code: {response.status}")                             
            except Exception as e:                                                                  
                print(f"Failed to send status update: {e}")                             

    async def on_ready(self):
        self.webhook_logger = WebhookLogger(self)
        self.print_banner()
        print('\033[92m' + '🚀 ' + '\033[94m' + f'{self.user}' + '\033[92m' + ' ZygnalBot is Online! ' + '\033[91m' + '(c) TheHolyOneZ' + '\033[0m')
        
        await self.send_status_update("online")                                 
        self.status_update_task.start()                                         
        
        await self.setup_status_task()                                          

    async def setup_status_task(self):
        while True:
            animations = [
                ("watching", "⚡ Website → zygnalbot.com"),
                ("listening", "🎧 Join us → .gg/U8sssc6xbv"),
                ("listening", ❤️ Support ZygnalBot → zygnalbot.com/support.html"),                 
            ]
            
            for activity_type, message in animations:
                activity = discord.Activity(
                    type=getattr(discord.ActivityType, activity_type),
                    name=message
                )
                await self.change_presence(activity=activity)
                await asyncio.sleep(10)
                
            stats_messages = [
                ("listening", "🎶 Get ZygnalBot → zygnalbot.com"),
                ("playing", f"⚡ Protecting {len(self.guilds)} servers!"),
                ("listening", "🎤 Join the community → .gg/U8sssc6xbv"),
                ("watching", f"👀 {sum(g.member_count for g in self.guilds)} members online!"),
                ("listening", "❤️ Support ZygnalBot → zygnalbot.com/support.html"), 
            ]
            
            for activity_type, message in stats_messages:
                activity = discord.Activity(
                    type=getattr(discord.ActivityType, activity_type),
                    name=message
                )
                await self.change_presence(activity=activity)
                await asyncio.sleep(10)

    async def periodic_status_update(self):                         
        await self.send_status_update("online")                     
    async def on_message(self, message):
        if message.guild:  
            return      
        if isinstance(message.content, bytes):
            message.content = str(message.content.decode('utf-8'))
        if self.webhook_logger:
            await self.webhook_logger.log_message(message)
        await self.process_commands(message)

    async def on_command(self, ctx):
        if self.webhook_logger:
            await self.webhook_logger.log_command(ctx)

    async def close(self):
        await self.send_status_update("offline")                    
        await super().close()  
                                             
bot = ZygnalBot()







"""Below Is Not Tested/Not Fully Implented and Wont Work Correctly"""



from collections import defaultdict


logger = logging.getLogger('zygnal_config')

class ConfigManager:

    def __init__(self, data_folder="config"):  
        self.bot = bot
        self.config_dir = "data/server_configs"
        self.ensure_directory_exists()
        self.cache = defaultdict(dict)
        self.load_all_configs()
        
    def ensure_directory_exists(self):

        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)
            logger.info(f"Created config directory: {self.config_dir}")
    
    def get_server_config_path(self, guild_id):

        return os.path.join(self.config_dir, f"{guild_id}.json")
    
    def load_all_configs(self):

        for filename in os.listdir(self.config_dir):
            if filename.endswith('.json'):
                guild_id = int(filename.split('.')[0])
                self.load_config(guild_id)
                
    def load_config(self, guild_id):

        path = self.get_server_config_path(guild_id)
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    self.cache[guild_id] = json.load(f)
                logger.info(f"Loaded config for guild {guild_id}")
            except json.JSONDecodeError:
                logger.error(f"Failed to parse config for guild {guild_id}")
                self.cache[guild_id] = {}
        else:
            self.cache[guild_id] = {}
        return self.cache[guild_id]
    
    def save_config(self, guild_id):

        path = self.get_server_config_path(guild_id)
        try:
            with open(path, 'w') as f:
                json.dump(self.cache[guild_id], f, indent=4)
            logger.info(f"Saved config for guild {guild_id}")
            return True
        except Exception as e:
            logger.error(f"Failed to save config for guild {guild_id}: {e}")
            return False
    
    def get_setting(self, guild_id, category, key, default=None):
      
        config = self.cache[guild_id]
        if category not in config:
            return default
        return config[category].get(key, default)
    
    def set_setting(self, guild_id, category, key, value):
       
        if guild_id not in self.cache:
            self.cache[guild_id] = {}
        if category not in self.cache[guild_id]:
            self.cache[guild_id][category] = {}
        self.cache[guild_id][category][key] = value
        return self.save_config(guild_id)
    
    def get_category(self, guild_id, category):

        return self.cache[guild_id].get(category, {})
    
    def set_category(self, guild_id, category, settings):

        self.cache[guild_id][category] = settings
        return self.save_config(guild_id)

class EnhancedServerConfigUI:
    def __init__(self, bot):
        self.bot = bot
        self.config_manager = bot.config_manager
        
    async def create_config_panel(self, interaction):

        embed = discord.Embed(
            title="🔧 ZygnalBot Advanced Server Configuration",
            description="Configure your server with our enhanced management system",
            color=discord.Color.brand_green(),
            timestamp=datetime.now()
        )
        
        embed.add_field(
            name="✨ Available Configuration Options",
            value="• Channel Permissions\n• Role Management\n• User Access Control\n• Moderation Settings\n• Bot Features",
            inline=False
        )
        
        embed.add_field(
            name="ℹ️ Instructions",
            value="Use the dropdown menus below to navigate through different configuration options.",
            inline=False
        )
        
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Premium Server Management")
        embed.set_thumbnail(url="https://zygnalbot.de/assets/zygnalISLAND_1.png")
        
        if isinstance(interaction, discord.Interaction):
          
            user_id = interaction.user.id
            view = ConfigMainView(self.bot, user_id)
            await interaction.response.send_message(embed=embed, view=view)
        else:
          
            user_id = interaction.author.id
            view = ConfigMainView(self.bot, user_id)
            await interaction.send(embed=embed, view=view)


class ConfigMainView(discord.ui.View):
    def __init__(self, bot, owner_id):
        super().__init__(timeout=300)
        self.bot = bot
        self.owner_id = owner_id
        
        self.add_item(MainConfigSelector(bot))
        
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
       
        if interaction.user.id != self.owner_id and not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("You don't have permission to use this configuration panel.", ephemeral=True)
            return False
        return True
        
    async def on_timeout(self):
        
        for item in self.children:
            item.disabled = True

class MainConfigSelector(discord.ui.Select):
    def __init__(self, bot):
        self.bot = bot
        options = [
            discord.SelectOption(
                label="Channel Permissions | In development",
                description="Configure who can view and interact with channels",
                emoji="🔒",
                value="channel_perms"
            ),
            discord.SelectOption(
                label="Role Management",
                description="Create, edit, and assign roles to members",
                emoji="👑",
                value="role_management"
            ),
            discord.SelectOption(
                label="User Access Control",
                description="Manage user permissions and access levels",
                emoji="👤",
                value="user_access"
            ),
            discord.SelectOption(
                label="Moderation Settings | In development",
                description="Configure auto-moderation and manual tools",
                emoji="🛡️",
                value="moderation"
            ),
            discord.SelectOption(
                label="Bot Features | In development",
                description="Enable or disable ZygnalBot features",
                emoji="🤖",
                value="bot_features"
            )
        ]
        
        super().__init__(
            placeholder="Select a configuration category...",
            min_values=1,
            max_values=1,
            options=options
        )
        
    async def callback(self, interaction: discord.Interaction):

        if self.values[0] == "channel_perms":
            view = ChannelPermissionsView(self.bot, interaction.guild)
            await interaction.response.send_message(
                embed=self.create_channel_perms_embed(), 
                view=view, 
                ephemeral=True
            )
        elif self.values[0] == "role_management":
            view = RoleManagementView(self.bot, interaction.guild)
            await interaction.response.send_message(
                embed=self.create_role_management_embed(),
                view=view,
                ephemeral=True
            )
        elif self.values[0] == "user_access":
            view = UserAccessView(self.bot, interaction.guild)
            await interaction.response.send_message(
                embed=self.create_user_access_embed(),
                view=view,
                ephemeral=True
            )
        elif self.values[0] == "moderation":
            view = ModerationSettingsView(self.bot, interaction.guild)
            await interaction.response.send_message(
                embed=self.create_moderation_embed(),
                view=view,
                ephemeral=True
            )
        elif self.values[0] == "bot_features":
            view = BotFeaturesView(self.bot, interaction.guild)
            await interaction.response.send_message(
                embed=self.create_bot_features_embed(),
                view=view,
                ephemeral=True
            )
    
    def create_channel_perms_embed(self):

        embed = discord.Embed(
            title="🔒 Channel Permissions Configuration",
            description="Manage who can see and interact with channels in your server",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        embed.add_field(
            name="Available Options",
            value="• Set view permissions\n• Set send message permissions\n• Configure voice channel access\n• Set up private channels\n• Manage channel categories",
            inline=False
        )
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Advanced Permission Management")
        return embed
    
    def create_role_management_embed(self):

        embed = discord.Embed(
            title="👑 Role Management System",
            description="Create and manage roles with advanced permission settings",
            color=discord.Color.gold(),
            timestamp=datetime.now()
        )
        embed.add_field(
            name="Available Options",
            value="• Create new roles\n• Edit existing roles\n• Set up role hierarchy\n• Configure role permissions\n• Create self-assignable roles",
            inline=False
        )
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Role Management System")
        return embed
    
    def create_user_access_embed(self):

        embed = discord.Embed(
            title="👤 User Access Control",
            description="Manage individual user permissions and access levels",
            color=discord.Color.teal(),
            timestamp=datetime.now()
        )
        embed.add_field(
            name="Available Options",
            value="• Assign roles to users\n• Set up user-specific permissions\n• Configure access levels\n• Manage user groups\n• Set up verification systems",
            inline=False
        )
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | User Management System")
        return embed
    
    def create_moderation_embed(self):

        embed = discord.Embed(
            title="🛡️ Moderation Settings",
            description="Configure automated and manual moderation tools",
            color=discord.Color.red(),
            timestamp=datetime.now()
        )
        embed.add_field(
            name="Available Options",
            value="• Auto-moderation settings\n• Spam protection\n• Word filters\n• Raid protection\n• Warning system configuration",
            inline=False
        )
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Advanced Moderation System")
        return embed
    
    def create_bot_features_embed(self):

        embed = discord.Embed(
            title="🤖 ZygnalBot Features",
            description="Enable or disable various bot features for your server",
            color=discord.Color.purple(),
            timestamp=datetime.now()
        )
        embed.add_field(
            name="Available Features",
            value="• Welcome system\n• Leveling system\n• Music commands\n• Analytics dashboard\n• Custom commands\n• Mood tracking\n• Study tools\n• Anti-ghost ping",
            inline=False
        )
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Feature Management")
        return embed

class ChannelPermissionsView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config_manager = bot.config_manager
        self.selected_channel = None
        self.selected_role = None
        

        self.add_item(ChannelSelector(guild))

        self.add_item(RoleSelector(guild))
        
    @discord.ui.button(label="Set View Permission", style=discord.ButtonStyle.primary, emoji="👁️")
    async def set_view_permission(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_channel or not self.selected_role:
            await interaction.response.send_message("Please select both a channel and a role first.", ephemeral=True)
            return
            

        await interaction.response.send_modal(PermissionModal("View Channel", self.bot, self.guild.id, self.selected_channel.id, self.selected_role.id))
        
    @discord.ui.button(label="Set Send Messages", style=discord.ButtonStyle.primary, emoji="✏️")
    async def set_send_permission(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_channel or not self.selected_role:
            await interaction.response.send_message("Please select both a channel and a role first.", ephemeral=True)
            return
            

        await interaction.response.send_modal(PermissionModal("Send Messages", self.bot, self.guild.id, self.selected_channel.id, self.selected_role.id))
        
    @discord.ui.button(label="Apply Settings", style=discord.ButtonStyle.success, emoji="✅")
    async def apply_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_channel or not self.selected_role:
            await interaction.response.send_message("Please select both a channel and a role first.", ephemeral=True)
            return
            

        channel_perms = self.config_manager.get_category(self.guild.id, "channel_permissions")
        channel_id = str(self.selected_channel.id)
        role_id = str(self.selected_role.id)
        
        if channel_id not in channel_perms or role_id not in channel_perms[channel_id]:
            await interaction.response.send_message("No permission changes have been configured yet.", ephemeral=True)
            return
            

        try:
            channel = self.guild.get_channel(int(channel_id))
            role = self.guild.get_role(int(role_id))
            
            perms = channel.overwrites_for(role)
            
            for perm_name, value in channel_perms[channel_id][role_id].items():
                if value == "True":
                    setattr(perms, perm_name, True)
                elif value == "False":
                    setattr(perms, perm_name, False)
                elif value == "None":
                    setattr(perms, perm_name, None)
            
            await channel.set_permissions(role, overwrite=perms)
            await interaction.response.send_message(f"Channel permissions for {role.name} in {channel.name} have been updated successfully!", ephemeral=True)
            
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to modify channel permissions.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error applying permissions: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)

class RoleManagementView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config_manager = bot.config_manager
        self.selected_role = None
        

        self.add_item(RoleSelector(guild))
        
    @discord.ui.button(label="Create New Role", style=discord.ButtonStyle.success, emoji="➕")
    async def create_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(RoleCreationModal(self.bot, self.guild))
        
    @discord.ui.button(label="Edit Selected Role", style=discord.ButtonStyle.primary, emoji="✏️")
    async def edit_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_role:
            await interaction.response.send_message("Please select a role first.", ephemeral=True)
            return
            
        await interaction.response.send_modal(RoleEditModal(self.bot, self.guild, self.selected_role))
        
    @discord.ui.button(label="Delete Role", style=discord.ButtonStyle.danger, emoji="🗑️")
    async def delete_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_role:
            await interaction.response.send_message("Please select a role first.", ephemeral=True)
            return
            
        if self.selected_role.position >= interaction.guild.me.top_role.position:
            await interaction.response.send_message("I cannot delete a role that is higher than or equal to my highest role.", ephemeral=True)
            return
            
        view = ConfirmationView(f"Are you sure you want to delete the role '{self.selected_role.name}'?")
        await interaction.response.send_message(view.prompt, ephemeral=True, view=view)
        

        await view.wait()
        if view.value:
            try:
                role_name = self.selected_role.name
                await self.selected_role.delete(reason=f"Deleted by {interaction.user} via ZygnalBot config")
                await interaction.followup.send(f"Role '{role_name}' has been deleted.", ephemeral=True)
            except discord.Forbidden:
                await interaction.followup.send("I don't have permission to delete this role.", ephemeral=True)
            except Exception as e:
                logger.error(f"Error deleting role: {e}")
                await interaction.followup.send(f"An error occurred: {e}", ephemeral=True)

class UserAccessView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config_manager = bot.config_manager
        self.selected_user = None
        self.selected_role = None
        

        self.add_item(UserSelector(guild))

        self.add_item(RoleSelector(guild))
        
    @discord.ui.button(label="Assign Role", style=discord.ButtonStyle.primary, emoji="👤")
    async def assign_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_user or not self.selected_role:
            await interaction.response.send_message("Please select both a user and a role first.", ephemeral=True)
            return
            
        if self.selected_role.position >= interaction.guild.me.top_role.position:
            await interaction.response.send_message("I cannot assign a role that is higher than or equal to my highest role.", ephemeral=True)
            return
            
        try:
            await self.selected_user.add_roles(self.selected_role, reason=f"Assigned by {interaction.user} via ZygnalBot config")
            await interaction.response.send_message(f"Role '{self.selected_role.name}' has been assigned to {self.selected_user.display_name}.", ephemeral=True)
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to assign roles.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error assigning role: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)
        
    @discord.ui.button(label="Remove Role", style=discord.ButtonStyle.secondary, emoji="🚫")
    async def remove_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_user or not self.selected_role:
            await interaction.response.send_message("Please select both a user and a role first.", ephemeral=True)
            return
            
        if self.selected_role.position >= interaction.guild.me.top_role.position:
            await interaction.response.send_message("I cannot remove a role that is higher than or equal to my highest role.", ephemeral=True)
            return
            
        try:
            await self.selected_user.remove_roles(self.selected_role, reason=f"Removed by {interaction.user} via ZygnalBot config")
            await interaction.response.send_message(f"Role '{self.selected_role.name}' has been removed from {self.selected_user.display_name}.", ephemeral=True)
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to remove roles.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error removing role: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)
        
    @discord.ui.button(label="Set Admin", style=discord.ButtonStyle.danger, emoji="⚠️")
    async def set_admin(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_user:
            await interaction.response.send_message("Please select a user first.", ephemeral=True)
            return
            

        admin_role = discord.utils.get(self.guild.roles, name="Admin")
        if not admin_role:
            try:
                admin_role = await self.guild.create_role(
                    name="Admin",
                    permissions=discord.Permissions(administrator=True),
                    color=discord.Color.red(),
                    reason=f"Created by {interaction.user} via ZygnalBot config"
                )
            except discord.Forbidden:
                await interaction.response.send_message("I don't have permission to create roles.", ephemeral=True)
                return
            except Exception as e:
                logger.error(f"Error creating admin role: {e}")
                await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)
                return
                
        view = ConfirmationView(f"⚠️ WARNING: This will give {self.selected_user.display_name} FULL ADMIN permissions. Are you absolutely sure?")
        await interaction.response.send_message(view.prompt, ephemeral=True, view=view)
        

        await view.wait()
        if view.value:
            try:
                await self.selected_user.add_roles(admin_role, reason=f"Admin role assigned by {interaction.user} via ZygnalBot config")
                await interaction.followup.send(f"⚠️ {self.selected_user.display_name} has been given admin permissions.", ephemeral=True)
            except discord.Forbidden:
                await interaction.followup.send("I don't have permission to assign roles.", ephemeral=True)
            except Exception as e:
                logger.error(f"Error assigning admin role: {e}")
                await interaction.followup.send(f"An error occurred: {e}", ephemeral=True)

class ModerationSettingsView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config_manager = bot.config_manager
        
    @discord.ui.button(label="Anti-Spam Settings", style=discord.ButtonStyle.primary, emoji="🛡️")
    async def anti_spam(self, interaction: discord.Interaction, button: discord.ui.Button):

        spam_settings = self.config_manager.get_category(self.guild.id, "anti_spam")
        

        view = AntiSpamView(self.bot, self.guild, spam_settings)
        await interaction.response.send_message("Configure anti-spam settings:", ephemeral=True, view=view)
        
    @discord.ui.button(label="Word Filter", style=discord.ButtonStyle.primary, emoji="🔍")
    async def word_filter(self, interaction: discord.Interaction, button: discord.ui.Button):

        filter_settings = self.config_manager.get_category(self.guild.id, "word_filter")
        filtered_words = filter_settings.get("words", [])
        
        view = WordFilterView(self.bot, self.guild, filtered_words)
        await interaction.response.send_message("Configure word filter settings:", ephemeral=True, view=view)
        
    @discord.ui.button(label="Raid Protection", style=discord.ButtonStyle.danger, emoji="⚠️")
    async def raid_protection(self, interaction: discord.Interaction, button: discord.ui.Button):

        raid_settings = self.config_manager.get_category(self.guild.id, "raid_protection")
        
        view = RaidProtectionView(self.bot, self.guild, raid_settings)
        await interaction.response.send_message("Configure raid protection settings:", ephemeral=True, view=view)

class BotFeaturesView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config_manager = bot.config_manager
        self.selected_feature = None
        

        self.add_item(FeatureSelector(bot, guild))
        
    @discord.ui.button(label="Enable Feature", style=discord.ButtonStyle.success, emoji="✅")
    async def enable_feature(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_feature:
            await interaction.response.send_message("Please select a feature first.", ephemeral=True)
            return
            

        self.config_manager.set_setting(self.guild.id, "features", self.selected_feature, True)
        

        await self.update_feature_state(interaction, self.selected_feature, True)
        
        await interaction.response.send_message(f"Feature '{self.selected_feature}' has been enabled successfully!", ephemeral=True)
        
    @discord.ui.button(label="Disable Feature", style=discord.ButtonStyle.secondary, emoji="❌")
    async def disable_feature(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_feature:
            await interaction.response.send_message("Please select a feature first.", ephemeral=True)
            return
            

        self.config_manager.set_setting(self.guild.id, "features", self.selected_feature, False)
        

        await self.update_feature_state(interaction, self.selected_feature, False)
        
        await interaction.response.send_message(f"Feature '{self.selected_feature}' has been disabled successfully!", ephemeral=True)
        
    @discord.ui.button(label="Configure Feature", style=discord.ButtonStyle.primary, emoji="⚙️")
    async def configure_feature(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_feature:
            await interaction.response.send_message("Please select a feature first.", ephemeral=True)
            return
            

        feature_config_view = await self.get_feature_config_view(self.selected_feature)
        if feature_config_view:
            await interaction.response.send_message(f"Configuring {self.selected_feature}...", ephemeral=True, view=feature_config_view)
        else:
            await interaction.response.send_message(f"No additional configuration options available for {self.selected_feature}.", ephemeral=True)
    
    async def update_feature_state(self, interaction, feature, enabled):

        feature_handlers = {
            "welcome": self.toggle_welcome_system,
            "leveling": self.toggle_leveling_system,
            "music": self.toggle_music_system,
            "analytics": self.toggle_analytics_system,
            "custom_cmds": self.toggle_custom_commands,
            "mood": self.toggle_mood_tracking,
            "study": self.toggle_study_tools,
            "ghost_ping": self.toggle_ghost_ping,
            "automod": self.toggle_automod_system,
            "ticket": self.toggle_ticket_system,
            "fun": self.toggle_fun_commands
        }
        
        if feature in feature_handlers:
            await feature_handlers[feature](interaction, enabled)
    
    async def get_feature_config_view(self, feature):

        feature_config_views = {
            "welcome": WelcomeConfigView,
            "leveling": LevelingConfigView,
            "music": MusicConfigView,
            "analytics": AnalyticsConfigView,
            "custom_cmds": CustomCommandsConfigView,
            "mood": MoodTrackingConfigView,
            "study": StudyToolsConfigView,
            "ghost_ping": GhostPingConfigView,
            "automod": AutoModConfigView
        }
        
        if feature in feature_config_views:
            return feature_config_views[feature](self.bot, self.guild)
        return None
    

    async def toggle_welcome_system(self, interaction, enabled):
        welcome_config = self.config_manager.get_category(interaction.guild.id, "welcome") or {}
        welcome_config["enabled"] = enabled
        self.config_manager.set_category(interaction.guild.id, "welcome", welcome_config)
        
        try:
            if enabled:

                if not welcome_config.get("channel_id"):

                    welcome_config["message"] = "Welcome {user} to {server}! You are member #{count}."
                    welcome_config["color"] = "3498db"  # Default blue color
                    welcome_config["use_embed"] = True
                    welcome_config["show_avatar"] = True
                    welcome_config["embed_title"] = "Welcome!"
                    self.config_manager.set_category(interaction.guild.id, "welcome", welcome_config)
                

                if "cogs.welcome" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.welcome")
                    logger.info(f"Welcome system enabled for guild {interaction.guild.id}")
            else:


                logger.info(f"Welcome system disabled for guild {interaction.guild.id}")
        except Exception as e:
            logger.error(f"Error toggling welcome system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the welcome system: {e}", ephemeral=True)
        
    async def toggle_leveling_system(self, interaction, enabled):
        leveling_config = self.config_manager.get_category(interaction.guild.id, "leveling") or {}
        leveling_config["enabled"] = enabled
        
        try:
            if enabled:

                if "xp_rate" not in leveling_config:
                    leveling_config["xp_rate"] = {"min": 15, "max": 25}
                    leveling_config["level_roles"] = {}
                    leveling_config["announcement_channel_id"] = None
                

                if "cogs.leveling" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.leveling")
                    logger.info(f"Leveling system enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Leveling system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "leveling", leveling_config)
        except Exception as e:
            logger.error(f"Error toggling leveling system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the leveling system: {e}", ephemeral=True)
        
    async def toggle_music_system(self, interaction, enabled):
        music_config = self.config_manager.get_category(interaction.guild.id, "music") or {}
        music_config["enabled"] = enabled
        self.config_manager.set_category(interaction.guild.id, "music", music_config)
        
        try:
            if enabled:

                if "cogs.music" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.music")
                    logger.info(f"Music system enabled for guild {interaction.guild.id}")
                

                if "default_volume" not in music_config:
                    music_config["default_volume"] = 70
                    music_config["announce_songs"] = True
                    music_config["dj_role_id"] = None
                    self.config_manager.set_category(interaction.guild.id, "music", music_config)
            else:

                logger.info(f"Music system disabled for guild {interaction.guild.id}")
                

                if hasattr(self.bot, 'wavelink') and self.bot.wavelink:
                    player = self.bot.wavelink.get_player(interaction.guild.id)
                    if player and player.is_connected:
                        await player.disconnect()
        except Exception as e:
            logger.error(f"Failed to toggle music system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the music system: {e}", ephemeral=True)
        
    async def toggle_analytics_system(self, interaction, enabled):
        analytics_config = self.config_manager.get_category(interaction.guild.id, "analytics") or {}
        analytics_config["enabled"] = enabled
        
        try:
            if enabled:

                if "track_messages" not in analytics_config:
                    analytics_config["track_messages"] = True
                    analytics_config["track_voice"] = True
                    analytics_config["track_members"] = True
                    analytics_config["data_retention_days"] = 30
                

                if "cogs.analytics" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.analytics")
                

                self.bot.dispatch("analytics_enabled", interaction.guild)
                logger.info(f"Analytics system enabled for guild {interaction.guild.id}")
            else:

                self.bot.dispatch("analytics_disabled", interaction.guild)
                logger.info(f"Analytics system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "analytics", analytics_config)
        except Exception as e:
            logger.error(f"Error toggling analytics system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the analytics system: {e}", ephemeral=True)
        
    async def toggle_custom_commands(self, interaction, enabled):
        custom_cmds_config = self.config_manager.get_category(interaction.guild.id, "custom_commands") or {}
        custom_cmds_config["enabled"] = enabled
        
        try:
            if enabled:

                if "commands" not in custom_cmds_config:
                    custom_cmds_config["commands"] = {}
                

                if "cogs.custom_commands" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.custom_commands")
                    logger.info(f"Custom commands system enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Custom commands system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "custom_commands", custom_cmds_config)
        except Exception as e:
            logger.error(f"Error toggling custom commands system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the custom commands system: {e}", ephemeral=True)
        
    async def toggle_mood_tracking(self, interaction, enabled):
        mood_config = self.config_manager.get_category(interaction.guild.id, "mood_tracking") or {}
        mood_config["enabled"] = enabled
        
        try:
            if enabled:

                if "cogs.mood_tracking" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.mood_tracking")
                    logger.info(f"Mood tracking system enabled for guild {interaction.guild.id}")
                

                await self.setup_mood_tracking(interaction.guild)
            else:
                logger.info(f"Mood tracking system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "mood_tracking", mood_config)
        except Exception as e:
            logger.error(f"Error toggling mood tracking system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the mood tracking system: {e}", ephemeral=True)
        
    async def toggle_study_tools(self, interaction, enabled):
        study_config = self.config_manager.get_category(interaction.guild.id, "study_tools") or {}
        study_config["enabled"] = enabled
        
        try:
            if enabled:

                if "pomodoro" not in study_config:
                    study_config["pomodoro"] = {
                        "work_minutes": 25,
                        "break_minutes": 5,
                        "long_break_minutes": 15,
                        "sessions_before_long_break": 4
                    }
                    study_config["focus_mode_enabled"] = False
                

                if "cogs.study_tools" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.study_tools")
                    logger.info(f"Study tools system enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Study tools system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "study_tools", study_config)
        except Exception as e:
            logger.error(f"Error toggling study tools system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the study tools system: {e}", ephemeral=True)
        
    async def toggle_ghost_ping(self, interaction, enabled):
        ghost_ping_config = self.config_manager.get_category(interaction.guild.id, "ghost_ping") or {}
        ghost_ping_config["enabled"] = enabled
        
        try:
            if enabled:

                if "strict_mode" not in ghost_ping_config:
                    ghost_ping_config["strict_mode"] = False
                    ghost_ping_config["strikes"] = {}
                    ghost_ping_config["strike_limit"] = 3
                    ghost_ping_config["punishment"] = "warn"
                

                if "cogs.ghost_ping" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.ghost_ping")
                    logger.info(f"Ghost ping detection enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Ghost ping detection disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "ghost_ping", ghost_ping_config)
        except Exception as e:
            logger.error(f"Error toggling ghost ping detection: {e}")
            await interaction.followup.send(f"An error occurred while toggling ghost ping detection: {e}", ephemeral=True)

    
    async def toggle_automod_system(self, interaction, enabled):
        automod_config = self.config_manager.get_category(interaction.guild.id, "automod") or {}
        automod_config["enabled"] = enabled
        
        try:
            if enabled:

                if "caps_threshold" not in automod_config:
                    automod_config["caps_threshold"] = 0.7  # 70% caps threshold
                    automod_config["spam_threshold"] = 5    # 5 messages in spam interval
                    automod_config["spam_interval"] = 5     # 5 seconds
                    automod_config["banned_words"] = []
                    automod_config["link_whitelist"] = []
                

                if "cogs.automod" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.automod")
                    logger.info(f"Automod system enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Automod system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "automod", automod_config)
        except Exception as e:
            logger.error(f"Error toggling automod system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the automod system: {e}", ephemeral=True)
    
    async def toggle_ticket_system(self, interaction, enabled):
        ticket_config = self.config_manager.get_category(interaction.guild.id, "ticket") or {}
        ticket_config["enabled"] = enabled
        
        try:
            if enabled:

                if "support_role_id" not in ticket_config:
                    ticket_config["support_role_id"] = None
                    ticket_config["ticket_category_id"] = None
                    ticket_config["ticket_counter"] = 0
                    ticket_config["log_channel_id"] = None
                

                if "cogs.ticket" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.ticket")
                    logger.info(f"Ticket system enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Ticket system disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "ticket", ticket_config)
        except Exception as e:
            logger.error(f"Error toggling ticket system: {e}")
            await interaction.followup.send(f"An error occurred while toggling the ticket system: {e}", ephemeral=True)
    
    async def toggle_fun_commands(self, interaction, enabled):
        fun_config = self.config_manager.get_category(interaction.guild.id, "fun") or {}
        fun_config["enabled"] = enabled
        
        try:
            if enabled:

                if "cogs.fun" not in self.bot.extensions:
                    await self.bot.load_extension("cogs.fun")
                    logger.info(f"Fun commands enabled for guild {interaction.guild.id}")
            else:
                logger.info(f"Fun commands disabled for guild {interaction.guild.id}")
            
            self.config_manager.set_category(interaction.guild.id, "fun", fun_config)
        except Exception as e:
            logger.error(f"Error toggling fun commands: {e}")
            await interaction.followup.send(f"An error occurred while toggling fun commands: {e}", ephemeral=True)
        
    async def setup_mood_tracking(self, guild):


        mood_config = self.config_manager.get_category(guild.id, "mood_tracking") or {}
        channel_id = mood_config.get("channel_id")
        
        if not channel_id or not guild.get_channel(int(channel_id) if channel_id else 0):
            try:

                overwrites = {
                    guild.default_role: discord.PermissionOverwrite(read_messages=True, send_messages=False),
                    guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True, manage_messages=True)
                }
                
                channel = await guild.create_text_channel(
                    "mood-tracking",
                    overwrites=overwrites,
                    topic="Track your mood with ZygnalBot's mood tracking system!"
                )
                
                mood_config["channel_id"] = str(channel.id)
                self.config_manager.set_category(guild.id, "mood_tracking", mood_config)
                

                embed = discord.Embed(
                    title="🌈 Mood Tracking System",
                    description="React with the emoji that best represents your current mood!",
                    color=discord.Color.blue()
                )
                embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Mood Tracking System")
                
                message = await channel.send(embed=embed)
                await message.add_reaction("😄")  # Happy
                await message.add_reaction("😊")  # Content
                await message.add_reaction("😐")  # Neutral
                await message.add_reaction("😔")  # Sad
                await message.add_reaction("😡")  # Angry
                
                mood_config["message_id"] = str(message.id)
                self.config_manager.set_category(guild.id, "mood_tracking", mood_config)
                
                logger.info(f"Created mood tracking channel in guild {guild.id}")
            except discord.Forbidden:
                logger.error(f"Failed to create mood tracking channel in guild {guild.id}: Missing permissions")
            except Exception as e:
                logger.error(f"Failed to set up mood tracking: {e}")


class AutoModConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "automod") or {}
        
    @discord.ui.button(label="Configure Filters", style=discord.ButtonStyle.primary)
    async def configure_filters(self, interaction: discord.Interaction, button: discord.ui.Button):

        await interaction.response.send_message("Automod filter configuration coming soon!", ephemeral=True)
        
    @discord.ui.button(label="Set Action", style=discord.ButtonStyle.primary)
    async def set_action(self, interaction: discord.Interaction, button: discord.ui.Button):

        await interaction.response.send_message("Automod action configuration coming soon!", ephemeral=True)
        
    @discord.ui.button(label="Toggle Automod", style=discord.ButtonStyle.success)
    async def toggle_automod(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_state = self.config.get("enabled", False)
        self.config["enabled"] = not current_state
        self.bot.config_manager.set_category(self.guild.id, "automod", self.config)
        
        status = "enabled" if not current_state else "disabled"
        await interaction.response.send_message(f"Automod has been {status}.", ephemeral=True)

class ChannelSelector(discord.ui.Select):
    def __init__(self, guild):
        options = []
        

        for i, channel in enumerate(guild.text_channels[:24]):
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            

        if len(guild.text_channels) > 24:
            options.append(
                discord.SelectOption(
                    label="More Channels...",
                    value="more_channels",
                    description="View additional channels"
                )
            )
            
        super().__init__(
            placeholder="Select a channel to configure...",
            min_values=1,
            max_values=1,
            options=options
        )
        
    async def callback(self, interaction: discord.Interaction):
        if self.values[0] == "more_channels":

            await interaction.response.send_message("Showing additional channels...", ephemeral=True)
        else:
            channel_id = int(self.values[0])
            channel = interaction.guild.get_channel(channel_id)
            

            self.view.selected_channel = channel
            
            await interaction.response.send_message(f"Selected channel: {channel.mention}", ephemeral=True)

class RoleSelector(discord.ui.Select):
    def __init__(self, guild):
        options = []
        

        for i, role in enumerate(sorted(guild.roles, key=lambda r: r.position, reverse=True)[:24]):
            if role.name != "@everyone":  # Skip the default role
                options.append(
                    discord.SelectOption(
                        label=role.name,
                        value=str(role.id),
                        description=f"Role with {len(role.members)} members"
                    )
                )
            

        if len(guild.roles) > 25:
            options.append(
                discord.SelectOption(
                    label="More Roles...",
                    value="more_roles",
                    description="View additional roles"
                )
            )
            
        super().__init__(
            placeholder="Select a role to configure...",
            min_values=1,
            max_values=1,
            options=options
        )
        
    async def callback(self, interaction: discord.Interaction):
        if self.values[0] == "more_roles":

            await interaction.response.send_message("Showing additional roles...", ephemeral=True)
        else:
            role_id = int(self.values[0])
            role = interaction.guild.get_role(role_id)
            

            self.view.selected_role = role
            
            await interaction.response.send_message(f"Selected role: {role.name}", ephemeral=True)

class UserSelector(discord.ui.Select):
    def __init__(self, guild):
        options = []
        

        for i, member in enumerate(list(guild.members)[:24]):
            options.append(
                discord.SelectOption(
                    label=f"{member.name}",
                    value=str(member.id),
                    description=f"{member.display_name}"
                )
            )
            

        options.append(
            discord.SelectOption(
                label="Search User...",
                value="search_user",
                description="Search for a specific user"
            )
        )
            
        super().__init__(
            placeholder="Select a user to configure...",
            min_values=1,
            max_values=1,
            options=options
        )
        
    async def callback(self, interaction: discord.Interaction):
        if self.values[0] == "search_user":

            await interaction.response.send_modal(UserSearchModal(self.view))
        else:
            user_id = int(self.values[0])
            user = interaction.guild.get_member(user_id)
            

            self.view.selected_user = user
            
            await interaction.response.send_message(f"Selected user: {user.mention}", ephemeral=True)

class FeatureSelector(discord.ui.Select):
    def __init__(self, bot, guild):
        self.bot = bot
        self.guild = guild
        

        features_config = bot.config_manager.get_category(guild.id, "features") or {}
        

        options = [
            discord.SelectOption(
                label="Welcome System",
                value="welcome",
                description="Customizable welcome messages",
                emoji="👋",
                default=features_config.get("welcome", False)
            ),
            discord.SelectOption(
                label="Leveling System",
                value="leveling",
                description="XP and level-up rewards",
                emoji="📈",
                default=features_config.get("leveling", False)
            ),
            discord.SelectOption(
                label="Music System",
                value="music",
                description="Play music in voice channels",
                emoji="🎵",
                default=features_config.get("music", False)
            ),
            discord.SelectOption(
                label="Analytics",
                value="analytics",
                description="Server activity tracking",
                emoji="📊",
                default=features_config.get("analytics", False)
            ),
            discord.SelectOption(
                label="Custom Commands",
                value="custom_cmds",
                description="Create custom bot commands",
                emoji="🤖",
                default=features_config.get("custom_cmds", False)
            ),
            discord.SelectOption(
                label="Mood Tracking",
                value="mood",
                description="Track server mood with reactions",
                emoji="🌈",
                default=features_config.get("mood", False)
            ),
            discord.SelectOption(
                label="Study Tools",
                value="study",
                description="Pomodoro timer and study aids",
                emoji="📚",
                default=features_config.get("study", False)
            ),
            discord.SelectOption(
                label="Ghost Ping Protection",
                value="ghost_ping",
                description="Detect and prevent ghost pings",
                emoji="👻",
                default=features_config.get("ghost_ping", False)
            ),
            discord.SelectOption(
                label="Whitelist System",
                value="whitelist",
                description="Control access to bot features",
                emoji="✅",
                default=features_config.get("whitelist", False)
            )
        ]
        
        super().__init__(
            placeholder="Select a feature to configure...",
            min_values=1,
            max_values=1,
            options=options
        )
        
    async def callback(self, interaction: discord.Interaction):

        self.view.selected_feature = self.values[0]
        

        features_config = self.bot.config_manager.get_category(self.guild.id, "features") or {}
        is_enabled = features_config.get(self.values[0], False)
        
        status = "enabled" if is_enabled else "disabled"
        

        feature_info = {
            "welcome": {
                "name": "Welcome System",
                "description": "Send customizable welcome messages to new members."
            },
            "leveling": {
                "name": "Leveling System",
                "description": "Track user activity with XP and levels, with role rewards."
            },
            "music": {
                "name": "Music System",
                "description": "Play music in voice channels with queue management."
            },
            "analytics": {
                "name": "Analytics System",
                "description": "Track server activity and generate reports."
            },
            "custom_cmds": {
                "name": "Custom Commands",
                "description": "Create custom bot commands for your server."
            },
            "mood": {
                "name": "Mood Tracking",
                "description": "Track server mood with reaction-based system."
            },
            "study": {
                "name": "Study Tools",
                "description": "Pomodoro timer and other study aids."
            },
            "ghost_ping": {
                "name": "Ghost Ping Protection",
                "description": "Detect and prevent ghost pings in your server."
            },
            "whitelist": {
                "name": "Whitelist System",
                "description": "Control which users and roles can access bot features."
            }
        }
        
        feature = feature_info.get(self.values[0], {"name": "Unknown Feature", "description": "No description available."})
        
        embed = discord.Embed(
            title=f"{feature['name']} Configuration",
            description=feature['description'],
            color=discord.Color.blue() if is_enabled else discord.Color.light_grey()
        )
        
        embed.add_field(name="Status", value=f"Currently **{status}**", inline=False)
        

        if self.values[0] == "welcome":
            welcome_config = self.bot.config_manager.get_category(self.guild.id, "welcome") or {}
            channel_id = welcome_config.get("channel_id")
            if channel_id:
                channel = self.guild.get_channel(int(channel_id))
                channel_mention = channel.mention if channel else "Unknown Channel"
                embed.add_field(name="Welcome Channel", value=channel_mention, inline=True)
            
            embed.add_field(name="Uses Embed", value="Yes" if welcome_config.get("use_embed", True) else "No", inline=True)
            
        elif self.values[0] == "leveling":
            leveling_config = self.bot.config_manager.get_category(self.guild.id, "leveling") or {}
            xp_rate = leveling_config.get("xp_rate", {"min": 15, "max": 25})
            embed.add_field(name="XP Rate", value=f"{xp_rate['min']}-{xp_rate['max']} per message", inline=True)
            
            level_roles = leveling_config.get("level_roles", {})
            embed.add_field(name="Level Roles", value=f"{len(level_roles)} configured", inline=True)
            
        elif self.values[0] == "music":
            music_config = self.bot.config_manager.get_category(self.guild.id, "music") or {}
            dj_role_id = music_config.get("dj_role_id")
            if dj_role_id:
                dj_role = self.guild.get_role(int(dj_role_id))
                dj_role_name = dj_role.name if dj_role else "Unknown Role"
                embed.add_field(name="DJ Role", value=dj_role_name, inline=True)
            
            embed.add_field(name="Default Volume", value=f"{music_config.get('default_volume', 70)}%", inline=True)
            
        elif self.values[0] == "analytics":
            analytics_config = self.bot.config_manager.get_category(self.guild.id, "analytics") or {}
            tracking = []
            if analytics_config.get("track_messages", True):
                tracking.append("Messages")
            if analytics_config.get("track_voice", True):
                tracking.append("Voice")
            if analytics_config.get("track_members", True):
                tracking.append("Members")
                
            embed.add_field(name="Tracking", value=", ".join(tracking) or "None", inline=True)
            embed.add_field(name="Data Retention", value=f"{analytics_config.get('data_retention_days', 30)} days", inline=True)
            
        elif self.values[0] == "custom_cmds":
            custom_cmds_config = self.bot.config_manager.get_category(self.guild.id, "custom_commands") or {}
            commands = custom_cmds_config.get("commands", {})
            embed.add_field(name="Custom Commands", value=f"{len(commands)} configured", inline=True)
            
        elif self.values[0] == "mood":
            mood_config = self.bot.config_manager.get_category(self.guild.id, "mood_tracking") or {}
            channel_id = mood_config.get("channel_id")
            if channel_id:
                channel = self.guild.get_channel(int(channel_id))
                channel_mention = channel.mention if channel else "Unknown Channel"
                embed.add_field(name="Tracking Channel", value=channel_mention, inline=True)
            
            mood_roles = mood_config.get("mood_roles", {})
            embed.add_field(name="Mood Roles", value=f"{len(mood_roles)} configured", inline=True)
            
        elif self.values[0] == "study":
            study_config = self.bot.config_manager.get_category(self.guild.id, "study_tools") or {}
            pomodoro = study_config.get("pomodoro", {})
            if pomodoro:
                embed.add_field(
                    name="Pomodoro Settings", 
                    value=f"Work: {pomodoro.get('work_minutes', 25)}m, Break: {pomodoro.get('break_minutes', 5)}m", 
                    inline=True
                )
            
            focus_mode = "Enabled" if study_config.get("focus_mode_enabled", False) else "Disabled"
            embed.add_field(name="Focus Mode", value=focus_mode, inline=True)
            
        elif self.values[0] == "ghost_ping":
            ghost_config = self.bot.config_manager.get_category(self.guild.id, "ghost_ping") or {}
            strict_mode = "Enabled" if ghost_config.get("strict_mode", False) else "Disabled"
            embed.add_field(name="Strict Mode", value=strict_mode, inline=True)
            
            strike_limit = ghost_config.get("strike_limit", 3)
            embed.add_field(name="Strike Limit", value=str(strike_limit), inline=True)
            
            punishment = ghost_config.get("punishment", "warn")
            punishment_names = {
                "warn": "Warning",
                "timeout_5": "Timeout (5m)",
                "timeout_60": "Timeout (1h)",
                "timeout_1440": "Timeout (1d)",
                "kick": "Kick",
                "ban": "Ban"
            }
            embed.add_field(name="Punishment", value=punishment_names.get(punishment, "Unknown"), inline=True)
            
        elif self.values[0] == "whitelist":
            whitelist_config = self.bot.config_manager.get_category(self.guild.id, "whitelist") or {}
            entries = whitelist_config.get("entries", [])
            
            user_count = sum(1 for entry in entries if entry.startswith("user:"))
            role_count = sum(1 for entry in entries if entry.startswith("role:"))
            
            embed.add_field(name="Whitelisted Users", value=str(user_count), inline=True)
            embed.add_field(name="Whitelisted Roles", value=str(role_count), inline=True)
        
        embed.set_footer(text="Use the buttons below to configure this feature")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class PermissionModal(discord.ui.Modal):
    def __init__(self, permission_type, bot, guild_id, channel_id, role_id):
        super().__init__(title=f"Configure {permission_type} Permission")
        self.permission_type = permission_type
        self.bot = bot
        self.guild_id = guild_id
        self.channel_id = channel_id
        self.role_id = role_id
        
        self.add_item(
            discord.ui.TextInput(
                label="Allow (True/False/None)",
                placeholder="Type 'True' to allow, 'False' to deny, or 'None' to inherit",
                required=True,
                max_length=5
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Reason for change",
                placeholder="Enter a reason for this permission change",
                required=False,
                style=discord.TextStyle.paragraph
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        value = self.children[0].value.capitalize()
        reason = self.children[1].value
        
        if value not in ["True", "False", "None"]:
            await interaction.response.send_message("Invalid value. Please enter 'True', 'False', or 'None'.", ephemeral=True)
            return
        

        permission_mapping = {
            "View Channel": "view_channel",
            "Send Messages": "send_messages",
            "Read Message History": "read_message_history",
            "Manage Messages": "manage_messages",
            "Manage Channels": "manage_channels",
            "Connect": "connect",
            "Speak": "speak"
        }
        
        if self.permission_type not in permission_mapping:
            await interaction.response.send_message(f"Unknown permission type: {self.permission_type}", ephemeral=True)
            return
            
        permission_name = permission_mapping[self.permission_type]
        

        channel_perms = self.bot.config_manager.get_category(self.guild_id, "channel_permissions")
        if str(self.channel_id) not in channel_perms:
            channel_perms[str(self.channel_id)] = {}
        if str(self.role_id) not in channel_perms[str(self.channel_id)]:
            channel_perms[str(self.channel_id)][str(self.role_id)] = {}
            
        channel_perms[str(self.channel_id)][str(self.role_id)][permission_name] = value
        self.bot.config_manager.set_category(self.guild_id, "channel_permissions", channel_perms)
        

        guild = self.bot.get_guild(self.guild_id)
        if guild:
            channel = guild.get_channel(self.channel_id)
            role = guild.get_role(self.role_id)
            
            if channel and role:
                try:
                    perms = channel.overwrites_for(role)
                    
                    if value == "True":
                        setattr(perms, permission_name, True)
                    elif value == "False":
                        setattr(perms, permission_name, False)
                    else:  # None
                        setattr(perms, permission_name, None)
                        
                    await channel.set_permissions(role, overwrite=perms, reason=f"{reason or 'No reason provided'} (via ZygnalBot config)")
                except discord.Forbidden:
                    await interaction.response.send_message("I don't have permission to modify channel permissions. The setting has been saved but not applied.", ephemeral=True)
                    return
                except Exception as e:
                    logger.error(f"Error applying permission: {e}")
                    await interaction.response.send_message(f"An error occurred while applying the permission: {e}. The setting has been saved but not applied.", ephemeral=True)
                    return
        
        embed = discord.Embed(
            title="Permission Updated",
            description=f"The {self.permission_type} permission has been updated.",
            color=discord.Color.green()
        )
        
        embed.add_field(name="Permission", value=self.permission_type, inline=True)
        embed.add_field(name="Setting", value=value, inline=True)
        
        if reason:
            embed.add_field(name="Reason", value=reason, inline=False)
            
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Permission Management")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class RoleCreationModal(discord.ui.Modal):
    def __init__(self, bot, guild):
        super().__init__(title="Create New Role")
        self.bot = bot
        self.guild = guild
        
        self.add_item(
            discord.ui.TextInput(
                label="Role Name",
                placeholder="Enter the name for the new role",
                required=True,
                max_length=100
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Role Color (hex)",
                placeholder="Enter a hex color code (e.g., #FF0000)",
                required=False,
                max_length=7
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Role Description",
                placeholder="Enter a description for this role",
                required=False,
                style=discord.TextStyle.paragraph
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Permissions (comma-separated)",
                placeholder="E.g., send_messages,read_messages,manage_messages",
                required=False,
                style=discord.TextStyle.paragraph
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        role_name = self.children[0].value
        role_color = self.children[1].value
        role_description = self.children[2].value
        permissions_text = self.children[3].value
        

        color = discord.Color.default()
        if role_color and role_color.startswith("#") and len(role_color) == 7:
            try:
                color_int = int(role_color[1:], 16)
                color = discord.Color(color_int)
            except ValueError:
                await interaction.response.send_message("Invalid color format. Using default color instead.", ephemeral=True)
        

        permissions = discord.Permissions.none()
        if permissions_text:
            perm_names = [p.strip() for p in permissions_text.split(',')]
            for perm_name in perm_names:
                if hasattr(permissions, perm_name):
                    setattr(permissions, perm_name, True)
        

        try:
            role = await self.guild.create_role(
                name=role_name,
                color=color,
                permissions=permissions,
                reason=f"Created by {interaction.user} via ZygnalBot config"
            )
            

            if role_description:
                role_config = self.bot.config_manager.get_category(self.guild.id, "roles")
                role_config[str(role.id)] = {"description": role_description}
                self.bot.config_manager.set_category(self.guild.id, "roles", role_config)
            
            embed = discord.Embed(
                title="Role Created",
                description=f"The role **{role_name}** has been created successfully.",
                color=color
            )
            
            if role_description:
                embed.add_field(name="Description", value=role_description, inline=False)
                

            if permissions_text:
                embed.add_field(name="Permissions", value=permissions_text, inline=False)
                
            embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Role Management")
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to create roles.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error creating role: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)

class RoleEditModal(discord.ui.Modal):
    def __init__(self, bot, guild, role):
        super().__init__(title=f"Edit Role: {role.name}")
        self.bot = bot
        self.guild = guild
        self.role = role
        

        role_config = bot.config_manager.get_category(guild.id, "roles")
        role_description = role_config.get(str(role.id), {}).get("description", "")
        
        self.add_item(
            discord.ui.TextInput(
                label="Role Name",
                placeholder="Enter the new name for the role",
                required=True,
                max_length=100,
                default=role.name
            )
        )
        

        default_color = f"#{role.color.value:06x}" if role.color.value else ""
        
        self.add_item(
            discord.ui.TextInput(
                label="Role Color (hex)",
                placeholder="Enter a hex color code (e.g., #FF0000)",
                required=False,
                max_length=7,
                default=default_color
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Role Description",
                placeholder="Enter a description for this role",
                required=False,
                style=discord.TextStyle.paragraph,
                default=role_description
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        new_name = self.children[0].value
        new_color_hex = self.children[1].value
        new_description = self.children[2].value
        

        new_color = self.role.color
        if new_color_hex and new_color_hex.startswith("#") and len(new_color_hex) == 7:
            try:
                color_int = int(new_color_hex[1:], 16)
                new_color = discord.Color(color_int)
            except ValueError:
                await interaction.response.send_message("Invalid color format. Keeping current color.", ephemeral=True)
        

        try:
            await self.role.edit(
                name=new_name,
                color=new_color,
                reason=f"Edited by {interaction.user} via ZygnalBot config"
            )
            

            role_config = self.bot.config_manager.get_category(self.guild.id, "roles")
            if str(self.role.id) not in role_config:
                role_config[str(self.role.id)] = {}
            role_config[str(self.role.id)]["description"] = new_description
            self.bot.config_manager.set_category(self.guild.id, "roles", role_config)
            
            embed = discord.Embed(
                title="Role Updated",
                description=f"The role has been updated successfully.",
                color=new_color
            )
            
            embed.add_field(name="New Name", value=new_name, inline=True)
            embed.add_field(name="New Color", value=new_color_hex or "Unchanged", inline=True)
            
            if new_description:
                embed.add_field(name="Description", value=new_description, inline=False)
                
            embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Role Management")
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to edit this role.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error editing role: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)

class UserSearchModal(discord.ui.Modal):
    def __init__(self, parent_view):
        super().__init__(title="Search for User")
        self.parent_view = parent_view
        
        self.add_item(
            discord.ui.TextInput(
                label="Username or ID",
                placeholder="Enter username or user ID",
                required=True
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        search_term = self.children[0].value
        

        user = None
        

        if search_term.isdigit():
            user = interaction.guild.get_member(int(search_term))
        

        if not user:
            user = discord.utils.find(
                lambda m: search_term.lower() in m.name.lower() or 
                          (m.nick and search_term.lower() in m.nick.lower()),
                interaction.guild.members
            )
        
        if user:

            self.parent_view.selected_user = user
            
            embed = discord.Embed(
                title="User Found",
                description=f"Found user: {user.mention}",
                color=discord.Color.green()
            )
            
            embed.set_thumbnail(url=user.display_avatar.url)
            embed.add_field(name="Username", value=user.name, inline=True)
            embed.add_field(name="User ID", value=user.id, inline=True)
            
            if user.nick:
                embed.add_field(name="Nickname", value=user.nick, inline=True)
                
            embed.add_field(name="Joined Server", value=user.joined_at.strftime("%Y-%m-%d"), inline=True)
            embed.add_field(name="Account Created", value=user.created_at.strftime("%Y-%m-%d"), inline=True)
            
            roles = [role.mention for role in user.roles if role.name != "@everyone"]
            if roles:
                embed.add_field(name="Roles", value=" ".join(roles), inline=False)
            
            embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | User Management")
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
        else:
            await interaction.response.send_message(f"No user found matching '{search_term}'.", ephemeral=True)



class ConfirmationView(discord.ui.View):
    def __init__(self, prompt):
        super().__init__(timeout=60)
        self.value = None
        self.prompt = prompt
        
    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger, emoji="✅")
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = True
        await interaction.response.send_message("Action confirmed!", ephemeral=True)
        self.stop()
        
    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary, emoji="❌")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = False
        await interaction.response.send_message("Action cancelled.", ephemeral=True)
        self.stop()

class AntiSpamView(discord.ui.View):
    def __init__(self, bot, guild, settings):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.settings = settings or {}
        

        self.add_item(discord.ui.Button(
            label=f"Current Message Limit: {self.settings.get('message_limit', '5')}",
            style=discord.ButtonStyle.secondary,
            disabled=True
        ))
        
        self.add_item(discord.ui.Button(
            label=f"Current Time Window: {self.settings.get('time_window', '5')} seconds",
            style=discord.ButtonStyle.secondary,
            disabled=True
        ))
        
        self.add_item(discord.ui.Button(
            label=f"Current Punishment: {self.settings.get('punishment', 'timeout')}",
            style=discord.ButtonStyle.secondary,
            disabled=True
        ))
        
    @discord.ui.button(label="Set Message Limit", style=discord.ButtonStyle.primary)
    async def set_message_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(
            SpamSettingsModal("Message Limit", self.bot, self.guild, self.settings)
        )
        
    @discord.ui.button(label="Set Time Window", style=discord.ButtonStyle.primary)
    async def set_time_window(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(
            SpamSettingsModal("Time Window", self.bot, self.guild, self.settings)
        )
        
    @discord.ui.button(label="Set Punishment", style=discord.ButtonStyle.primary)
    async def set_punishment(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(
            SpamSettingsModal("Punishment", self.bot, self.guild, self.settings)
        )
        
    @discord.ui.button(label="Enable Anti-Spam", style=discord.ButtonStyle.success)
    async def enable_antispam(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["enabled"] = True
        self.bot.config_manager.set_category(self.guild.id, "anti_spam", self.settings)
        
        await interaction.response.send_message("Anti-spam system has been enabled!", ephemeral=True)
        
    @discord.ui.button(label="Disable Anti-Spam", style=discord.ButtonStyle.danger)
    async def disable_antispam(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["enabled"] = False
        self.bot.config_manager.set_category(self.guild.id, "anti_spam", self.settings)
        
        await interaction.response.send_message("Anti-spam system has been disabled!", ephemeral=True)

class WordFilterView(discord.ui.View):
    def __init__(self, bot, guild, filtered_words):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.filtered_words = filtered_words or []
        
    @discord.ui.button(label="Add Filtered Word", style=discord.ButtonStyle.primary)
    async def add_word(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(
            FilterWordModal("Add", self.bot, self.guild, self.filtered_words)
        )
        
    @discord.ui.button(label="Remove Filtered Word", style=discord.ButtonStyle.secondary)
    async def remove_word(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(
            FilterWordModal("Remove", self.bot, self.guild, self.filtered_words)
        )
        
    @discord.ui.button(label="View Filtered Words", style=discord.ButtonStyle.success)
    async def view_words(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="Filtered Words List",
            description="Here are the currently filtered words:",
            color=discord.Color.red()
        )
        
        if self.filtered_words:

            words_by_punishment = {}
            for word_data in self.filtered_words:
                punishment = word_data.get("punishment", "delete")
                if punishment not in words_by_punishment:
                    words_by_punishment[punishment] = []
                words_by_punishment[punishment].append(word_data["word"])
            
            for punishment, words in words_by_punishment.items():
                embed.add_field(
                    name=f"Words with '{punishment}' punishment",
                    value="• " + "\n• ".join([f"`{word}`" for word in words]),
                    inline=False
                )
        else:
            embed.add_field(name="No Filtered Words", value="You haven't added any filtered words yet.", inline=False)
            
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Word Filter System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
    @discord.ui.button(label="Enable Word Filter", style=discord.ButtonStyle.success)
    async def enable_filter(self, interaction: discord.Interaction, button: discord.ui.Button):
        filter_settings = self.bot.config_manager.get_category(self.guild.id, "word_filter")
        filter_settings["enabled"] = True
        filter_settings["words"] = self.filtered_words
        self.bot.config_manager.set_category(self.guild.id, "word_filter", filter_settings)
        
        await interaction.response.send_message("Word filter has been enabled!", ephemeral=True)
        
    @discord.ui.button(label="Disable Word Filter", style=discord.ButtonStyle.danger)
    async def disable_filter(self, interaction: discord.Interaction, button: discord.ui.Button):
        filter_settings = self.bot.config_manager.get_category(self.guild.id, "word_filter")
        filter_settings["enabled"] = False
        filter_settings["words"] = self.filtered_words
        self.bot.config_manager.set_category(self.guild.id, "word_filter", filter_settings)
        
        await interaction.response.send_message("Word filter has been disabled!", ephemeral=True)

class RaidProtectionView(discord.ui.View):
    def __init__(self, bot, guild, settings):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.settings = settings or {}
        

        self.add_item(discord.ui.Button(
            label=f"Join Rate: {self.settings.get('join_rate', '10')} joins/minute",
            style=discord.ButtonStyle.secondary,
            disabled=True
        ))
        
        self.add_item(discord.ui.Button(
            label=f"Min Account Age: {self.settings.get('min_account_age', '1')} days",
            style=discord.ButtonStyle.secondary,
            disabled=True
        ))
        
        self.add_item(discord.ui.Button(
            label=f"Verification Level: {self.settings.get('verification_level', 'medium')}",
            style=discord.ButtonStyle.secondary,
            disabled=True
        ))
        
    @discord.ui.button(label="Configure Thresholds", style=discord.ButtonStyle.primary)
    async def configure_thresholds(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(
            RaidSettingsModal(self.bot, self.guild, self.settings)
        )
        
    @discord.ui.button(label="Enable Raid Mode", style=discord.ButtonStyle.danger)
    async def enable_raid_mode(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["raid_mode_active"] = True
        self.bot.config_manager.set_category(self.guild.id, "raid_protection", self.settings)
        

        try:

            verification_level = self.settings.get("verification_level", "medium").lower()
            if verification_level == "low":
                await self.guild.edit(verification_level=discord.VerificationLevel.low)
            elif verification_level == "medium":
                await self.guild.edit(verification_level=discord.VerificationLevel.medium)
            elif verification_level == "high":
                await self.guild.edit(verification_level=discord.VerificationLevel.high)
            elif verification_level == "highest":
                await self.guild.edit(verification_level=discord.VerificationLevel.highest)
                

            mod_channel = self.guild.get_channel(int(self.settings.get("mod_channel_id", 0) or 0))
            if mod_channel:
                embed = discord.Embed(
                    title="⚠️ RAID MODE ACTIVATED",
                    description="Raid protection mode has been enabled. New joins will be strictly monitored.",
                    color=discord.Color.red(),
                    timestamp=datetime.now()
                )
                embed.add_field(name="Activated By", value=interaction.user.mention, inline=True)
                embed.add_field(name="Verification Level", value=verification_level.capitalize(), inline=True)
                
                await mod_channel.send(embed=embed)
                
            await interaction.response.send_message("⚠️ Raid protection mode has been enabled!", ephemeral=True)
            
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to change server settings.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error enabling raid mode: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)
        
    @discord.ui.button(label="Disable Raid Mode", style=discord.ButtonStyle.secondary)
    async def disable_raid_mode(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["raid_mode_active"] = False
        self.bot.config_manager.set_category(self.guild.id, "raid_protection", self.settings)
        

        try:

            await self.guild.edit(verification_level=discord.VerificationLevel.low)
                

            mod_channel = self.guild.get_channel(int(self.settings.get("mod_channel_id", 0) or 0))
            if mod_channel:
                embed = discord.Embed(
                    title="✅ RAID MODE DEACTIVATED",
                    description="Raid protection mode has been disabled. Server has returned to normal operation.",
                    color=discord.Color.green(),
                    timestamp=datetime.now()
                )
                embed.add_field(name="Deactivated By", value=interaction.user.mention, inline=True)
                
                await mod_channel.send(embed=embed)
                
            await interaction.response.send_message("Raid protection mode has been disabled.", ephemeral=True)
            
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to change server settings.", ephemeral=True)
        except Exception as e:
            logger.error(f"Error disabling raid mode: {e}")
            await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)
            
    @discord.ui.button(label="Set Mod Channel", style=discord.ButtonStyle.primary)
    async def set_mod_channel(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for channel in self.guild.text_channels[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a channel for raid notifications...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            channel_id = int(select.values[0])
            self.settings["mod_channel_id"] = str(channel_id)
            self.bot.config_manager.set_category(self.guild.id, "raid_protection", self.settings)
            
            channel = self.guild.get_channel(channel_id)
            await interaction.response.send_message(f"Raid notifications will now be sent to {channel.mention}.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a channel for raid notifications:", view=view, ephemeral=True)

class SpamSettingsModal(discord.ui.Modal):
    def __init__(self, setting_type, bot, guild, settings):
        super().__init__(title=f"Configure {setting_type}")
        self.setting_type = setting_type
        self.bot = bot
        self.guild = guild
        self.settings = settings or {}
        

        default_value = ""
        if setting_type == "Message Limit":
            default_value = str(self.settings.get("message_limit", "5"))
        elif setting_type == "Time Window":
            default_value = str(self.settings.get("time_window", "5"))
        elif setting_type == "Punishment":
            default_value = self.settings.get("punishment", "timeout")
        
        self.add_item(
            discord.ui.TextInput(
                label=setting_type,
                placeholder="Enter the new value",
                required=True,
                default=default_value
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        value = self.children[0].value
        

        if self.setting_type == "Message Limit" or self.setting_type == "Time Window":
            if not value.isdigit() or int(value) <= 0:
                await interaction.response.send_message("Please enter a positive number.", ephemeral=True)
                return
                
        elif self.setting_type == "Punishment":
            valid_punishments = ["delete", "warn", "timeout", "kick", "ban"]
            if value.lower() not in valid_punishments:
                await interaction.response.send_message(
                    f"Invalid punishment type. Please use one of: {', '.join(valid_punishments)}",
                    ephemeral=True
                )
                return
        

        setting_key = self.setting_type.lower().replace(" ", "_")
        self.settings[setting_key] = value
        self.bot.config_manager.set_category(self.guild.id, "anti_spam", self.settings)
        
        embed = discord.Embed(
            title="Anti-Spam Setting Updated",
            description=f"The {self.setting_type} has been updated to: {value}",
            color=discord.Color.green()
        )
        
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Anti-Spam System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class FilterWordModal(discord.ui.Modal):
    def __init__(self, action_type, bot, guild, filtered_words):
        super().__init__(title=f"{action_type} Filtered Word")
        self.action_type = action_type
        self.bot = bot
        self.guild = guild
        self.filtered_words = filtered_words
        
        self.add_item(
            discord.ui.TextInput(
                label="Word or Phrase",
                placeholder="Enter the word or phrase to filter",
                required=True
            )
        )
        
        if action_type == "Add":
            self.add_item(
                discord.ui.TextInput(
                    label="Punishment",
                    placeholder="Enter 'delete', 'warn', 'timeout', or 'kick'",
                    required=False,
                    default="delete"
                )
            )
        
    async def on_submit(self, interaction: discord.Interaction):
        word = self.children[0].value
        
        if self.action_type == "Add":
            punishment = self.children[1].value.lower() if len(self.children) > 1 else "delete"
            

            valid_punishments = ["delete", "warn", "timeout", "kick", "ban"]
            if punishment not in valid_punishments:
                await interaction.response.send_message(
                    f"Invalid punishment type. Using 'delete' instead. Valid options are: {', '.join(valid_punishments)}",
                    ephemeral=True
                )
                punishment = "delete"
            

            self.filtered_words.append({"word": word, "punishment": punishment})
            

            filter_settings = self.bot.config_manager.get_category(self.guild.id, "word_filter")
            filter_settings["words"] = self.filtered_words
            self.bot.config_manager.set_category(self.guild.id, "word_filter", filter_settings)
            
            embed = discord.Embed(
                title="Word Filter Updated",
                description=f"The word/phrase has been added to the filter.",
                color=discord.Color.green()
            )
            embed.add_field(name="Word/Phrase", value=f"`{word}`", inline=True)
            embed.add_field(name="Punishment", value=punishment, inline=True)
        else:

            found = False
            for i, word_data in enumerate(self.filtered_words):
                if word_data["word"].lower() == word.lower():
                    self.filtered_words.pop(i)
                    found = True
                    break
            
            if not found:
                await interaction.response.send_message(f"Word/phrase `{word}` was not found in the filter.", ephemeral=True)
                return
                

            filter_settings = self.bot.config_manager.get_category(self.guild.id, "word_filter")
            filter_settings["words"] = self.filtered_words
            self.bot.config_manager.set_category(self.guild.id, "word_filter", filter_settings)
            
            embed = discord.Embed(
                title="Word Filter Updated",
                description=f"The word/phrase has been removed from the filter.",
                color=discord.Color.green()
            )
            embed.add_field(name="Word/Phrase", value=f"`{word}`", inline=True)
        
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Word Filter System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class RaidSettingsModal(discord.ui.Modal):
    def __init__(self, bot, guild, settings):
        super().__init__(title="Raid Protection Settings")
        self.bot = bot
        self.guild = guild
        self.settings = settings or {}
        
        self.add_item(
            discord.ui.TextInput(
                label="Join Rate Threshold",
                placeholder="Number of joins per minute to trigger raid mode",
                required=True,
                default=str(self.settings.get("join_rate", "10"))
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Account Age Minimum (days)",
                placeholder="Minimum account age in days",
                required=True,
                default=str(self.settings.get("min_account_age", "1"))
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Verification Level",
                placeholder="Enter 'low', 'medium', 'high', or 'highest'",
                required=True,
                default=self.settings.get("verification_level", "medium")
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        join_rate = self.children[0].value
        account_age = self.children[1].value
        verification = self.children[2].value.lower()
        

        if not join_rate.isdigit() or int(join_rate) <= 0:
            await interaction.response.send_message("Join rate must be a positive number.", ephemeral=True)
            return
            
        if not account_age.isdigit() or int(account_age) < 0:
            await interaction.response.send_message("Account age must be a non-negative number.", ephemeral=True)
            return
            
        valid_verification_levels = ["low", "medium", "high", "highest"]
        if verification not in valid_verification_levels:
            await interaction.response.send_message(
                f"Invalid verification level. Please use one of: {', '.join(valid_verification_levels)}",
                ephemeral=True
            )
            return
        

        self.settings["join_rate"] = join_rate
        self.settings["min_account_age"] = account_age
        self.settings["verification_level"] = verification
        self.bot.config_manager.set_category(self.guild.id, "raid_protection", self.settings)
        
        embed = discord.Embed(
            title="Raid Protection Settings Updated",
            description="Your raid protection settings have been updated.",
            color=discord.Color.green()
        )
        
        embed.add_field(name="Join Rate Threshold", value=f"{join_rate} joins/minute", inline=True)
        embed.add_field(name="Minimum Account Age", value=f"{account_age} days", inline=True)
        embed.add_field(name="Verification Level", value=verification.capitalize(), inline=True)
        
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Raid Protection System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)



class WelcomeConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "welcome") or {}
        
    @discord.ui.button(label="Set Welcome Channel", style=discord.ButtonStyle.primary)
    async def set_channel(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for channel in self.guild.text_channels[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a welcome channel...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            channel_id = int(select.values[0])
            self.config["channel_id"] = str(channel_id)
            self.bot.config_manager.set_category(self.guild.id, "welcome", self.config)
            
            channel = self.guild.get_channel(channel_id)
            await interaction.response.send_message(f"Welcome messages will now be sent to {channel.mention}.", ephemeral=True)
            

            if hasattr(self.bot, 'welcome_system'):
                self.bot.welcome_system.update_config(self.guild.id)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a channel for welcome messages:", view=view, ephemeral=True)
        
    @discord.ui.button(label="Customize Message", style=discord.ButtonStyle.primary)
    async def customize_message(self, interaction: discord.Interaction, button: discord.ui.Button):

        current_message = self.config.get("message", "Welcome to {server}, {user}!")
        

        class WelcomeMessageModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Customize Welcome Message")
                self.config_view = config_view
                
                self.message = discord.ui.TextInput(
                    label="Welcome Message",
                    placeholder="Enter your welcome message here...",
                    default=current_message,
                    style=discord.TextStyle.paragraph,
                    required=True,
                    max_length=1000
                )
                
                self.add_item(self.message)
                
            async def on_submit(self, interaction: discord.Interaction):
                self.config_view.config["message"] = self.message.value
                self.config_view.bot.config_manager.set_category(
                    self.config_view.guild.id, "welcome", self.config_view.config
                )
                

                if hasattr(self.config_view.bot, 'welcome_system'):
                    self.config_view.bot.welcome_system.update_config(self.config_view.guild.id)
                
                await interaction.response.send_message(
                    "Welcome message updated! Available placeholders: {user}, {server}, {member_count}", 
                    ephemeral=True
                )
        
        await interaction.response.send_modal(WelcomeMessageModal(self))
        
    @discord.ui.button(label="Toggle Embed", style=discord.ButtonStyle.primary)
    async def toggle_embed(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("use_embed", True)
        self.config["use_embed"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "welcome", self.config)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Welcome message embeds have been {status}.", ephemeral=True)
        

        if hasattr(self.bot, 'welcome_system'):
            self.bot.welcome_system.update_config(self.guild.id)
        
    @discord.ui.button(label="Set Embed Color", style=discord.ButtonStyle.primary)
    async def set_embed_color(self, interaction: discord.Interaction, button: discord.ui.Button):

        current_color = self.config.get("embed_color", "3447003")
        

        class ColorModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Set Embed Color")
                self.config_view = config_view
                
                self.color = discord.ui.TextInput(
                    label="Color (Hex code without #)",
                    placeholder="e.g. 3498db for blue",
                    default=current_color,
                    required=True,
                    max_length=6
                )
                
                self.add_item(self.color)
                
            async def on_submit(self, interaction: discord.Interaction):

                try:
                    color_value = self.color.value.strip()
                    if color_value.startswith("#"):
                        color_value = color_value[1:]
                    

                    int(color_value, 16)
                    
                    self.config_view.config["embed_color"] = color_value
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "welcome", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'welcome_system'):
                        self.config_view.bot.welcome_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(f"Embed color updated to #{color_value}!", ephemeral=True)
                except ValueError:
                    await interaction.response.send_message("Invalid hex color! Please use a valid hex color code.", ephemeral=True)
        
        await interaction.response.send_modal(ColorModal(self))
        
    @discord.ui.button(label="Preview Message", style=discord.ButtonStyle.success)
    async def preview_message(self, interaction: discord.Interaction, button: discord.ui.Button):

        message_template = self.config.get("message", "Welcome to {server}, {user}!")
        

        preview_message = message_template.format(
            user=interaction.user.mention,
            server=self.guild.name,
            member_count=self.guild.member_count
        )
        

        if self.config.get("use_embed", True):
            embed = discord.Embed(
                title=self.config.get("embed_title", "Welcome!"),
                description=preview_message,
                color=discord.Color(int(self.config.get("embed_color", "3447003"), 16))
            )
            
            if self.config.get("show_avatar", True):
                embed.set_thumbnail(url=interaction.user.display_avatar.url)
                
            await interaction.response.send_message("Here's a preview of your welcome message:", embed=embed, ephemeral=True)
        else:
            await interaction.response.send_message(f"Here's a preview of your welcome message:\n\n{preview_message}", ephemeral=True)

class LevelingConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "leveling") or {}
        
    @discord.ui.button(label="Set XP Rate", style=discord.ButtonStyle.primary)
    async def set_xp_rate(self, interaction: discord.Interaction, button: discord.ui.Button):

        current_min = self.config.get("xp_rate", {}).get("min", 15)
        current_max = self.config.get("xp_rate", {}).get("max", 25)
        

        class XPSettingsModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Set XP Rate")
                self.config_view = config_view
                
                self.min_xp = discord.ui.TextInput(
                    label="Minimum XP per message",
                    placeholder="Enter minimum XP (e.g. 15)",
                    default=str(current_min),
                    required=True
                )
                
                self.max_xp = discord.ui.TextInput(
                    label="Maximum XP per message",
                    placeholder="Enter maximum XP (e.g. 25)",
                    default=str(current_max),
                    required=True
                )
                
                self.add_item(self.min_xp)
                self.add_item(self.max_xp)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    min_xp = int(self.min_xp.value)
                    max_xp = int(self.max_xp.value)
                    
                    if min_xp < 1 or max_xp < 1:
                        await interaction.response.send_message("XP values must be positive numbers.", ephemeral=True)
                        return
                        
                    if min_xp > max_xp:
                        await interaction.response.send_message("Minimum XP cannot be greater than maximum XP.", ephemeral=True)
                        return
                    
                    self.config_view.config["xp_rate"] = {"min": min_xp, "max": max_xp}
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "leveling", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'leveling_system'):
                        self.config_view.bot.leveling_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(
                        f"XP rate updated! Users will now receive {min_xp}-{max_xp} XP per message.", 
                        ephemeral=True
                    )
                except ValueError:
                    await interaction.response.send_message("Invalid input! Please enter valid numbers.", ephemeral=True)
        
        await interaction.response.send_modal(XPSettingsModal(self))
        
    @discord.ui.button(label="Configure Level Roles", style=discord.ButtonStyle.primary)
    async def configure_level_roles(self, interaction: discord.Interaction, button: discord.ui.Button):

        class LevelRolesView(discord.ui.View):
            def __init__(self, bot, guild, config):
                super().__init__(timeout=180)
                self.bot = bot
                self.guild = guild
                self.config = config
                self.level_roles = config.get("level_roles", {})
                
            @discord.ui.button(label="Add Level Role", style=discord.ButtonStyle.success)
            async def add_level_role(self, interaction: discord.Interaction, button: discord.ui.Button):

                class AddLevelRoleModal(discord.ui.Modal):
                    def __init__(self, roles_view):
                        super().__init__(title="Add Level Role")
                        self.roles_view = roles_view
                        
                        self.level = discord.ui.TextInput(
                            label="Level",
                            placeholder="Enter level number (e.g. 10)",
                            required=True
                        )
                        
                        self.add_item(self.level)
                        
                    async def on_submit(self, interaction: discord.Interaction):
                        try:
                            level = int(self.level.value)
                            
                            if level < 1:
                                await interaction.response.send_message("Level must be a positive number.", ephemeral=True)
                                return
                            

                            options = []
                            for role in sorted(self.roles_view.guild.roles, key=lambda r: r.position, reverse=True)[:25]:
                                if role.name != "@everyone" and not role.managed:
                                    options.append(
                                        discord.SelectOption(
                                            label=role.name,
                                            value=str(role.id),
                                            description=f"Role with {len(role.members)} members"
                                        )
                                    )
                                
                            select = discord.ui.Select(
                                placeholder="Select a role for this level...",
                                min_values=1,
                                max_values=1,
                                options=options
                            )
                            
                            async def select_callback(interaction: discord.Interaction):
                                role_id = select.values[0]
                                role = self.roles_view.guild.get_role(int(role_id))
                                

                                self.roles_view.level_roles[str(level)] = role_id
                                self.roles_view.config["level_roles"] = self.roles_view.level_roles
                                self.roles_view.bot.config_manager.set_category(
                                    self.roles_view.guild.id, "leveling", self.roles_view.config
                                )
                                

                                if hasattr(self.roles_view.bot, 'leveling_system'):
                                    self.roles_view.bot.leveling_system.update_config(self.roles_view.guild.id)
                                
                                await interaction.response.send_message(
                                    f"Level {level} will now receive the {role.name} role!", 
                                    ephemeral=True
                                )
                                
                            select.callback = select_callback
                            
                            view = discord.ui.View()
                            view.add_item(select)
                            
                            await interaction.response.send_message(
                                f"Select a role to assign at level {level}:", 
                                view=view, 
                                ephemeral=True
                            )
                        except ValueError:
                            await interaction.response.send_message("Invalid level! Please enter a valid number.", ephemeral=True)
                
                await interaction.response.send_modal(AddLevelRoleModal(self))
                
            @discord.ui.button(label="Remove Level Role", style=discord.ButtonStyle.danger)
            async def remove_level_role(self, interaction: discord.Interaction, button: discord.ui.Button):
                if not self.level_roles:
                    await interaction.response.send_message("No level roles configured yet.", ephemeral=True)
                    return
                

                options = []
                for level, role_id in self.level_roles.items():
                    role = self.guild.get_role(int(role_id))
                    role_name = role.name if role else "Unknown Role"
                    options.append(
                        discord.SelectOption(
                            label=f"Level {level}",
                            value=level,
                            description=f"Role: {role_name}"
                        )
                    )
                    
                select = discord.ui.Select(
                    placeholder="Select a level role to remove...",
                    min_values=1,
                    max_values=1,
                    options=options
                )
                
                async def select_callback(interaction: discord.Interaction):
                    level = select.values[0]
                    

                    del self.level_roles[level]
                    self.config["level_roles"] = self.level_roles
                    self.bot.config_manager.set_category(self.guild.id, "leveling", self.config)
                    

                    if hasattr(self.bot, 'leveling_system'):
                        self.bot.leveling_system.update_config(self.guild.id)
                    
                    await interaction.response.send_message(f"Removed role assignment for level {level}.", ephemeral=True)
                    
                select.callback = select_callback
                
                view = discord.ui.View()
                view.add_item(select)
                
                await interaction.response.send_message("Select a level role to remove:", view=view, ephemeral=True)
                
            @discord.ui.button(label="View Level Roles", style=discord.ButtonStyle.secondary)
            async def view_level_roles(self, interaction: discord.Interaction, button: discord.ui.Button):
                if not self.level_roles:
                    await interaction.response.send_message("No level roles configured yet.", ephemeral=True)
                    return
                
                embed = discord.Embed(
                    title="Level Roles Configuration",
                    description="The following roles will be assigned at these levels:",
                    color=discord.Color.blue()
                )
                
                for level, role_id in sorted(self.level_roles.items(), key=lambda x: int(x[0])):
                    role = self.guild.get_role(int(role_id))
                    role_mention = role.mention if role else f"Unknown Role ({role_id})"
                    embed.add_field(name=f"Level {level}", value=role_mention, inline=False)
                
                await interaction.response.send_message(embed=embed, ephemeral=True)
        

        level_config = self.bot.config_manager.get_category(self.guild.id, "leveling") or {}
        

        await interaction.response.send_message(
            "Configure level roles:", 
            view=LevelRolesView(self.bot, self.guild, level_config),
            ephemeral=True
        )
        
    @discord.ui.button(label="Set Announcement Channel", style=discord.ButtonStyle.primary)
    async def set_announcement_channel(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for channel in self.guild.text_channels[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a level-up announcement channel...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            channel_id = int(select.values[0])
            self.config["announcement_channel_id"] = str(channel_id)
            self.bot.config_manager.set_category(self.guild.id, "leveling", self.config)
            

            if hasattr(self.bot, 'leveling_system'):
                self.bot.leveling_system.update_config(self.guild.id)
            
            channel = self.guild.get_channel(channel_id)
            await interaction.response.send_message(f"Level-up announcements will now be sent to {channel.mention}.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a channel for level-up announcements:", view=view, ephemeral=True)
    
    @discord.ui.button(label="Toggle Level-Up Messages", style=discord.ButtonStyle.secondary)
    async def toggle_level_messages(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("announce_level_up", True)
        self.config["announce_level_up"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "leveling", self.config)
        

        if hasattr(self.bot, 'leveling_system'):
            self.bot.leveling_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Level-up announcements have been {status}.", ephemeral=True)


class MusicConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "music") or {}
        
    @discord.ui.button(label="Set DJ Role", style=discord.ButtonStyle.primary)
    async def set_dj_role(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for role in sorted(self.guild.roles, key=lambda r: r.position, reverse=True)[:25]:  # Discord limit
            if role.name != "@everyone" and not role.managed:
                options.append(
                    discord.SelectOption(
                        label=role.name,
                        value=str(role.id),
                        description=f"Role with {len(role.members)} members"
                    )
                )
            
        select = discord.ui.Select(
            placeholder="Select a DJ role...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            role_id = int(select.values[0])
            self.config["dj_role_id"] = str(role_id)
            self.bot.config_manager.set_category(self.guild.id, "music", self.config)
            

            if hasattr(self.bot, 'music_system'):
                self.bot.music_system.update_config(self.guild.id)
            
            role = self.guild.get_role(role_id)
            await interaction.response.send_message(f"DJ role has been set to {role.name}.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a role to be the DJ role:", view=view, ephemeral=True)
        
    @discord.ui.button(label="Set Default Volume", style=discord.ButtonStyle.primary)
    async def set_default_volume(self, interaction: discord.Interaction, button: discord.ui.Button):

        current_volume = self.config.get("default_volume", 70)
        

        class MusicVolumeModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Set Default Volume")
                self.config_view = config_view
                
                self.volume = discord.ui.TextInput(
                    label="Default Volume (1-100)",
                    placeholder="Enter a number between 1 and 100",
                    default=str(current_volume),
                    required=True
                )
                
                self.add_item(self.volume)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    volume = int(self.volume.value)
                    
                    if volume < 1 or volume > 100:
                        await interaction.response.send_message("Volume must be between 1 and 100.", ephemeral=True)
                        return
                    
                    self.config_view.config["default_volume"] = volume
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "music", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'music_system'):
                        self.config_view.bot.music_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(f"Default volume set to {volume}%.", ephemeral=True)
                except ValueError:
                    await interaction.response.send_message("Invalid input! Please enter a valid number.", ephemeral=True)
        
        await interaction.response.send_modal(MusicVolumeModal(self))
        
    @discord.ui.button(label="Toggle Song Announcements", style=discord.ButtonStyle.primary)
    async def toggle_announcements(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("announce_songs", True)
        self.config["announce_songs"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "music", self.config)
        

        if hasattr(self.bot, 'music_system'):
            self.bot.music_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Song announcements have been {status}.", ephemeral=True)
    
    @discord.ui.button(label="Set Music Channel", style=discord.ButtonStyle.primary)
    async def set_music_channel(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for channel in self.guild.text_channels[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a dedicated music channel...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            channel_id = int(select.values[0])
            self.config["music_channel_id"] = str(channel_id)
            self.bot.config_manager.set_category(self.guild.id, "music", self.config)
            

            if hasattr(self.bot, 'music_system'):
                self.bot.music_system.update_config(self.guild.id)
            
            channel = self.guild.get_channel(channel_id)
            await interaction.response.send_message(f"Music commands will now be primarily used in {channel.mention}.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a dedicated channel for music commands:", view=view, ephemeral=True)

class AnalyticsConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "analytics") or {}
        
    @discord.ui.button(label="Toggle Message Tracking", style=discord.ButtonStyle.primary)
    async def toggle_message_tracking(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("track_messages", True)
        self.config["track_messages"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "analytics", self.config)
        

        if hasattr(self.bot, 'analytics_system'):
            self.bot.analytics_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Message tracking has been {status}.", ephemeral=True)
        
    @discord.ui.button(label="Toggle Voice Tracking", style=discord.ButtonStyle.primary)
    async def toggle_voice_tracking(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("track_voice", True)
        self.config["track_voice"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "analytics", self.config)
        

        if hasattr(self.bot, 'analytics_system'):
            self.bot.analytics_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Voice activity tracking has been {status}.", ephemeral=True)
        
    @discord.ui.button(label="Toggle Member Tracking", style=discord.ButtonStyle.primary)
    async def toggle_member_tracking(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("track_members", True)
        self.config["track_members"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "analytics", self.config)
        

        if hasattr(self.bot, 'analytics_system'):
            self.bot.analytics_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Member tracking has been {status}.", ephemeral=True)
        
    @discord.ui.button(label="Set Data Retention", style=discord.ButtonStyle.primary)
    async def set_data_retention(self, interaction: discord.Interaction, button: discord.ui.Button):

        current_days = self.config.get("data_retention_days", 30)
        

        class DataRetentionModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Set Data Retention Period")
                self.config_view = config_view
                
                self.days = discord.ui.TextInput(
                    label="Retention Period (days)",
                    placeholder="Enter number of days to keep data",
                    default=str(current_days),
                    required=True
                )
                
                self.add_item(self.days)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    days = int(self.days.value)
                    
                    if days < 1:
                        await interaction.response.send_message("Retention period must be at least 1 day.", ephemeral=True)
                        return
                    
                    self.config_view.config["data_retention_days"] = days
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "analytics", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'analytics_system'):
                        self.config_view.bot.analytics_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(f"Data retention period set to {days} days.", ephemeral=True)
                except ValueError:
                    await interaction.response.send_message("Invalid input! Please enter a valid number.", ephemeral=True)
        
        await interaction.response.send_modal(DataRetentionModal(self))
        
    @discord.ui.button(label="View Dashboard", style=discord.ButtonStyle.success)
    async def view_dashboard(self, interaction: discord.Interaction, button: discord.ui.Button):

        dashboard_url = f"https://zygnalbot.com/dashboard/{self.guild.id}"
        
        embed = discord.Embed(
            title="ZygnalBot Analytics Dashboard",
            description="Access your server's analytics dashboard to view detailed statistics.",
            color=discord.Color.blue()
        )
        
        embed.add_field(name="Dashboard URL", value=f"[Click here to view dashboard]({dashboard_url})", inline=False)
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Analytics System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
    
    @discord.ui.button(label="Generate Report", style=discord.ButtonStyle.primary)
    async def generate_report(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True, thinking=True)
        
        try:


            
            embed = discord.Embed(
                title=f"Analytics Report for {self.guild.name}",
                description="Here's your server activity report for the past 7 days.",
                color=discord.Color.blue()
            )
            

            embed.add_field(name="Total Messages", value="1,245", inline=True)
            embed.add_field(name="Active Users", value="78", inline=True)
            embed.add_field(name="Voice Minutes", value="4,320", inline=True)
            embed.add_field(name="Most Active Channel", value="#general", inline=True)
            embed.add_field(name="Peak Activity", value="8:00 PM - 10:00 PM", inline=True)
            embed.add_field(name="New Members", value="12", inline=True)
            
            embed.set_footer(text=f"Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Error generating analytics report: {e}")
            await interaction.followup.send(f"An error occurred while generating the report: {e}", ephemeral=True)


class CustomCommandsConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "custom_commands") or {}
        self.commands = self.config.get("commands", {})
        
    @discord.ui.button(label="Add Command", style=discord.ButtonStyle.success)
    async def add_command(self, interaction: discord.Interaction, button: discord.ui.Button):

        class CustomCommandModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Add Custom Command")
                self.config_view = config_view
                
                self.command_name = discord.ui.TextInput(
                    label="Command Name",
                    placeholder="Enter command name (without prefix)",
                    required=True,
                    max_length=32
                )
                
                self.command_response = discord.ui.TextInput(
                    label="Command Response",
                    placeholder="Enter the response for this command",
                    style=discord.TextStyle.paragraph,
                    required=True,
                    max_length=2000
                )
                
                self.add_item(self.command_name)
                self.add_item(self.command_response)
                
            async def on_submit(self, interaction: discord.Interaction):
                cmd_name = self.command_name.value.lower().strip()
                

                if not cmd_name.isalnum() and not '_' in cmd_name:
                    await interaction.response.send_message(
                        "Command name must contain only letters, numbers, and underscores.", 
                        ephemeral=True
                    )
                    return
                

                if cmd_name in self.config_view.commands:
                    await interaction.response.send_message(
                        f"Command `{cmd_name}` already exists. Use the edit option to modify it.", 
                        ephemeral=True
                    )
                    return
                

                self.config_view.commands[cmd_name] = {
                    "response": self.command_response.value,
                    "created_by": str(interaction.user.id),
                    "created_at": datetime.datetime.now().isoformat()
                }
                
                self.config_view.config["commands"] = self.config_view.commands
                self.config_view.bot.config_manager.set_category(
                    self.config_view.guild.id, "custom_commands", self.config_view.config
                )
                

                if hasattr(self.config_view.bot, 'custom_commands_system'):
                    self.config_view.bot.custom_commands_system.update_config(self.config_view.guild.id)
                
                await interaction.response.send_message(f"Custom command `{cmd_name}` added successfully!", ephemeral=True)
        
        await interaction.response.send_modal(CustomCommandModal(self))
        
    @discord.ui.button(label="Edit Command", style=discord.ButtonStyle.primary)
    async def edit_command(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.commands:
            await interaction.response.send_message("You don't have any custom commands to edit.", ephemeral=True)
            return
            

        options = []
        for cmd_name in list(self.commands.keys())[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=cmd_name,
                    value=cmd_name,
                    description=f"Edit the '{cmd_name}' command"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a command to edit...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            cmd_name = select.values[0]
            

            class EditCommandModal(discord.ui.Modal):
                def __init__(self, config_view, cmd_name, current_response):
                    super().__init__(title=f"Edit Command: {cmd_name}")
                    self.config_view = config_view
                    self.cmd_name = cmd_name
                    
                    self.command_response = discord.ui.TextInput(
                        label="Command Response",
                        placeholder="Enter the new response for this command",
                        style=discord.TextStyle.paragraph,
                        default=current_response,
                        required=True,
                        max_length=2000
                    )
                    
                    self.add_item(self.command_response)
                    
                async def on_submit(self, interaction: discord.Interaction):

                    self.config_view.commands[self.cmd_name]["response"] = self.command_response.value
                    self.config_view.commands[self.cmd_name]["edited_by"] = str(interaction.user.id)
                    self.config_view.commands[self.cmd_name]["edited_at"] = datetime.datetime.now().isoformat()
                    
                    self.config_view.config["commands"] = self.config_view.commands
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "custom_commands", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'custom_commands_system'):
                        self.config_view.bot.custom_commands_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(f"Custom command `{self.cmd_name}` updated successfully!", ephemeral=True)
            
            current_response = self.commands[cmd_name]["response"]
            await interaction.response.send_modal(EditCommandModal(self, cmd_name, current_response))
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a command to edit:", view=view, ephemeral=True)
        
    @discord.ui.button(label="Delete Command", style=discord.ButtonStyle.danger)
    async def delete_command(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.commands:
            await interaction.response.send_message("You don't have any custom commands to delete.", ephemeral=True)
            return
            

        options = []
        for cmd_name in list(self.commands.keys())[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=cmd_name,
                    value=cmd_name,
                    description=f"Delete the '{cmd_name}' command"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a command to delete...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            cmd_name = select.values[0]
            

            class ConfirmationView(discord.ui.View):
                def __init__(self, prompt):
                    super().__init__(timeout=60)
                    self.prompt = prompt
                    self.value = None
                
                @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
                async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                    self.value = True
                    self.stop()
                    await interaction.response.send_message("Confirmed!", ephemeral=True)
                
                @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary)
                async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                    self.value = False
                    self.stop()
                    await interaction.response.send_message("Cancelled!", ephemeral=True)
            
            view = ConfirmationView(f"Are you sure you want to delete the command '{cmd_name}'?")
            await interaction.response.send_message(view.prompt, ephemeral=True, view=view)
            

            await view.wait()
            if view.value:

                del self.commands[cmd_name]
                self.config["commands"] = self.commands
                self.bot.config_manager.set_category(self.guild.id, "custom_commands", self.config)
                

                if hasattr(self.bot, 'custom_commands_system'):
                    self.bot.custom_commands_system.update_config(self.guild.id)
                
                await interaction.followup.send(f"Command '{cmd_name}' has been deleted.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a command to delete:", view=view, ephemeral=True)
        
    @discord.ui.button(label="View Commands", style=discord.ButtonStyle.secondary)
    async def view_commands(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.commands:
            await interaction.response.send_message("You don't have any custom commands set up.", ephemeral=True)
            return
            
        embed = discord.Embed(
            title="Custom Commands",
            description="Here are all the custom commands for this server:",
            color=discord.Color.blue()
        )
        
        for cmd_name, cmd_data in self.commands.items():
            response_preview = cmd_data.get("response", "")
            if len(response_preview) > 100:
                response_preview = response_preview[:97] + "..."
                
            embed.add_field(
                name=f"!{cmd_name}",
                value=f"Response: {response_preview}",
                inline=False
            )
            
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Custom Commands System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class MoodTrackingConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "mood_tracking") or {}
        
    @discord.ui.button(label="Set Tracking Channel", style=discord.ButtonStyle.primary)
    async def set_channel(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for channel in self.guild.text_channels[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a mood tracking channel...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            channel_id = int(select.values[0])
            self.config["channel_id"] = str(channel_id)
            self.bot.config_manager.set_category(self.guild.id, "mood_tracking", self.config)
            

            if hasattr(self.bot, 'mood_tracking_system'):
                self.bot.mood_tracking_system.update_config(self.guild.id)
            
            channel = self.guild.get_channel(channel_id)
            await interaction.response.send_message(f"Mood tracking will now use {channel.mention}.", ephemeral=True)
            

            try:
                embed = discord.Embed(
                    title="🌈 Mood Tracking System",
                    description="React with the emoji that best represents your current mood!",
                    color=discord.Color.blue()
                )
                embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Mood Tracking System")
                
                message = await channel.send(embed=embed)
                await message.add_reaction("😄")  # Happy
                await message.add_reaction("😊")  # Content
                await message.add_reaction("😐")  # Neutral
                await message.add_reaction("😔")  # Sad
                await message.add_reaction("😡")  # Angry
                
                self.config["message_id"] = str(message.id)
                self.bot.config_manager.set_category(self.guild.id, "mood_tracking", self.config)
                

                if hasattr(self.bot, 'mood_tracking_system'):
                    self.bot.mood_tracking_system.update_config(self.guild.id)
            except discord.Forbidden:
                await interaction.followup.send("I don't have permission to send messages or add reactions in that channel.", ephemeral=True)
            except Exception as e:
                logger.error(f"Error setting up mood tracking message: {e}")
                await interaction.followup.send(f"An error occurred: {e}", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a channel for mood tracking:", view=view, ephemeral=True)
        
    @discord.ui.button(label="Configure Mood Roles", style=discord.ButtonStyle.primary)
    async def configure_mood_roles(self, interaction: discord.Interaction, button: discord.ui.Button):

        class MoodRolesView(discord.ui.View):
            def __init__(self, bot, guild):
                super().__init__(timeout=180)
                self.bot = bot
                self.guild = guild
                self.config = bot.config_manager.get_category(guild.id, "mood_tracking") or {}
                self.mood_roles = self.config.get("mood_roles", {})
                
            @discord.ui.button(label="Set Happy Role", style=discord.ButtonStyle.success, emoji="😄")
            async def set_happy_role(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.set_mood_role(interaction, "happy", "😄")
                
            @discord.ui.button(label="Set Content Role", style=discord.ButtonStyle.success, emoji="😊")
            async def set_content_role(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.set_mood_role(interaction, "content", "😊")
                
            @discord.ui.button(label="Set Neutral Role", style=discord.ButtonStyle.secondary, emoji="😐")
            async def set_neutral_role(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.set_mood_role(interaction, "neutral", "😐")
                
            @discord.ui.button(label="Set Sad Role", style=discord.ButtonStyle.primary, emoji="😔")
            async def set_sad_role(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.set_mood_role(interaction, "sad", "😔")
                
            @discord.ui.button(label="Set Angry Role", style=discord.ButtonStyle.danger, emoji="😡")
            async def set_angry_role(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.set_mood_role(interaction, "angry", "😡")
                
            async def set_mood_role(self, interaction, mood_type, emoji):

                options = []
                for role in sorted(self.guild.roles, key=lambda r: r.position, reverse=True)[:25]:
                    if role.name != "@everyone" and not role.managed:
                        options.append(
                            discord.SelectOption(
                                label=role.name,
                                value=str(role.id),
                                description=f"Role with {len(role.members)} members"
                            )
                        )
                    
                select = discord.ui.Select(
                    placeholder=f"Select a role for {mood_type} mood...",
                    min_values=1,
                    max_values=1,
                    options=options
                )
                
                async def select_callback(interaction: discord.Interaction):
                    role_id = select.values[0]
                    

                    if "mood_roles" not in self.config:
                        self.config["mood_roles"] = {}
                    
                    self.config["mood_roles"][mood_type] = role_id
                    self.bot.config_manager.set_category(self.guild.id, "mood_tracking", self.config)
                    

                    if hasattr(self.bot, 'mood_tracking_system'):
                        self.bot.mood_tracking_system.update_config(self.guild.id)
                    
                    role = self.guild.get_role(int(role_id))
                    await interaction.response.send_message(
                        f"{emoji} Users with {mood_type} mood will now receive the {role.name} role!", 
                        ephemeral=True
                    )
                    
                select.callback = select_callback
                
                view = discord.ui.View()
                view.add_item(select)
                
                await interaction.response.send_message(
                    f"Select a role to assign for {mood_type} mood:", 
                    view=view, 
                    ephemeral=True
                )
        

        await interaction.response.send_message(
            "Configure mood roles:", 
            view=MoodRolesView(self.bot, self.guild),
            ephemeral=True
        )
        
    @discord.ui.button(label="Toggle Analytics", style=discord.ButtonStyle.primary)
    async def toggle_analytics(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("analytics_enabled", True)
        self.config["analytics_enabled"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "mood_tracking", self.config)
        

        if hasattr(self.bot, 'mood_tracking_system'):
            self.bot.mood_tracking_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        await interaction.response.send_message(f"Mood analytics have been {status}.", ephemeral=True)
        
    @discord.ui.button(label="View Mood Stats", style=discord.ButtonStyle.success)
    async def view_stats(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True, thinking=True)
        
        try:


            
            embed = discord.Embed(
                title="Mood Statistics",
                description="Here are the mood statistics for your server:",
                color=discord.Color.blue()
            )

            embed.add_field(name="😄 Happy", value="32%", inline=True)
            embed.add_field(name="😊 Content", value="45%", inline=True)
            embed.add_field(name="😐 Neutral", value="15%", inline=True)
            embed.add_field(name="😔 Sad", value="5%", inline=True)
            embed.add_field(name="😡 Angry", value="3%", inline=True)
            
            embed.add_field(name="Most Common Mood", value="😊 Content", inline=False)
            embed.add_field(name="Mood Trend", value="Improving over the past week", inline=False)
            
            embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Mood Tracking System")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Error generating mood statistics: {e}")
            await interaction.followup.send(f"An error occurred while generating mood statistics: {e}", ephemeral=True)

class StudyToolsConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "study_tools") or {}
        
    @discord.ui.button(label="Configure Pomodoro", style=discord.ButtonStyle.primary)
    async def configure_pomodoro(self, interaction: discord.Interaction, button: discord.ui.Button):

        pomodoro_config = self.config.get("pomodoro", {})
        work_minutes = pomodoro_config.get("work_minutes", 25)
        break_minutes = pomodoro_config.get("break_minutes", 5)
        long_break_minutes = pomodoro_config.get("long_break_minutes", 15)
        sessions = pomodoro_config.get("sessions_before_long_break", 4)
        

        class PomodoroSettingsModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Configure Pomodoro Timer")
                self.config_view = config_view
                
                self.work_minutes = discord.ui.TextInput(
                    label="Work Minutes",
                    placeholder="Duration of work sessions in minutes",
                    default=str(work_minutes),
                    required=True
                )
                
                self.break_minutes = discord.ui.TextInput(
                    label="Break Minutes",
                    placeholder="Duration of short breaks in minutes",
                    default=str(break_minutes),
                    required=True
                )
                
                self.long_break_minutes = discord.ui.TextInput(
                    label="Long Break Minutes",
                    placeholder="Duration of long breaks in minutes",
                    default=str(long_break_minutes),
                    required=True
                )
                
                self.sessions = discord.ui.TextInput(
                    label="Sessions Before Long Break",
                    placeholder="Number of work sessions before a long break",
                    default=str(sessions),
                    required=True
                )
                
                self.add_item(self.work_minutes)
                self.add_item(self.break_minutes)
                self.add_item(self.long_break_minutes)
                self.add_item(self.sessions)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    work = int(self.work_minutes.value)
                    short_break = int(self.break_minutes.value)
                    long_break = int(self.long_break_minutes.value)
                    sessions_count = int(self.sessions.value)
                    
                    if work < 1 or short_break < 1 or long_break < 1 or sessions_count < 1:
                        await interaction.response.send_message("All values must be positive numbers.", ephemeral=True)
                        return
                    

                    if "pomodoro" not in self.config_view.config:
                        self.config_view.config["pomodoro"] = {}
                    
                    self.config_view.config["pomodoro"]["work_minutes"] = work
                    self.config_view.config["pomodoro"]["break_minutes"] = short_break
                    self.config_view.config["pomodoro"]["long_break_minutes"] = long_break
                    self.config_view.config["pomodoro"]["sessions_before_long_break"] = sessions_count
                    
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "study_tools", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'study_tools_system'):
                        self.config_view.bot.study_tools_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(
                        f"Pomodoro settings updated!\n"
                        f"Work: {work} minutes\n"
                        f"Short Break: {short_break} minutes\n"
                        f"Long Break: {long_break} minutes\n"
                        f"Sessions before long break: {sessions_count}",
                        ephemeral=True
                    )
                except ValueError:
                    await interaction.response.send_message("Invalid input! Please enter valid numbers.", ephemeral=True)
        
        await interaction.response.send_modal(PomodoroSettingsModal(self))
        
    @discord.ui.button(label="Set Study Channel", style=discord.ButtonStyle.primary)
    async def set_study_channel(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for channel in self.guild.text_channels[:25]:  # Discord limit
            options.append(
                discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a study channel...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            channel_id = int(select.values[0])
            self.config["study_channel_id"] = str(channel_id)
            self.bot.config_manager.set_category(self.guild.id, "study_tools", self.config)
            

            if hasattr(self.bot, 'study_tools_system'):
                self.bot.study_tools_system.update_config(self.guild.id)
            
            channel = self.guild.get_channel(channel_id)
            await interaction.response.send_message(f"Study tools will now use {channel.mention}.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a channel for study tools:", view=view, ephemeral=True)
        
    @discord.ui.button(label="Configure Flashcards", style=discord.ButtonStyle.primary)
    async def configure_flashcards(self, interaction: discord.Interaction, button: discord.ui.Button):

        embed = discord.Embed(
            title="Flashcard System Configuration",
            description="The flashcard system allows users to create and study with digital flashcards.",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="Available Commands",
            value=(
                "`/flashcard create` - Create a new flashcard deck\n"
                "`/flashcard add` - Add cards to a deck\n"
                "`/flashcard study` - Study with a flashcard deck\n"
                "`/flashcard list` - List all available decks\n"
                "`/flashcard delete` - Delete a deck"
            ),
            inline=False
        )
        
        embed.add_field(
            name="Coming Soon",
            value="Advanced flashcard features including spaced repetition, image support, and collaborative decks.",
            inline=False
        )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
    @discord.ui.button(label="Toggle Focus Mode", style=discord.ButtonStyle.primary)
    async def toggle_focus_mode(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("focus_mode_enabled", False)
        self.config["focus_mode_enabled"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "study_tools", self.config)
        

        if hasattr(self.bot, 'study_tools_system'):
            self.bot.study_tools_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        
        embed = discord.Embed(
            title="Focus Mode Settings",
            description=f"Focus mode has been {status}.",
            color=discord.Color.green() if not current_setting else discord.Color.red()
        )
        
        if not current_setting:  # If we just enabled it
            embed.add_field(
                name="What is Focus Mode?",
                value=(
                    "Focus Mode helps users stay concentrated on their studies by:\n"
                    "• Limiting distracting commands\n"
                    "• Providing automatic Pomodoro timers\n"
                    "• Tracking study time for analytics\n"
                    "• Temporarily muting non-study channels"
                ),
                inline=False
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class GhostPingConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(self.guild.id, "ghost_ping") or {}
        
    @discord.ui.button(label="Toggle Strict Mode", style=discord.ButtonStyle.primary)
    async def toggle_strict_mode(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_setting = self.config.get("strict_mode", False)
        self.config["strict_mode"] = not current_setting
        self.bot.config_manager.set_category(self.guild.id, "ghost_ping", self.config)
        

        if hasattr(self.bot, 'ghost_ping_system'):
            self.bot.ghost_ping_system.update_config(self.guild.id)
        
        status = "enabled" if not current_setting else "disabled"
        
        embed = discord.Embed(
            title="Ghost Ping Protection",
            description=f"Strict mode has been {status}.",
            color=discord.Color.green() if not current_setting else discord.Color.red()
        )
        
        if not current_setting:  # If we just enabled it
            embed.add_field(
                name="What is Strict Mode?",
                value=(
                    "Strict Mode enhances ghost ping detection by:\n"
                    "• Detecting edited messages that remove mentions\n"
                    "• Tracking message edits more aggressively\n"
                    "• Applying stricter punishment for repeat offenders\n"
                    "• Logging all potential ghost pings, even borderline cases"
                ),
                inline=False
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
    @discord.ui.button(label="Set Strike Limit", style=discord.ButtonStyle.primary)
    async def set_strike_limit(self, interaction: discord.Interaction, button: discord.ui.Button):

        current_limit = self.config.get("strike_limit", 3)
        

        class StrikeLimitModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Set Ghost Ping Strike Limit")
                self.config_view = config_view
                
                self.strike_limit = discord.ui.TextInput(
                    label="Strike Limit",
                    placeholder="Number of strikes before punishment",
                    default=str(current_limit),
                    required=True
                )
                
                self.add_item(self.strike_limit)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    limit = int(self.strike_limit.value)
                    
                    if limit < 1:
                        await interaction.response.send_message("Strike limit must be a positive number.", ephemeral=True)
                        return
                    
                    self.config_view.config["strike_limit"] = limit
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "ghost_ping", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'ghost_ping_system'):
                        self.config_view.bot.ghost_ping_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(f"Ghost ping strike limit set to {limit}.", ephemeral=True)
                except ValueError:
                    await interaction.response.send_message("Invalid input! Please enter a valid number.", ephemeral=True)
        
        await interaction.response.send_modal(StrikeLimitModal(self))
        
    @discord.ui.button(label="Configure Punishment", style=discord.ButtonStyle.primary)
    async def configure_punishment(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = [
            discord.SelectOption(
                label="Warning",
                value="warn",
                description="Just warn the user"
            ),
            discord.SelectOption(
                label="Timeout (5 minutes)",
                value="timeout_5",
                description="Timeout the user for 5 minutes"
            ),
            discord.SelectOption(
                label="Timeout (1 hour)",
                value="timeout_60",
                description="Timeout the user for 1 hour"
            ),
            discord.SelectOption(
                label="Timeout (1 day)",
                value="timeout_1440",
                description="Timeout the user for 1 day"
            ),
            discord.SelectOption(
                label="Kick",
                value="kick",
                description="Kick the user from the server"
            ),
            discord.SelectOption(
                label="Ban",
                value="ban",
                description="Ban the user from the server"
            )
        ]
            
        select = discord.ui.Select(
            placeholder="Select a punishment...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            punishment = select.values[0]
            self.config["punishment"] = punishment
            self.bot.config_manager.set_category(self.guild.id, "ghost_ping", self.config)
            

            if hasattr(self.bot, 'ghost_ping_system'):
                self.bot.ghost_ping_system.update_config(self.guild.id)
            
            punishment_name = next(option.label for option in select.options if option.value == punishment)
            await interaction.response.send_message(f"Ghost ping punishment has been set to: {punishment_name}", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a punishment for ghost pings:", view=view, ephemeral=True)
        
    @discord.ui.button(label="View Strike Log", style=discord.ButtonStyle.success)
    async def view_strikes(self, interaction: discord.Interaction, button: discord.ui.Button):
        strikes = self.config.get("strikes", {})
        
        if not strikes:
            await interaction.response.send_message("No ghost ping strikes have been recorded.", ephemeral=True)
            return
            
        embed = discord.Embed(
            title="Ghost Ping Strike Log",
            description="Here are the users who have ghost pinged others:",
            color=discord.Color.red()
        )
        
        for user_id, strike_count in strikes.items():
            user = self.guild.get_member(int(user_id))
            user_name = user.name if user else f"Unknown User ({user_id})"
            embed.add_field(name=user_name, value=f"{strike_count} strikes", inline=True)
            
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Ghost Ping Protection")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
    @discord.ui.button(label="Clear All Strikes", style=discord.ButtonStyle.danger)
    async def clear_strikes(self, interaction: discord.Interaction, button: discord.ui.Button):

        class ConfirmationView(discord.ui.View):
            def __init__(self, prompt):
                super().__init__(timeout=60)
                self.prompt = prompt
                self.value = None
            
            @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
            async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                self.value = True
                self.stop()
                await interaction.response.send_message("Confirmed!", ephemeral=True)
            
            @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary)
            async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                self.value = False
                self.stop()
                await interaction.response.send_message("Cancelled!", ephemeral=True)
        
        view = ConfirmationView("Are you sure you want to clear all ghost ping strikes?")
        await interaction.response.send_message(view.prompt, ephemeral=True, view=view)
        

        await view.wait()
        if view.value:
            self.config["strikes"] = {}
            self.bot.config_manager.set_category(self.guild.id, "ghost_ping", self.config)
            

            if hasattr(self.bot, 'ghost_ping_system'):
                self.bot.ghost_ping_system.update_config(self.guild.id)
            
            await interaction.followup.send("All ghost ping strikes have been cleared.", ephemeral=True)

class WhitelistConfigView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "whitelist") or {}
        self.whitelist = self.config.get("entries", [])
        
    @discord.ui.button(label="Add User", style=discord.ButtonStyle.success, emoji="👤")
    async def add_user(self, interaction: discord.Interaction, button: discord.ui.Button):

        class UserIDModal(discord.ui.Modal):
            def __init__(self, config_view):
                super().__init__(title="Add User to Whitelist")
                self.config_view = config_view
                
                self.user_id = discord.ui.TextInput(
                    label="User ID",
                    placeholder="Enter the user ID to whitelist",
                    required=True
                )
                
                self.add_item(self.user_id)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    user_id = self.user_id.value.strip()
                    

                    try:
                        user_id_int = int(user_id)
                        user = await self.config_view.bot.fetch_user(user_id_int)
                    except (ValueError, discord.NotFound):
                        await interaction.response.send_message("Invalid user ID. Please enter a valid Discord user ID.", ephemeral=True)
                        return
                    

                    entry = f"user:{user_id}"
                    if entry in self.config_view.whitelist:
                        await interaction.response.send_message(f"User {user.name} (ID: {user_id}) is already whitelisted.", ephemeral=True)
                        return
                    

                    self.config_view.whitelist.append(entry)
                    self.config_view.config["entries"] = self.config_view.whitelist
                    self.config_view.bot.config_manager.set_category(
                        self.config_view.guild.id, "whitelist", self.config_view.config
                    )
                    

                    if hasattr(self.config_view.bot, 'whitelist_system'):
                        self.config_view.bot.whitelist_system.update_config(self.config_view.guild.id)
                    
                    await interaction.response.send_message(f"Added user {user.name} (ID: {user_id}) to the whitelist.", ephemeral=True)
                except Exception as e:
                    logger.error(f"Error adding user to whitelist: {e}")
                    await interaction.response.send_message(f"An error occurred: {e}", ephemeral=True)
        
        await interaction.response.send_modal(UserIDModal(self))
        
    @discord.ui.button(label="Add Role", style=discord.ButtonStyle.success, emoji="🎭")
    async def add_role(self, interaction: discord.Interaction, button: discord.ui.Button):

        options = []
        for role in sorted(self.guild.roles, key=lambda r: r.position, reverse=True)[:25]:
            if role.name != "@everyone" and not role.managed:
                options.append(
                    discord.SelectOption(
                        label=role.name,
                        value=str(role.id),
                        description=f"Role with {len(role.members)} members"
                    )
                )
            
        select = discord.ui.Select(
            placeholder="Select a role to whitelist...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            role_id = select.values[0]
            role = self.guild.get_role(int(role_id))
            

            entry = f"role:{role_id}"
            if entry in self.whitelist:
                await interaction.response.send_message(f"Role {role.name} (ID: {role_id}) is already whitelisted.", ephemeral=True)
                return
            

            self.whitelist.append(entry)
            self.config["entries"] = self.whitelist
            self.bot.config_manager.set_category(self.guild.id, "whitelist", self.config)
            

            if hasattr(self.bot, 'whitelist_system'):
                self.bot.whitelist_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Added role {role.name} (ID: {role_id}) to the whitelist.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a role to whitelist:", view=view, ephemeral=True)
        
    @discord.ui.button(label="Remove Entry", style=discord.ButtonStyle.danger)
    async def remove_entry(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.whitelist:
            await interaction.response.send_message("The whitelist is empty.", ephemeral=True)
            return
            

        options = []
        for entry in self.whitelist[:25]:  # Discord limit
            entry_type, entry_id = entry.split(":", 1)
            
            if entry_type == "user":
                try:
                    user = await self.bot.fetch_user(int(entry_id))
                    label = f"User: {user.name}"
                    description = f"User ID: {entry_id}"
                except:
                    label = f"User: Unknown"
                    description = f"User ID: {entry_id}"
            else:  # role
                role = self.guild.get_role(int(entry_id))
                label = f"Role: {role.name if role else 'Unknown'}"
                description = f"Role ID: {entry_id}"
                
            options.append(
                discord.SelectOption(
                    label=label,
                    value=entry,
                    description=description
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select an entry to remove...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            entry = select.values[0]
            

            self.whitelist.remove(entry)
            self.config["entries"] = self.whitelist
            self.bot.config_manager.set_category(self.guild.id, "whitelist", self.config)
            

            if hasattr(self.bot, 'whitelist_system'):
                self.bot.whitelist_system.update_config(self.guild.id)
            
            entry_type, entry_id = entry.split(":", 1)
            type_name = "User" if entry_type == "user" else "Role"
            
            await interaction.response.send_message(f"Removed {type_name} (ID: {entry_id}) from the whitelist.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select an entry to remove from the whitelist:", view=view, ephemeral=True)
        
    @discord.ui.button(label="View Whitelist", style=discord.ButtonStyle.secondary)
    async def view_whitelist(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.whitelist:
            await interaction.response.send_message("The whitelist is empty.", ephemeral=True)
            return
            
        embed = discord.Embed(
            title="Whitelist Configuration",
            description=f"Total entries: {len(self.whitelist)}",
            color=discord.Color.blue()
        )
        
        users = []
        roles = []
        
        for entry in self.whitelist:
            entry_type, entry_id = entry.split(":", 1)
            
            if entry_type == "user":
                try:
                    user = await self.bot.fetch_user(int(entry_id))
                    users.append(f"👤 {user.name} (ID: {entry_id})")
                except:
                    users.append(f"👤 Unknown User (ID: {entry_id})")
            else:  # role
                role = self.guild.get_role(int(entry_id))
                if role:
                    roles.append(f"🎭 {role.name} (ID: {entry_id})")
                else:
                    roles.append(f"🎭 Unknown Role (ID: {entry_id})")
        
        if users:
            embed.add_field(
                name="Whitelisted Users",
                value="\n".join(users),
                inline=False
            )
            
        if roles:
            embed.add_field(
                name="Whitelisted Roles",
                value="\n".join(roles),
                inline=False
            )
            
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Whitelist System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
    @discord.ui.button(label="Clear Whitelist", style=discord.ButtonStyle.danger)
    async def clear_whitelist(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.whitelist:
            await interaction.response.send_message("The whitelist is already empty.", ephemeral=True)
            return
            

        class ConfirmationView(discord.ui.View):
            def __init__(self, prompt):
                super().__init__(timeout=60)
                self.prompt = prompt
                self.value = None
            
            @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
            async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                self.value = True
                self.stop()
                await interaction.response.send_message("Confirmed!", ephemeral=True)
            
            @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary)
            async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                self.value = False
                self.stop()
                await interaction.response.send_message("Cancelled!", ephemeral=True)
        
        view = ConfirmationView("Are you sure you want to clear the entire whitelist?")
        await interaction.response.send_message(view.prompt, ephemeral=True, view=view)
        

        await view.wait()
        if view.value:
            self.whitelist = []
            self.config["entries"] = self.whitelist
            self.bot.config_manager.set_category(self.guild.id, "whitelist", self.config)
            

            if hasattr(self.bot, 'whitelist_system'):
                self.bot.whitelist_system.update_config(self.guild.id)
            
            await interaction.followup.send("The whitelist has been cleared.", ephemeral=True)


class WelcomeMessageModal(discord.ui.Modal):
    def __init__(self, bot, guild, config):
        super().__init__(title="Customize Welcome Message")
        self.bot = bot
        self.guild = guild
        self.config = config
        

        current_message = config.get("message", "Welcome to {server}, {user}!")
        current_title = config.get("embed_title", "Welcome!")
        current_color = config.get("embed_color", "3447003")  # Discord blue in decimal
        
        self.message = discord.ui.TextInput(
            label="Welcome Message",
            placeholder="Enter your welcome message",
            default=current_message,
            style=discord.TextStyle.paragraph,
            required=True
        )
        
        self.embed_title = discord.ui.TextInput(
            label="Embed Title",
            placeholder="Enter the title for the welcome embed",
            default=current_title,
            required=False
        )
        
        self.embed_color = discord.ui.TextInput(
            label="Embed Color (Hex)",
            placeholder="Enter a hex color code (e.g. 3498db)",
            default=current_color,
            required=False
        )
        
        self.add_item(self.message)
        self.add_item(self.embed_title)
        self.add_item(self.embed_color)
        
    async def on_submit(self, interaction: discord.Interaction):

        self.config["message"] = self.message.value
        

        if self.embed_title.value:
            self.config["embed_title"] = self.embed_title.value
            
        if self.embed_color.value:
            try:

                color_value = self.embed_color.value.strip("#")
                int(color_value, 16)  # This will raise ValueError if invalid
                self.config["embed_color"] = color_value
            except ValueError:
                await interaction.response.send_message("Invalid hex color. Using default color instead.", ephemeral=True)
                return
        

        self.bot.config_manager.set_category(self.guild.id, "welcome", self.config)
        
        await interaction.response.send_message("Welcome message updated successfully!", ephemeral=True)

class XPSettingsModal(discord.ui.Modal):
    def __init__(self, bot, guild, config):
        super().__init__(title="Configure XP Settings")
        self.bot = bot
        self.guild = guild
        self.config = config
        

        current_xp = config.get("xp_rate", {"min": 15, "max": 25})
        
        self.min_xp = discord.ui.TextInput(
            label="Minimum XP per message",
            placeholder="Enter the minimum XP per message",
            default=str(current_xp.get("min", 15)),
            required=True
        )
        
        self.max_xp = discord.ui.TextInput(
            label="Maximum XP per message",
            placeholder="Enter the maximum XP per message",
            default=str(current_xp.get("max", 25)),
            required=True
        )
        
        self.cooldown = discord.ui.TextInput(
            label="XP Cooldown (seconds)",
            placeholder="Enter cooldown between XP gains",
            default=str(config.get("xp_cooldown", 60)),
            required=True
        )
        
        self.add_item(self.min_xp)
        self.add_item(self.max_xp)
        self.add_item(self.cooldown)
        
    async def on_submit(self, interaction: discord.Interaction):
        try:
            min_xp = int(self.min_xp.value)
            max_xp = int(self.max_xp.value)
            cooldown = int(self.cooldown.value)
            
            if min_xp < 1 or max_xp < 1 or cooldown < 0:
                await interaction.response.send_message("Values must be positive numbers.", ephemeral=True)
                return
                
            if min_xp > max_xp:
                await interaction.response.send_message("Minimum XP cannot be greater than maximum XP.", ephemeral=True)
                return
                

            self.config["xp_rate"] = {"min": min_xp, "max": max_xp}
            self.config["xp_cooldown"] = cooldown
            

            self.bot.config_manager.set_category(self.guild.id, "leveling", self.config)
            

            if hasattr(self.bot, 'leveling_system'):
                self.bot.leveling_system.update_config(self.guild.id)
            
            await interaction.response.send_message(
                f"XP settings updated successfully!\n"
                f"XP per message: {min_xp}-{max_xp}\n"
                f"Cooldown: {cooldown} seconds",
                ephemeral=True
            )
        except ValueError:
            await interaction.response.send_message("Invalid input! Please enter valid numbers.", ephemeral=True)


class MusicVolumeModal(discord.ui.Modal):
    def __init__(self, bot, guild, config):
        super().__init__(title="Set Default Music Volume")
        self.bot = bot
        self.guild = guild
        self.config = config
        

        current_volume = config.get("default_volume", 70)
        
        self.volume = discord.ui.TextInput(
            label="Default Volume (1-100)",
            placeholder="Enter the default volume level",
            default=str(current_volume),
            required=True
        )
        
        self.add_item(self.volume)
        
    async def on_submit(self, interaction: discord.Interaction):
        try:
            volume = int(self.volume.value)
            
            if volume < 1 or volume > 100:
                await interaction.response.send_message("Volume must be between 1 and 100.", ephemeral=True)
                return
            
            self.config["default_volume"] = volume
            self.bot.config_manager.set_category(self.guild.id, "music", self.config)
            

            if hasattr(self.bot, 'music_system'):
                self.bot.music_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Default music volume set to {volume}%.", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Invalid input! Please enter a valid number.", ephemeral=True)


class DataRetentionModal(discord.ui.Modal):
    def __init__(self, bot, guild, config):
        super().__init__(title="Set Data Retention Period")
        self.bot = bot
        self.guild = guild
        self.config = config
        

        current_days = config.get("data_retention_days", 30)
        
        self.days = discord.ui.TextInput(
            label="Retention Period (days)",
            placeholder="Enter number of days to keep data",
            default=str(current_days),
            required=True
        )
        
        self.add_item(self.days)
        
    async def on_submit(self, interaction: discord.Interaction):
        try:
            days = int(self.days.value)
            
            if days < 1:
                await interaction.response.send_message("Retention period must be at least 1 day.", ephemeral=True)
                return
            
            self.config["data_retention_days"] = days
            self.bot.config_manager.set_category(self.guild.id, "analytics", self.config)
            

            if hasattr(self.bot, 'analytics_system'):
                self.bot.analytics_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Data retention period set to {days} days.", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Invalid input! Please enter a valid number.", ephemeral=True)



class CustomCommandModal(discord.ui.Modal):
    def __init__(self, mode, bot, guild, commands, cmd_name=None):
        title = "Add Custom Command" if mode == "add" else f"Edit Command: {cmd_name}"
        super().__init__(title=title)
        self.mode = mode
        self.bot = bot
        self.guild = guild
        self.commands = commands
        self.cmd_name = cmd_name
        
        if mode == "add":
            self.command_name = discord.ui.TextInput(
                label="Command Name",
                placeholder="Enter the command name (without prefix)",
                required=True,
                max_length=32
            )
            
            self.command_response = discord.ui.TextInput(
                label="Command Response",
                placeholder="Enter the response for this command",
                style=discord.TextStyle.paragraph,
                required=True,
                max_length=2000
            )
            
            self.add_item(self.command_name)
            self.add_item(self.command_response)
        else:  # Edit mode
            current_response = commands.get(cmd_name, {}).get("response", "")
            
            self.command_response = discord.ui.TextInput(
                label="Command Response",
                placeholder="Enter the new response for this command",
                style=discord.TextStyle.paragraph,
                default=current_response,
                required=True,
                max_length=2000
            )
            
            self.add_item(self.command_response)
        
    async def on_submit(self, interaction: discord.Interaction):
        if self.mode == "add":
            cmd_name = self.command_name.value.lower().strip()
            

            if not cmd_name or " " in cmd_name:
                await interaction.response.send_message("Command name cannot be empty or contain spaces.", ephemeral=True)
                return
                
            if cmd_name in self.commands:
                await interaction.response.send_message(f"Command `{cmd_name}` already exists. Use the Edit button to modify it.", ephemeral=True)
                return
                

            self.commands[cmd_name] = {
                "response": self.command_response.value,
                "created_by": str(interaction.user.id),
                "created_at": datetime.datetime.now().isoformat()
            }
            
            config = self.bot.config_manager.get_category(self.guild.id, "custom_commands") or {}
            config["commands"] = self.commands
            self.bot.config_manager.set_category(self.guild.id, "custom_commands", config)
            

            if hasattr(self.bot, 'custom_commands_system'):
                self.bot.custom_commands_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Custom command `{cmd_name}` added successfully!", ephemeral=True)
        else:  # Edit mode

            self.commands[self.cmd_name]["response"] = self.command_response.value
            self.commands[self.cmd_name]["edited_by"] = str(interaction.user.id)
            self.commands[self.cmd_name]["edited_at"] = datetime.datetime.now().isoformat()
            
            config = self.bot.config_manager.get_category(self.guild.id, "custom_commands") or {}
            config["commands"] = self.commands
            self.bot.config_manager.set_category(self.guild.id, "custom_commands", config)
            

            if hasattr(self.bot, 'custom_commands_system'):
                self.bot.custom_commands_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Custom command `{self.cmd_name}` updated successfully!", ephemeral=True)


class PomodoroSettingsModal(discord.ui.Modal):
    def __init__(self, bot, guild, config):
        super().__init__(title="Configure Pomodoro Timer")
        self.bot = bot
        self.guild = guild
        self.config = config
        

        pomodoro_config = config.get("pomodoro", {})
        work_minutes = pomodoro_config.get("work_minutes", 25)
        break_minutes = pomodoro_config.get("break_minutes", 5)
        long_break_minutes = pomodoro_config.get("long_break_minutes", 15)
        sessions = pomodoro_config.get("sessions_before_long_break", 4)
        
        self.work_minutes = discord.ui.TextInput(
            label="Work Minutes",
            placeholder="Duration of work sessions in minutes",
            default=str(work_minutes),
            required=True
        )
        
        self.break_minutes = discord.ui.TextInput(
            label="Break Minutes",
            placeholder="Duration of short breaks in minutes",
            default=str(break_minutes),
            required=True
        )
        
        self.long_break_minutes = discord.ui.TextInput(
            label="Long Break Minutes",
            placeholder="Duration of long breaks in minutes",
            default=str(long_break_minutes),
            required=True
        )
        
        self.sessions = discord.ui.TextInput(
            label="Sessions Before Long Break",
            placeholder="Number of work sessions before a long break",
            default=str(sessions),
            required=True
        )
        
        self.add_item(self.work_minutes)
        self.add_item(self.break_minutes)
        self.add_item(self.long_break_minutes)
        self.add_item(self.sessions)
        
    async def on_submit(self, interaction: discord.Interaction):
        try:
            work = int(self.work_minutes.value)
            short_break = int(self.break_minutes.value)
            long_break = int(self.long_break_minutes.value)
            sessions_count = int(self.sessions.value)
            
            if work < 1 or short_break < 1 or long_break < 1 or sessions_count < 1:
                await interaction.response.send_message("All values must be positive numbers.", ephemeral=True)
                return
            

            if "pomodoro" not in self.config:
                self.config["pomodoro"] = {}
            
            self.config["pomodoro"]["work_minutes"] = work
            self.config["pomodoro"]["break_minutes"] = short_break
            self.config["pomodoro"]["long_break_minutes"] = long_break
            self.config["pomodoro"]["sessions_before_long_break"] = sessions_count
            
            self.bot.config_manager.set_category(self.guild.id, "study_tools", self.config)
            

            if hasattr(self.bot, 'study_tools_system'):
                self.bot.study_tools_system.update_config(self.guild.id)
            
            await interaction.response.send_message(
                f"Pomodoro settings updated!\n"
                f"Work: {work} minutes\n"
                f"Short Break: {short_break} minutes\n"
                f"Long Break: {long_break} minutes\n"
                f"Sessions before long break: {sessions_count}",
                ephemeral=True
            )
        except ValueError:
            await interaction.response.send_message("Invalid input! Please enter valid numbers.", ephemeral=True)


class StrikeLimitModal(discord.ui.Modal):
    def __init__(self, bot, guild, config):
        super().__init__(title="Set Ghost Ping Strike Limit")
        self.bot = bot
        self.guild = guild
        self.config = config
        

        current_limit = config.get("strike_limit", 3)
        
        self.strike_limit = discord.ui.TextInput(
            label="Strike Limit",
            placeholder="Number of strikes before punishment",
            default=str(current_limit),
            required=True
        )
        
        self.add_item(self.strike_limit)
        
    async def on_submit(self, interaction: discord.Interaction):
        try:
            limit = int(self.strike_limit.value)
            
            if limit < 1:
                await interaction.response.send_message("Strike limit must be a positive number.", ephemeral=True)
                return
            
            self.config["strike_limit"] = limit
            self.bot.config_manager.set_category(self.guild.id, "ghost_ping", self.config)
            

            if hasattr(self.bot, 'ghost_ping_system'):
                self.bot.ghost_ping_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Ghost ping strike limit set to {limit}.", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Invalid input! Please enter a valid number.", ephemeral=True)

@commands.command(name="features")
@commands.has_permissions(administrator=True)
async def features_command(self, ctx):

    view = BotFeaturesView(self.bot, ctx.guild)
    
    embed = discord.Embed(
        title="ZygnalBot Features Configuration",
        description="Select a feature from the dropdown menu below to configure it.",
        color=discord.Color.blue()
    )
    
    embed.add_field(
        name="Available Features",
        value=(
            "• Welcome System\n"
            "• Leveling System\n"
            "• Music System\n"
            "• Analytics\n"
            "• Custom Commands\n"
            "• Mood Tracking\n"
            "• Study Tools\n"
            "• Ghost Ping Protection\n"
            "• Whitelist System"
        ),
        inline=False
    )
    
    embed.add_field(
        name="How to Use",
        value=(
            "1. Select a feature from the dropdown menu\n"
            "2. Use the buttons to enable, disable, or configure the feature\n"
            "3. Follow the prompts to complete configuration"
        ),
        inline=False
    )
    
    embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Features Configuration")
    
    await ctx.send(embed=embed, view=view)

class LevelRolesView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "leveling") or {}
        self.level_roles = self.config.get("level_roles", {})
        
    @discord.ui.button(label="Add Level Role", style=discord.ButtonStyle.success)
    async def add_level_role(self, interaction: discord.Interaction, button: discord.ui.Button):

        class LevelRoleModal(discord.ui.Modal):
            def __init__(self, view):
                super().__init__(title="Add Level Role")
                self.view = view
                
                self.level = discord.ui.TextInput(
                    label="Level",
                    placeholder="Enter the level number",
                    required=True
                )
                
                self.add_item(self.level)
                
            async def on_submit(self, interaction: discord.Interaction):
                try:
                    level = int(self.level.value)
                    
                    if level < 1:
                        await interaction.response.send_message("Level must be a positive number.", ephemeral=True)
                        return
                        

                    options = []
                    for role in sorted(self.view.guild.roles, key=lambda r: r.position, reverse=True)[:25]:
                        if role.name != "@everyone" and not role.managed:
                            options.append(
                                discord.SelectOption(
                                    label=role.name,
                                    value=str(role.id),
                                    description=f"Role with {len(role.members)} members"
                                )
                            )
                        
                    select = discord.ui.Select(
                        placeholder=f"Select a role for level {level}...",
                        min_values=1,
                        max_values=1,
                        options=options
                    )
                    
                    async def select_callback(interaction: discord.Interaction):
                        role_id = select.values[0]
                        role = self.view.guild.get_role(int(role_id))
                        

                        self.view.level_roles[str(level)] = role_id
                        self.view.config["level_roles"] = self.view.level_roles
                        self.view.bot.config_manager.set_category(self.view.guild.id, "leveling", self.view.config)
                        

                        if hasattr(self.view.bot, 'leveling_system'):
                            self.view.bot.leveling_system.update_config(self.view.guild.id)
                        
                        await interaction.response.send_message(
                            f"Level {level} will now receive the {role.name} role upon level-up!",
                            ephemeral=True
                        )
                        
                    select.callback = select_callback
                    
                    view = discord.ui.View()
                    view.add_item(select)
                    
                    await interaction.response.send_message(
                        f"Select a role to assign at level {level}:",
                        view=view,
                        ephemeral=True
                    )
                except ValueError:
                    await interaction.response.send_message("Invalid input! Please enter a valid level number.", ephemeral=True)
        
        await interaction.response.send_modal(LevelRoleModal(self))
        
    @discord.ui.button(label="Remove Level Role", style=discord.ButtonStyle.danger)
    async def remove_level_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.level_roles:
            await interaction.response.send_message("No level roles have been configured.", ephemeral=True)
            return
            

        options = []
        for level, role_id in self.level_roles.items():
            role = self.guild.get_role(int(role_id))
            role_name = role.name if role else "Unknown Role"
            
            options.append(
                discord.SelectOption(
                    label=f"Level {level}",
                    value=level,
                    description=f"Role: {role_name}"
                )
            )
            
        select = discord.ui.Select(
            placeholder="Select a level role to remove...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            level = select.values[0]
            

            del self.level_roles[level]
            self.config["level_roles"] = self.level_roles
            self.bot.config_manager.set_category(self.guild.id, "leveling", self.config)
            

            if hasattr(self.bot, 'leveling_system'):
                self.bot.leveling_system.update_config(self.guild.id)
            
            await interaction.response.send_message(f"Removed role reward for level {level}.", ephemeral=True)
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message("Select a level role to remove:", view=view, ephemeral=True)
        
    @discord.ui.button(label="View Level Roles", style=discord.ButtonStyle.secondary)
    async def view_level_roles(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.level_roles:
            await interaction.response.send_message("No level roles have been configured.", ephemeral=True)
            return
            
        embed = discord.Embed(
            title="Level Role Rewards",
            description="Here are the roles that users will receive at each level:",
            color=discord.Color.blue()
        )
        

        sorted_levels = sorted(self.level_roles.keys(), key=int)
        
        for level in sorted_levels:
            role_id = self.level_roles[level]
            role = self.guild.get_role(int(role_id))
            role_name = role.mention if role else f"Unknown Role (ID: {role_id})"
            
            embed.add_field(name=f"Level {level}", value=role_name, inline=True)
            
        embed.set_footer(text="ZygnalBot © 2025 TheHolyOneZ | Leveling System")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)


class MoodRolesView(discord.ui.View):
    def __init__(self, bot, guild):
        super().__init__(timeout=180)
        self.bot = bot
        self.guild = guild
        self.config = bot.config_manager.get_category(guild.id, "mood_tracking") or {}
        self.mood_roles = self.config.get("mood_roles", {})
        
    @discord.ui.button(label="Set Happy Role", style=discord.ButtonStyle.success, emoji="😄")
    async def set_happy_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.set_mood_role(interaction, "happy", "😄")
        
    @discord.ui.button(label="Set Content Role", style=discord.ButtonStyle.success, emoji="😊")
    async def set_content_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.set_mood_role(interaction, "content", "😊")
        
    @discord.ui.button(label="Set Neutral Role", style=discord.ButtonStyle.secondary, emoji="😐")
    async def set_neutral_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.set_mood_role(interaction, "neutral", "😐")
        
    @discord.ui.button(label="Set Sad Role", style=discord.ButtonStyle.primary, emoji="😔")
    async def set_sad_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.set_mood_role(interaction, "sad", "😔")
        
    @discord.ui.button(label="Set Angry Role", style=discord.ButtonStyle.danger, emoji="😡")
    async def set_angry_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.set_mood_role(interaction, "angry", "😡")
        
    async def set_mood_role(self, interaction, mood_type, emoji):

        options = []
        for role in sorted(self.guild.roles, key=lambda r: r.position, reverse=True)[:25]:
            if role.name != "@everyone" and not role.managed:
                options.append(
                    discord.SelectOption(
                        label=role.name,
                        value=str(role.id),
                        description=f"Role with {len(role.members)} members"
                    )
                )
            
        select = discord.ui.Select(
            placeholder=f"Select a role for {mood_type} mood...",
            min_values=1,
            max_values=1,
            options=options
        )
        
        async def select_callback(interaction: discord.Interaction):
            role_id = select.values[0]
            

            if "mood_roles" not in self.config:
                self.config["mood_roles"] = {}
            
            self.config["mood_roles"][mood_type] = role_id
            self.bot.config_manager.set_category(self.guild.id, "mood_tracking", self.config)
            

            if hasattr(self.bot, 'mood_tracking_system'):
                self.bot.mood_tracking_system.update_config(self.guild.id)
            
            role = self.guild.get_role(int(role_id))
            await interaction.response.send_message(
                f"{emoji} Users with {mood_type} mood will now receive the {role.name} role!",
                ephemeral=True
            )
            
        select.callback = select_callback
        
        view = discord.ui.View()
        view.add_item(select)
        
        await interaction.response.send_message(
            f"Select a role to assign for {mood_type} mood:",
            view=view,
            ephemeral=True
        )

class LevelRoleModal(discord.ui.Modal):
    def __init__(self, action_type, bot, guild, level_roles):
        super().__init__(title="Configure Level Role")
        self.action_type = action_type
        self.bot = bot
        self.guild = guild
        self.level_roles = level_roles
        
        self.add_item(
            discord.ui.TextInput(
                label="Level Number",
                placeholder="Enter the level number (e.g., 5, 10, 25)",
                required=True
            )
        )
        
        self.add_item(
            discord.ui.TextInput(
                label="Role ID or Name",
                placeholder="Enter the role ID or exact role name",
                required=True
            )
        )
        
    async def on_submit(self, interaction: discord.Interaction):
        level = self.children[0].value
        role_input = self.children[1].value
        

        if not level.isdigit() or int(level) <= 0:
            await interaction.response.send_message("Level must be a positive number.", ephemeral=True)
            return
            

        role = None
        

        if role_input.isdigit():
            role = interaction.guild.get_role(int(role_input))
            

        if not role:
            role = discord.utils.get(interaction.guild.roles, name=role_input)
            
        if not role:
            await interaction.response.send_message(f"Could not find a role with ID or name: {role_input}", ephemeral=True)
            return
            

        config = self.bot.config_manager.get_category(interaction.guild.id, "leveling") or {}
        if "level_roles" not in config:
            config["level_roles"] = {}
            
        config["level_roles"][level] = str(role.id)
        self.bot.config_manager.set_category(interaction.guild.id, "leveling", config)
        
        await interaction.response.send_message(f"Users will now receive the {role.name} role when they reach level {level}.", ephemeral=True)


class ConfirmationView(discord.ui.View):
    def __init__(self, prompt):
        super().__init__(timeout=60)
        self.prompt = prompt
        self.value = None
    
    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = True
        self.stop()
        await interaction.response.send_message("Confirmed!", ephemeral=True)
    
    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary)
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = False
        self.stop()
        await interaction.response.send_message("Cancelled!", ephemeral=True)



class ServerConfig(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.config_ui = EnhancedServerConfigUI(bot)
    
    @commands.command(name="config")
    @commands.has_permissions(administrator=True)
    async def server_config(self, ctx):

        await self.config_ui.create_config_panel(ctx)  # Pass ctx directly

    @app_commands.command(name="config", description="Open the advanced server configuration panel")
    @app_commands.default_permissions(administrator=True)
    async def server_config_slash(self, interaction: discord.Interaction):

        await self.config_ui.create_config_panel(interaction)

    @commands.command()
    @commands.is_owner()
    async def sync_here(self, ctx):

        self.bot.tree.copy_global_to(guild=ctx.guild)  # Use self.bot.tree instead of self.tree
        await self.bot.tree.sync(guild=ctx.guild)      # Use self.bot.tree instead of self.tree
        await ctx.send("Commands synced to this server!")



























class UserNotebook(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.data_path = "data/notebooks/"
        self.ensure_data_directory()
        self.notebooks = {}  
        self.load_all_notebooks()
        
    def ensure_data_directory(self):
        os.makedirs(self.data_path, exist_ok=True)
        
    def load_all_notebooks(self):
        for filename in os.listdir(self.data_path):
            if filename.endswith('.json'):
                user_id = filename.split('.')[0]
                try:
                    with open(f"{self.data_path}{filename}", 'r') as f:
                        self.notebooks[user_id] = json.load(f)
                except Exception as e:
                    print(f"Error loading notebook for {user_id}: {e}")
    
    def get_user_notebook(self, user_id):
        user_id = str(user_id)
        if user_id not in self.notebooks:
            self.notebooks[user_id] = {
                "pages": {
                    "default": {
                        "title": "My Notes",
                        "entries": []
                    }
                },
                "last_page": "default"
            }
            self.save_notebook(user_id)
        return self.notebooks[user_id]
    
    def save_notebook(self, user_id):
        user_id = str(user_id)
        with open(f"{self.data_path}{user_id}.json", 'w') as f:
            json.dump(self.notebooks[user_id], f, indent=4)
    
    async def notebook_command(self, ctx):
        user_id = str(ctx.author.id)
        notebook = self.get_user_notebook(user_id)
        

        await self.show_notebook_main_menu(ctx, notebook)
    
    async def show_notebook_main_menu(self, ctx_or_interaction, notebook):
        embed = discord.Embed(
            title="📔 Your Notebook",
            description="Welcome to your personal notebook! Use the buttons below to navigate.",
            color=discord.Color.blue()
        )
        embed.set_footer(text="ZygnalBot Made By TheHolyoneZ")


        pages_text = ""
        for page_id, page in notebook["pages"].items():
            pages_text += f"• {page['title']} ({len(page['entries'])} entries)\n"
        
        embed.add_field(name="Your Pages", value=pages_text if pages_text else "No pages yet")
        

        view = discord.ui.View(timeout=300)
        

        view.add_item(discord.ui.Button(label="View Pages", style=discord.ButtonStyle.primary, custom_id="view_pages"))
        view.add_item(discord.ui.Button(label="Create New Page", style=discord.ButtonStyle.green, custom_id="new_page"))
        view.add_item(discord.ui.Button(label="Bookmark Message", style=discord.ButtonStyle.blurple, custom_id="bookmark"))
        view.add_item(discord.ui.Button(label="Add Note", style=discord.ButtonStyle.blurple, custom_id="add_note"))
        view.add_item(discord.ui.Button(label="Close", style=discord.ButtonStyle.red, custom_id="close"))
        

        for item in view.children:
            item.callback = self.handle_notebook_button
        
        try:

            if hasattr(ctx_or_interaction, 'response'):

                try:
                    if ctx_or_interaction.response.is_done():

                        await ctx_or_interaction.edit_original_response(embed=embed, view=view)
                    else:

                        await ctx_or_interaction.response.edit_message(embed=embed, view=view)
                except:

                    try:
                        await ctx_or_interaction.followup.send(embed=embed, view=view, ephemeral=True)
                    except:

                        if not ctx_or_interaction.response.is_done():
                            await ctx_or_interaction.response.defer()
            else:

                await ctx_or_interaction.send(embed=embed, view=view)
        except Exception as e:

            print(f"Error in show_notebook_main_menu: {e}")

            try:
                if hasattr(ctx_or_interaction, 'author'):
                    await ctx_or_interaction.send(embed=embed, view=view)
                elif hasattr(ctx_or_interaction, 'user'):
                    if not ctx_or_interaction.response.is_done():
                        await ctx_or_interaction.response.send_message(embed=embed, view=view)
                    else:
                        await ctx_or_interaction.followup.send(embed=embed, view=view)
            except Exception as e2:
                print(f"Failed all attempts to respond: {e2}")

    
    async def handle_notebook_button(self, interaction):
        try:
            user_id = str(interaction.user.id)
            notebook = self.get_user_notebook(user_id)
            custom_id = interaction.data["custom_id"]
            
            if custom_id == "view_pages":
                await self.show_pages_menu(interaction, notebook)
            elif custom_id == "new_page":
                try:

                    await self.create_new_page_modal(interaction)
                except Exception as modal_error:

                    print(f"Modal creation failed: {modal_error}")
                    import traceback
                    traceback.print_exc()
                    

                    try:

                        if not interaction.response.is_done():
                            await interaction.response.send_message("Creating a new page...", ephemeral=True)
                        else:
                            await interaction.followup.send("Creating a new page...", ephemeral=True)
                        

                        title_msg = await interaction.followup.send("Please reply with the title for your new page:", ephemeral=True)
                        

                        def check(m):
                            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
                        

                        import asyncio
                        message = await self.bot.wait_for('message', check=check, timeout=60.0)
                        

                        page_title = message.content
                        

                        try:
                            await message.delete()
                        except:
                            pass
                        

                        page_id = f"page_{len(notebook['pages']) + 1}"
                        notebook["pages"][page_id] = {
                            "title": page_title,
                            "entries": []
                        }
                        notebook["last_page"] = page_id
                        self.save_notebook(user_id)
                        

                        await interaction.followup.send(f"Created new page: **{page_title}**", ephemeral=True)
                        

                        temp_message = await interaction.channel.send("Opening notebook...")
                        ctx = await self.bot.get_context(temp_message)
                        await self.show_notebook_main_menu(ctx, notebook)
                        await temp_message.delete()
                        
                    except asyncio.TimeoutError:
                        await interaction.followup.send("You took too long to respond. Please try again.", ephemeral=True)
                    except Exception as fallback_error:
                        print(f"Fallback page creation failed: {fallback_error}")
                        traceback.print_exc()
                        await interaction.followup.send("Unable to create a new page. Please try again later.", ephemeral=True)
            elif custom_id == "bookmark":
                await interaction.response.send_message("Please reply to a message with `!bookmark` to save it", ephemeral=True)
            elif custom_id == "add_note":
                await self.add_note_modal(interaction)
            elif custom_id == "close":
                await interaction.message.delete()
            else:
                await interaction.response.send_message("Unknown action", ephemeral=True)
        except Exception as e:

            print(f"Error in handle_notebook_button: {e}")
            import traceback
            traceback.print_exc()
            
            try:
                if not interaction.response.is_done():
                    await interaction.response.send_message("Something went wrong. Please try again later.", ephemeral=True)
                else:
                    await interaction.followup.send("Something went wrong. Please try again later.", ephemeral=True)
            except:
                pass

        

    async def create_new_page(self, interaction):
        try:

            await interaction.response.defer(ephemeral=True)
            

            await interaction.followup.send("Please enter a title for your new page:", ephemeral=True)
            

            def check(m):
                return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
            

            try:
                message = await self.bot.wait_for('message', check=check, timeout=60.0)
                

                page_title = message.content
                

                try:
                    await message.delete()
                except:
                    pass
                

                user_id = str(interaction.user.id)
                notebook = self.get_user_notebook(user_id)
                

                page_id = f"page_{len(notebook['pages']) + 1}"
                

                notebook["pages"][page_id] = {
                    "title": page_title,
                    "entries": []
                }
                

                notebook["last_page"] = page_id
                

                self.save_notebook(user_id)
                

                print(f"Created new page '{page_title}' for user {user_id}")
                

                await interaction.followup.send(f"Created new page: **{page_title}**", ephemeral=True)
                

                temp_message = await interaction.channel.send("Opening notebook...")
                ctx = await self.bot.get_context(temp_message)
                await self.show_notebook_main_menu(ctx, notebook)
                await temp_message.delete()
                
            except asyncio.TimeoutError:
                await interaction.followup.send("You took too long to respond. Please try again.", ephemeral=True)
                
        except Exception as e:

            print(f"Error in create_new_page: {e}")
            import traceback
            traceback.print_exc()
            

            try:
                await interaction.followup.send("Something went wrong while creating a new page. Please try again.", ephemeral=True)
            except:
                pass

    async def create_new_page_modal(self, interaction):
        try:

            modal = discord.ui.Modal(title="Create New Page")
            

            page_title = discord.ui.TextInput(
                label="Page Title",
                placeholder="Enter a title for your new page",
                required=True,
                max_length=100
            )
            modal.add_item(page_title)
            

            async def modal_callback(interaction):
                try:

                    user_id = str(interaction.user.id)
                    notebook = self.get_user_notebook(user_id)
                    

                    page_id = f"page_{len(notebook['pages']) + 1}"
                    

                    notebook["pages"][page_id] = {
                        "title": page_title.value,
                        "entries": []
                    }
                    

                    notebook["last_page"] = page_id
                    

                    self.save_notebook(user_id)
                    

                    print(f"Created new page '{page_title.value}' for user {user_id}")
                    

                    await interaction.response.send_message(f"Created new page: {page_title.value}", ephemeral=True)
                    

                    try:

                        channel = interaction.channel
                        if channel:

                            temp_message = await channel.send("Opening notebook...")
                            

                            ctx = await self.bot.get_context(temp_message)
                            

                            await self.show_notebook_main_menu(ctx, notebook)
                            

                            await temp_message.delete()
                        else:

                            await interaction.followup.send("Use !notebook to view your updated notebook", ephemeral=True)
                    except Exception as e:
                        print(f"Error refreshing notebook view: {e}")

                        await interaction.followup.send("Notebook updated! Use !notebook to view it.", ephemeral=True)
                    
                except Exception as e:

                    print(f"Error in modal_callback: {e}")
                    import traceback
                    traceback.print_exc()
                    

                    try:
                        if not interaction.response.is_done():
                            await interaction.response.send_message(f"Error creating page: {str(e)}", ephemeral=True)
                        else:
                            await interaction.followup.send(f"Error creating page: {str(e)}", ephemeral=True)
                    except Exception as e2:
                        print(f"Failed to send error message: {e2}")
            

            modal.on_submit = modal_callback
            

            await interaction.response.send_modal(modal)
            
        except Exception as e:

            print(f"Error showing create_new_page_modal: {e}")
            import traceback
            traceback.print_exc()
            

            try:
                if not interaction.response.is_done():
                    await interaction.response.send_message("Something went wrong while creating a new page. Please try again.", ephemeral=True)
                else:
                    await interaction.followup.send("Something went wrong while creating a new page. Please try again.", ephemeral=True)
            except Exception as e2:
                print(f"Failed to send error message: {e2}")


    
    async def show_pages_menu(self, interaction, notebook):
        embed = discord.Embed(
            title="📑 Your Notebook Pages",
            description="Select a page to view or manage",
            color=discord.Color.blue()
        )
        embed.set_footer(text="ZygnalBot Made By TheHolyoneZ")

        view = discord.ui.View(timeout=300)
        

        select = discord.ui.Select(
            placeholder="Select a page",
            options=[
                discord.SelectOption(label=page["title"], value=page_id)
                for page_id, page in notebook["pages"].items()
            ]
        )
        
        async def select_callback(interaction):
            page_id = select.values[0]
            notebook["last_page"] = page_id
            self.save_notebook(str(interaction.user.id))
            await self.show_page_content(interaction, notebook, page_id)
        
        select.callback = select_callback
        view.add_item(select)
        

        back_button = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="back_to_main")
        
        async def back_callback(interaction):
            await self.show_notebook_main_menu(interaction, notebook)
        
        back_button.callback = back_callback
        view.add_item(back_button)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def show_page_content(self, interaction, notebook, page_id):
        page = notebook["pages"][page_id]
        
        embed = discord.Embed(
            title=f"📝 {page['title']}",
            description="Your notes and bookmarks on this page",
            color=discord.Color.green()
        )
        embed.set_footer(text="ZygnalBot Made By TheHolyoneZ")



        entries_text = ""
        for i, entry in enumerate(page["entries"]):
            entry_type = entry.get("type", "note")
            timestamp = entry.get("timestamp", "Unknown time")
            
            if entry_type == "bookmark":
                entries_text += f"{i+1}. 🔖 **Message Bookmark** - {timestamp}\n"
                entries_text += f"   From: {entry.get('author', 'Unknown')}\n"
                entries_text += f"   Content: {entry.get('content', 'No content')[:100]}...\n\n"
            else:
                entries_text += f"{i+1}. 📌 **Note** - {timestamp}\n"
                entries_text += f"   {entry.get('content', 'No content')[:100]}...\n\n"
        
        embed.add_field(name="Entries", value=entries_text if entries_text else "No entries yet")
        
        view = discord.ui.View(timeout=300)
        

        view.add_item(discord.ui.Button(label="Add Note", style=discord.ButtonStyle.primary, custom_id=f"add_note_to_{page_id}"))
        view.add_item(discord.ui.Button(label="View Entry", style=discord.ButtonStyle.blurple, custom_id=f"view_entry_{page_id}"))
        view.add_item(discord.ui.Button(label="Delete Entry", style=discord.ButtonStyle.red, custom_id=f"delete_entry_{page_id}"))
        view.add_item(discord.ui.Button(label="Rename Page", style=discord.ButtonStyle.secondary, custom_id=f"rename_page_{page_id}"))
        view.add_item(discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="back_to_pages"))
        

        for item in view.children:
            item.callback = self.handle_page_button
        

        if hasattr(interaction, 'author'):

            await interaction.send(embed=embed, view=view)
        else:
            try:

                if interaction.response.is_done():

                    await interaction.edit_original_response(embed=embed, view=view)
                else:

                    await interaction.response.edit_message(embed=embed, view=view)
            except Exception as e:
                print(f"Error in show_page_content: {e}")

                try:
                    await interaction.followup.send(embed=embed, view=view, ephemeral=True)
                except:

                    if not interaction.response.is_done():
                        await interaction.response.defer()

    
    async def handle_page_button(self, interaction):
        user_id = str(interaction.user.id)
        notebook = self.get_user_notebook(user_id)
        custom_id = interaction.data["custom_id"]
        
        if custom_id.startswith("add_note_to_"):
            page_id = custom_id.replace("add_note_to_", "")
            await self.add_note_modal(interaction, page_id)
        elif custom_id.startswith("view_entry_"):
            page_id = custom_id.replace("view_entry_", "")
            await self.view_entry_select(interaction, notebook, page_id)
        elif custom_id.startswith("delete_entry_"):
            page_id = custom_id.replace("delete_entry_", "")
            await self.delete_entry_select(interaction, notebook, page_id)
        elif custom_id.startswith("rename_page_"):
            page_id = custom_id.replace("rename_page_", "")
            await self.rename_page_modal(interaction, page_id)
        elif custom_id == "back_to_pages":
            await self.show_pages_menu(interaction, notebook)
        else:
            await interaction.response.send_message("Unknown action", ephemeral=True)
    
    async def add_note_modal(self, interaction, page_id=None):
        try:
            user_id = str(interaction.user.id)
            notebook = self.get_user_notebook(user_id)
            
            if page_id is None:
                page_id = notebook["last_page"]
            
            modal = discord.ui.Modal(title=f"Add Note to {notebook['pages'][page_id]['title']}")
            
            note_content = discord.ui.TextInput(
                label="Note Content",
                style=discord.TextStyle.paragraph,
                placeholder="Enter your note here...",
                required=True,
                max_length=1000
            )
            modal.add_item(note_content)
            
            async def modal_callback(interaction):
                try:

                    notebook["pages"][page_id]["entries"].append({
                        "type": "note",
                        "content": note_content.value,
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    })
                    

                    self.save_notebook(user_id)
                    
                    await interaction.response.send_message("Note added successfully!", ephemeral=True)
                    

                    channel = interaction.channel
                    temp_message = await channel.send("Loading page...")
                    ctx = await self.bot.get_context(temp_message)
                    await self.show_page_content(ctx, notebook, page_id)
                    await temp_message.delete()
                    
                except Exception as e:
                    print(f"Error adding note: {e}")
                    import traceback
                    traceback.print_exc()
                    
                    try:
                        if not interaction.response.is_done():
                            await interaction.response.send_message(f"Error adding note: {str(e)}", ephemeral=True)
                        else:
                            await interaction.followup.send(f"Error adding note: {str(e)}", ephemeral=True)
                    except:
                        pass
            

            modal.on_submit = modal_callback
            

            await interaction.response.send_modal(modal)
            
        except Exception as e:
            print(f"Error showing add_note_modal: {e}")
            import traceback
            traceback.print_exc()
            
            try:
                if not interaction.response.is_done():
                    await interaction.response.send_message("Something went wrong while adding a note. Please try again.", ephemeral=True)
                else:
                    await interaction.followup.send("Something went wrong while adding a note. Please try again.", ephemeral=True)
            except:
                pass

    
    async def bookmark_message(self, ctx, message_id=None):
        user_id = str(ctx.author.id)
        notebook = self.get_user_notebook(user_id)
        page_id = notebook["last_page"]
        

        message = None
        if message_id:
            try:
                message = await ctx.channel.fetch_message(int(message_id))
            except:
                await ctx.send("Couldn't find that message. Make sure you're using a valid message ID.", ephemeral=True)
                return
        elif ctx.message.reference:
            message = await ctx.channel.fetch_message(ctx.message.reference.message_id)
        else:
            await ctx.send("Please reply to a message or provide a message ID to bookmark it.", ephemeral=True)
            return
        

        notebook["pages"][page_id]["entries"].append({
            "type": "bookmark",
            "content": message.content,
            "author": str(message.author),
            "channel": str(message.channel),
            "message_id": str(message.id),
            "jump_url": message.jump_url,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "attachments": [a.url for a in message.attachments],
            "embeds": [e.to_dict() for e in message.embeds]
        })
        

        self.save_notebook(user_id)
        

        embed = discord.Embed(
            title="🔖 Message Bookmarked",
            description=f"Message has been saved to your notebook page: **{notebook['pages'][page_id]['title']}**",
            color=discord.Color.green()
        )
        embed.add_field(name="Message Preview", value=message.content[:100] + "..." if len(message.content) > 100 else message.content)
        embed.set_footer(text=f"From: {message.author} • ZygnalBot Made By TheHolyoneZ")
        
        await ctx.send(embed=embed, ephemeral=True)
    
    async def view_entry_select(self, interaction, notebook, page_id):
        page = notebook["pages"][page_id]
        
        if not page["entries"]:
            await interaction.response.send_message("This page has no entries yet.", ephemeral=True)
            return
        
        view = discord.ui.View(timeout=300)
        

        select = discord.ui.Select(
            placeholder="Select an entry to view",
            options=[
                discord.SelectOption(
                    label=f"Entry {i+1}: {entry.get('type', 'note').capitalize()}", 
                    value=str(i),
                    description=entry.get('content', '')[:100] + "..." if len(entry.get('content', '')) > 100 else entry.get('content', '')
                )
                for i, entry in enumerate(page["entries"])
            ]
        )
        
        async def select_callback(interaction):
            entry_index = int(select.values[0])
            await self.view_entry_details(interaction, notebook, page_id, entry_index)
        
        select.callback = select_callback
        view.add_item(select)
        

        back_button = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="back_to_page")
        
        async def back_callback(interaction):
            await self.show_page_content(interaction, notebook, page_id)
        
        back_button.callback = back_callback
        view.add_item(back_button)
        
        await interaction.response.edit_message(view=view)
    
    async def view_entry_details(self, interaction, notebook, page_id, entry_index):
        page = notebook["pages"][page_id]
        entry = page["entries"][entry_index]
        
        embed = discord.Embed(
            title=f"Entry Details - {entry.get('type', 'note').capitalize()}",
            description=f"From page: **{page['title']}**",
            color=discord.Color.blue()
        )
        embed.set_footer(text="ZygnalBot Made By TheHolyoneZ")

        if entry.get("type") == "bookmark":
            embed.add_field(name="Author", value=entry.get("author", "Unknown"), inline=True)
            embed.add_field(name="Channel", value=entry.get("channel", "Unknown"), inline=True)
            embed.add_field(name="Timestamp", value=entry.get("timestamp", "Unknown"), inline=True)
            embed.add_field(name="Content", value=entry.get("content", "No content"), inline=False)
            

            view = discord.ui.View(timeout=300)
            if "jump_url" in entry:
                view.add_item(discord.ui.Button(
                    label="Go to Original Message", 
                    style=discord.ButtonStyle.url, 
                    url=entry["jump_url"]
                ))
        else:
            embed.add_field(name="Created", value=entry.get("timestamp", "Unknown"), inline=True)
            embed.add_field(name="Content", value=entry.get("content", "No content"), inline=False)
            view = discord.ui.View(timeout=300)
        

        edit_button = discord.ui.Button(label="Edit", style=discord.ButtonStyle.primary, custom_id=f"edit_{entry_index}")
        delete_button = discord.ui.Button(label="Delete", style=discord.ButtonStyle.red, custom_id=f"delete_{entry_index}")
        back_button = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="back_to_entries")
        
        async def edit_callback(interaction):
            await self.edit_entry_modal(interaction, notebook, page_id, entry_index)
        
        async def delete_callback(interaction):

            del notebook["pages"][page_id]["entries"][entry_index]

            self.save_notebook(str(interaction.user.id))
            

            page = notebook["pages"][page_id]
            embed = discord.Embed(
                title=f"📝 {page['title']}",
                description="Your notes and bookmarks on this page",
                color=discord.Color.green()
            )
            

            entries_text = ""
            for i, entry in enumerate(page["entries"]):
                entry_type = entry.get("type", "note")
                timestamp = entry.get("timestamp", "Unknown time")
                
                if entry_type == "bookmark":
                    entries_text += f"{i+1}. 🔖 **Message Bookmark** - {timestamp}\n"
                    entries_text += f"   From: {entry.get('author', 'Unknown')}\n"
                    entries_text += f"   Content: {entry.get('content', 'No content')[:100]}...\n\n"
                else:
                    entries_text += f"{i+1}. 📌 **Note** - {timestamp}\n"
                    entries_text += f"   {entry.get('content', 'No content')[:100]}...\n\n"
            
            embed.add_field(name="Entries", value=entries_text if entries_text else "No entries yet")
            
            view = discord.ui.View(timeout=300)
            

            view.add_item(discord.ui.Button(label="Add Note", style=discord.ButtonStyle.primary, custom_id=f"add_note_to_{page_id}"))
            view.add_item(discord.ui.Button(label="View Entry", style=discord.ButtonStyle.blurple, custom_id=f"view_entry_{page_id}"))
            view.add_item(discord.ui.Button(label="Delete Entry", style=discord.ButtonStyle.red, custom_id=f"delete_entry_{page_id}"))
            view.add_item(discord.ui.Button(label="Rename Page", style=discord.ButtonStyle.secondary, custom_id=f"rename_page_{page_id}"))
            view.add_item(discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="back_to_pages"))
            

            for item in view.children:
                item.callback = self.handle_page_button
            

            await interaction.response.send_message(
                content="Entry deleted successfully!", 
                embed=embed, 
                view=view,
                ephemeral=True
            )

        
        async def back_callback(interaction):
            await self.view_entry_select(interaction, notebook, page_id)
        
        edit_button.callback = edit_callback
        delete_button.callback = delete_callback
        back_button.callback = back_callback
        
        view.add_item(edit_button)
        view.add_item(delete_button)
        view.add_item(back_button)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def edit_entry_modal(self, interaction, notebook, page_id, entry_index):
        page = notebook["pages"][page_id]
        entry = page["entries"][entry_index]
        
        modal = discord.ui.Modal(title=f"Edit {entry.get('type', 'note').capitalize()}")
        
        content_input = discord.ui.TextInput(
            label="Content",
            style=discord.TextStyle.paragraph,
            placeholder="Edit your content here...",
            required=True,
            max_length=1000,
            default=entry.get("content", "")
        )
        modal.add_item(content_input)
        
        async def modal_callback(interaction):

            entry["content"] = content_input.value
            entry["edited_timestamp"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            

            self.save_notebook(str(interaction.user.id))
            
            await interaction.response.send_message("Entry updated successfully!", ephemeral=True)
            

            await self.view_entry_details(interaction, notebook, page_id, entry_index)
        
        modal.callback = modal_callback
        await interaction.response.send_modal(modal)
    
    async def delete_entry_select(self, interaction, notebook, page_id):
        page = notebook["pages"][page_id]
        
        if not page["entries"]:
            await interaction.response.send_message("This page has no entries to delete.", ephemeral=True)
            return
        
        view = discord.ui.View(timeout=300)
        
        select = discord.ui.Select(
            placeholder="Select an entry to delete",
            options=[
                discord.SelectOption(
                    label=f"Entry {i+1}: {entry.get('type', 'note').capitalize()}", 
                    value=str(i),
                    description=entry.get('content', '')[:100] + "..." if len(entry.get('content', '')) > 100 else entry.get('content', '')
                )
                for i, entry in enumerate(page["entries"])
            ]
        )
        
        async def select_callback(interaction):
            entry_index = int(select.values[0])
            

            confirm_embed = discord.Embed(
                title="Confirm Deletion",
                description=f"Are you sure you want to delete this entry?",
                color=discord.Color.red()
            )
            
            entry = page["entries"][entry_index]
            confirm_embed.add_field(
                name="Entry Preview", 
                value=entry.get('content', '')[:100] + "..." if len(entry.get('content', '')) > 100 else entry.get('content', '')
            )
            

            confirm_embed.set_footer(text="ZygnalBot Made By TheHolyoneZ")
            
            confirm_view = discord.ui.View(timeout=60)
            confirm_button = discord.ui.Button(label="Delete", style=discord.ButtonStyle.danger, custom_id="confirm_delete")
            cancel_button = discord.ui.Button(label="Cancel", style=discord.ButtonStyle.secondary, custom_id="cancel_delete")
            
            async def confirm_callback(interaction):

                del notebook["pages"][page_id]["entries"][entry_index]

                self.save_notebook(str(interaction.user.id))
                await interaction.response.send_message("Entry deleted successfully!", ephemeral=True)

                await self.show_page_content(interaction, notebook, page_id)
            
            async def cancel_callback(interaction):
                await self.show_page_content(interaction, notebook, page_id)
            
            confirm_button.callback = confirm_callback
            cancel_button.callback = cancel_callback
            
            confirm_view.add_item(confirm_button)
            confirm_view.add_item(cancel_button)
            
            await interaction.response.edit_message(embed=confirm_embed, view=confirm_view)
        
        select.callback = select_callback
        view.add_item(select)
        

        back_button = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="back_to_page")
        
        async def back_callback(interaction):
            await self.show_page_content(interaction, notebook, page_id)
        
        back_button.callback = back_callback
        view.add_item(back_button)
        
        await interaction.response.edit_message(view=view)

    async def rename_page_modal(self, interaction, page_id):
        try:
            user_id = str(interaction.user.id)
            notebook = self.get_user_notebook(user_id)
            page = notebook["pages"][page_id]
            
            modal = discord.ui.Modal(title="Rename Page")
            
            page_title = discord.ui.TextInput(
                label="New Page Title",
                placeholder="Enter a new title for your page",
                required=True,
                max_length=100,
                default=page["title"]
            )
            modal.add_item(page_title)
            
            async def modal_callback(interaction):
                try:

                    notebook["pages"][page_id]["title"] = page_title.value
                    
                    self.save_notebook(user_id)
                    
                    await interaction.response.send_message(f"Page renamed to: {page_title.value}", ephemeral=True)
                    
                    channel = interaction.channel
                    temp_message = await channel.send("Loading page...")
                    ctx = await self.bot.get_context(temp_message)
                    await self.show_page_content(ctx, notebook, page_id)
                    await temp_message.delete()
                    
                except Exception as e:
                    print(f"Error renaming page: {e}")
                    import traceback
                    traceback.print_exc()
                    
                    try:
                        if not interaction.response.is_done():
                            await interaction.response.send_message(f"Error renaming page: {str(e)}", ephemeral=True)
                        else:
                            await interaction.followup.send(f"Error renaming page: {str(e)}", ephemeral=True)
                    except:
                        pass
            

            modal.on_submit = modal_callback
            

            await interaction.response.send_modal(modal)
            
        except Exception as e:
            print(f"Error showing rename_page_modal: {e}")
            import traceback
            traceback.print_exc()
            
            try:
                if not interaction.response.is_done():
                    await interaction.response.send_message("Something went wrong while renaming the page. Please try again.", ephemeral=True)
                else:
                    await interaction.followup.send("Something went wrong while renaming the page. Please try again.", ephemeral=True)
            except:
                pass

    @commands.command(name="notebook", aliases=["nb", "notes"])
    async def notebook_cmd(self, ctx):
        await self.notebook_command(ctx)
            
    @commands.command(name="bookmark", aliases=["bm", "save"])
    async def bookmark_cmd(self, ctx, message_id=None):
        await self.bookmark_message(ctx, message_id)

class CommandAliases(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.aliases_file = "data/command_aliases.json"
        self.command_aliases = {}
        self.load_aliases()
        
    def load_aliases(self):
        if os.path.exists(self.aliases_file):
            try:
                with open(self.aliases_file, 'r') as f:
                    self.command_aliases = json.load(f)
            except Exception as e:
                print(f"Error loading command aliases: {e}")
                self.command_aliases = {}
        else:
            os.makedirs(os.path.dirname(self.aliases_file), exist_ok=True)
            self.command_aliases = {}
            self.save_aliases()
    
    def save_aliases(self):
        with open(self.aliases_file, 'w') as f:
            json.dump(self.command_aliases, f, indent=4)
    
    @commands.group(name="alias", aliases=["aliases"], invoke_without_command=True)
    async def alias_group(self, ctx):
        embed = discord.Embed(
            title="⚡ ZygnalBot Command Aliases",
            description="Create custom triggers for existing commands",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Available Commands",
            value=(
                "`!alias create` - Create a new alias for an existing command\n"
                "`!alias delete <alias>` - Delete an existing alias\n"
                "`!alias list` - List all aliases\n"
                "`!alias info <alias>` - Show info about an alias"
            ),
            inline=False
        )
        embed.set_footer(text="ZygnalBot Command Aliases | © TheHolyOneZ")
        await ctx.send(embed=embed)
    
    @alias_group.command(name="create")
    @commands.has_permissions(manage_guild=True)
    async def create_alias(self, ctx, alias: str = None, *, command: str = None):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.command_aliases:
            self.command_aliases[guild_id] = {}
        if alias is None or command is None:
            embed = discord.Embed(
                title="Create Command Alias",
                description="Let's create a new alias for an existing command!",
                color=discord.Color.green()
            )
            await ctx.send(embed=embed)
            
            def check(m):
                return m.author == ctx.author and m.channel == ctx.channel
            if alias is None:
                await ctx.send("What would you like the alias to be? (without the prefix)")
                try:
                    alias_msg = await self.bot.wait_for('message', check=check, timeout=60)
                    alias = alias_msg.content.lower()
                except asyncio.TimeoutError:
                    return await ctx.send("⏱️ Alias creation timed out.")
            if command is None:
                await ctx.send("What command should this alias trigger? (include the prefix and any parameters)")
                try:
                    command_msg = await self.bot.wait_for('message', check=check, timeout=60)
                    command = command_msg.content
                except asyncio.TimeoutError:
                    return await ctx.send("⏱️ Alias creation timed out.")
        if alias in self.bot.all_commands:
            return await ctx.send(f"⚠️ `{alias}` is already a built-in command. Please choose a different alias.")
        
        if alias in self.command_aliases.get(guild_id, {}):
            return await ctx.send(f"⚠️ `{alias}` already exists as an alias. Use `!alias delete {alias}` to remove it first.")
        prefix = self.bot.command_prefix
        if not command.startswith(prefix):
            command = prefix + command
        base_command = command.split()[0][len(prefix):]
        if base_command not in self.bot.all_commands:
            confirm_embed = discord.Embed(
                title="⚠️ Command Not Found",
                description=f"The command `{prefix}{base_command}` doesn't appear to be a built-in command. Create the alias anyway?",
                color=discord.Color.gold()
            )
            confirm_msg = await ctx.send(embed=confirm_embed)
            
            await confirm_msg.add_reaction("✅")
            await confirm_msg.add_reaction("❌")
            
            def reaction_check(reaction, user):
                return user == ctx.author and reaction.message.id == confirm_msg.id and str(reaction.emoji) in ["✅", "❌"]
            
            try:
                reaction, user = await self.bot.wait_for('reaction_add', check=reaction_check, timeout=30)
                
                if str(reaction.emoji) == "❌":
                    return await ctx.send("Alias creation cancelled.")
            except asyncio.TimeoutError:
                return await ctx.send("Alias creation timed out.")
        self.command_aliases[guild_id][alias] = {
            "command": command,
            "created_by": ctx.author.id,
            "created_at": datetime.now().isoformat(),
            "uses": 0
        }
        self.save_aliases()
        
        success_embed = discord.Embed(
            title="✅ Alias Created Successfully",
            description=f"The alias `{prefix}{alias}` has been created for command `{command}`!",
            color=discord.Color.green()
        )
        success_embed.set_footer(text="ZygnalBot Command Aliases | © TheHolyOneZ")
        await ctx.send(embed=success_embed)
    
    @alias_group.command(name="list")
    async def list_aliases(self, ctx):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.command_aliases or not self.command_aliases[guild_id]:
            return await ctx.send("This server doesn't have any command aliases yet.")
        
        aliases_list = self.command_aliases[guild_id]
        
        embed = discord.Embed(
            title=f"⚡ Command Aliases for {ctx.guild.name}",
            description=f"This server has {len(aliases_list)} command aliases.",
            color=discord.Color.blue()
        )
        categories = {}
        
        for alias_name, alias_data in aliases_list.items():
            command = alias_data["command"]
            base_command = command.split()[0][len(self.bot.command_prefix):]
            cmd = self.bot.get_command(base_command)
            category = cmd.cog_name if cmd and cmd.cog_name else "Other"
            
            if category not in categories:
                categories[category] = []
            
            categories[category].append((alias_name, command))
        for category, aliases in sorted(categories.items()):
            value = "\n".join([f"`{self.bot.command_prefix}{alias}` → `{cmd}`" for alias, cmd in aliases])
            if len(value) > 1024:
                chunks = [value[i:i+1024] for i in range(0, len(value), 1024)]
                for i, chunk in enumerate(chunks):
                    embed.add_field(
                        name=f"{category} ({i+1}/{len(chunks)})",
                        value=chunk,
                        inline=False
                    )
            else:
                embed.add_field(
                    name=category,
                    value=value,
                    inline=False
                )
        
        embed.set_footer(text="Use !alias info <alias> to see details | © ZygnalBot")
        await ctx.send(embed=embed)
    
    @alias_group.command(name="delete", aliases=["remove"])
    @commands.has_permissions(manage_guild=True)
    async def delete_alias(self, ctx, alias: str):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.command_aliases or alias not in self.command_aliases[guild_id]:
            return await ctx.send(f"Alias `{alias}` doesn't exist.")
        confirm_embed = discord.Embed(
            title="⚠️ Confirm Deletion",
            description=f"Are you sure you want to delete the alias `{self.bot.command_prefix}{alias}`?",
            color=discord.Color.red()
        )
        confirm_msg = await ctx.send(embed=confirm_embed)
        
        await confirm_msg.add_reaction("✅")
        await confirm_msg.add_reaction("❌")
        
        def reaction_check(reaction, user):
            return user == ctx.author and reaction.message.id == confirm_msg.id and str(reaction.emoji) in ["✅", "❌"]
        
        try:
            reaction, user = await self.bot.wait_for('reaction_add', check=reaction_check, timeout=30)
            
            if str(reaction.emoji) == "✅":
                del self.command_aliases[guild_id][alias]
                self.save_aliases()
                
                success_embed = discord.Embed(
                    title="✅ Alias Deleted",
                    description=f"The alias `{self.bot.command_prefix}{alias}` has been deleted.",
                    color=discord.Color.green()
                )
                await ctx.send(embed=success_embed)
            else:
                await ctx.send("Alias deletion cancelled.")
                
        except asyncio.TimeoutError:
            await ctx.send("Alias deletion timed out.")
    
    @alias_group.command(name="info")
    async def alias_info(self, ctx, alias: str):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.command_aliases or alias not in self.command_aliases[guild_id]:
            return await ctx.send(f"Alias `{alias}` doesn't exist.")
        
        alias_data = self.command_aliases[guild_id][alias]
        creator = await self.bot.fetch_user(alias_data["created_by"])
        
        embed = discord.Embed(
            title=f"Alias Info: {self.bot.command_prefix}{alias}",
            color=discord.Color.blue()
        )
        
        embed.add_field(name="Triggers Command", value=f"`{alias_data['command']}`", inline=False)
        embed.add_field(name="Created By", value=creator.mention, inline=True)
        embed.add_field(name="Uses", value=str(alias_data["uses"]), inline=True)
        
        created_at = datetime.fromisoformat(alias_data["created_at"])
        embed.add_field(name="Created On", value=created_at.strftime("%Y-%m-%d %H:%M:%S"), inline=True)
        
        embed.set_footer(text="ZygnalBot Command Aliases | © TheHolyOneZ")
        await ctx.send(embed=embed)
    
    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        if message.guild:  
            return           
        guild_id = str(message.guild.id)
        
        if guild_id not in self.command_aliases:
            return
        
        prefix = self.bot.command_prefix
        if not message.content.startswith(prefix):
            return
        
        content = message.content[len(prefix):]
        potential_alias = content.split()[0].lower()
        
        if potential_alias in self.command_aliases[guild_id]:
            alias_data = self.command_aliases[guild_id][potential_alias]
            command = alias_data["command"]
            
            if len(content.split()) > 1:
                args = content.split(' ', 1)[1]
                
                if ' ' in command[len(prefix):]:
                    base_cmd, cmd_args = command.split(' ', 1)
                    new_command = f"{base_cmd} {args} {cmd_args}"
                else:
                    new_command = f"{command} {args}"
            else:
                new_command = command
            
            self.command_aliases[guild_id][potential_alias]["uses"] += 1
            self.save_aliases()
            original_content = message.content
            message._update({'content': new_command})
            await self.bot.process_commands(message)
            message._update({'content': original_content})
            return

class CustomCommands(commands.Cog):
    
    def __init__(self, bot):
        self.bot = bot
        self.commands_file = "data/custom_commands.json"
        self.custom_commands = {}
        self.load_commands()
        
    def load_commands(self):
        if os.path.exists(self.commands_file):
            try:
                with open(self.commands_file, 'r') as f:
                    self.custom_commands = json.load(f)
            except Exception as e:
                print(f"Error loading custom commands: {e}")
                self.custom_commands = {}
        else:
           
            os.makedirs(os.path.dirname(self.commands_file), exist_ok=True)
            self.custom_commands = {}
            self.save_commands()
    
    def save_commands(self):
        with open(self.commands_file, 'w') as f:
            json.dump(self.custom_commands, f, indent=4)
    
    @commands.group(name="custom", aliases=["cc"], invoke_without_command=True)
    async def custom_command_group(self, ctx):
        embed = discord.Embed(
            title="⚡ ZygnalBot Custom Commands",
            description="Manage your server's custom commands",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Available Commands",
            value=(
                "`!custom create` - Create a new custom command\n"
                "`!custom edit` - Edit an existing custom command\n"
                "`!custom delete <command>` - Delete a custom command\n"
                "`!custom list` - List all custom commands\n"
                "`!custom info <command>` - Show info about a command"
            ),
            inline=False
        )
        embed.set_footer(text="ZygnalBot Custom Commands | © TheHolyOneZ")
        await ctx.send(embed=embed)
    
    @custom_command_group.command(name="create")
    @commands.has_permissions(manage_guild=True)
    async def create_command(self, ctx):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.custom_commands:
            self.custom_commands[guild_id] = {}
        embed = discord.Embed(
            title="Custom Command Creator",
            description="Let's create a new custom command! What would you like the command name to be?\n\n"
                        "Type the command name without the prefix (e.g. `hello` for `!hello`)",
            color=discord.Color.green()
        )
        embed.set_footer(text="Type 'cancel' to cancel the process")
        
        await ctx.send(embed=embed)
        
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
        
        try:
            cmd_msg = await self.bot.wait_for('message', check=check, timeout=60)
            
            if cmd_msg.content.lower() == 'cancel':
                return await ctx.send("Command creation cancelled.")
            
            cmd_name = cmd_msg.content.lower()
            
            if cmd_name in self.bot.all_commands:
                return await ctx.send(f"⚠️ `{cmd_name}` is already a built-in command. Please choose a different name.")
            
            if cmd_name in self.custom_commands.get(guild_id, {}):
                return await ctx.send(f"⚠️ `{cmd_name}` already exists as a custom command. Use `!custom edit {cmd_name}` to modify it.")
            type_embed = discord.Embed(
                title="Response Type",
                description="What type of response should this command have?\n\n"
                            "1️⃣ Text - Simple text response\n"
                            "2️⃣ Embed - Fancy embed response\n"
                            "3️⃣ Random - Random response from a list",
                color=discord.Color.blue()
            )
            type_msg = await ctx.send(embed=type_embed)
            await type_msg.add_reaction("1️⃣")
            await type_msg.add_reaction("2️⃣")
            await type_msg.add_reaction("3️⃣")
            
            def reaction_check(reaction, user):
                return user == ctx.author and reaction.message.id == type_msg.id and str(reaction.emoji) in ["1️⃣", "2️⃣", "3️⃣"]
            
            reaction, user = await self.bot.wait_for('reaction_add', check=reaction_check, timeout=60)
            
            response_type = {
                "1️⃣": "text",
                "2️⃣": "embed",
                "3️⃣": "random"
            }[str(reaction.emoji)]
            if response_type == "text":
                await ctx.send("Enter the text response for this command:")
                content_msg = await self.bot.wait_for('message', check=check, timeout=120)
                
                if content_msg.content.lower() == 'cancel':
                    return await ctx.send("Command creation cancelled.")
                
                command_data = {
                    "type": "text",
                    "response": content_msg.content,
                    "created_by": ctx.author.id,
                    "created_at": datetime.now().isoformat(),
                    "uses": 0
                }
                
            elif response_type == "embed":
                await ctx.send("Enter the embed title (type 'none' for no title):")
                title_msg = await self.bot.wait_for('message', check=check, timeout=60)
                
                if title_msg.content.lower() == 'cancel':
                    return await ctx.send("Command creation cancelled.")
                
                title = None if title_msg.content.lower() == 'none' else title_msg.content
                
                await ctx.send("Enter the embed description:")
                desc_msg = await self.bot.wait_for('message', check=check, timeout=120)
                
                if desc_msg.content.lower() == 'cancel':
                    return await ctx.send("Command creation cancelled.")
                
                await ctx.send("Enter the embed color (hex code like #FF0000 or 'random'):")
                color_msg = await self.bot.wait_for('message', check=check, timeout=60)
                
                if color_msg.content.lower() == 'cancel':
                    return await ctx.send("Command creation cancelled.")
                
                if color_msg.content.lower() == 'random':
                    color = "random"
                else:
                    try:
                        color = color_msg.content.lstrip('#')
                        color = int(color, 16)
                    except ValueError:
                        color = 0x3498db  
                
                command_data = {
                    "type": "embed",
                    "title": title,
                    "description": desc_msg.content,
                    "color": color,
                    "created_by": ctx.author.id,
                    "created_at": datetime.now().isoformat(),
                    "uses": 0
                }
                
            elif response_type == "random":
                responses = []
                await ctx.send("Enter your responses one by one. Type 'done' when finished:")
                
                while True:
                    response_msg = await self.bot.wait_for('message', check=check, timeout=60)
                    
                    if response_msg.content.lower() == 'cancel':
                        return await ctx.send("Command creation cancelled.")
                    
                    if response_msg.content.lower() == 'done':
                        if not responses:
                            await ctx.send("You need to add at least one response. Please enter a response:")
                            continue
                        break
                    
                    responses.append(response_msg.content)
                    await ctx.message.add_reaction("✅")
                
                command_data = {
                    "type": "random",
                    "responses": responses,
                    "created_by": ctx.author.id,
                    "created_at": datetime.now().isoformat(),
                    "uses": 0
                }
            self.custom_commands[guild_id][cmd_name] = command_data
            self.save_commands()
            
            success_embed = discord.Embed(
                title="✅ Command Created Successfully",
                description=f"The command `{self.bot.command_prefix}{cmd_name}` has been created!",
                color=discord.Color.green()
            )
            success_embed.set_footer(text="ZygnalBot Custom Commands | © TheHolyOneZ")
            await ctx.send(embed=success_embed)
            
        except asyncio.TimeoutError:
            await ctx.send("⏱️ Command creation timed out.")
    
    @custom_command_group.command(name="list")
    async def list_commands(self, ctx):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.custom_commands or not self.custom_commands[guild_id]:
            return await ctx.send("This server doesn't have any custom commands yet.")
        
        commands_list = self.custom_commands[guild_id]
        
        embed = discord.Embed(
            title=f"⚡ Custom Commands for {ctx.guild.name}",
            description=f"This server has {len(commands_list)} custom commands.",
            color=discord.Color.blue()
        )
        text_cmds = []
        embed_cmds = []
        random_cmds = []
        
        for cmd_name, cmd_data in commands_list.items():
            if cmd_data["type"] == "text":
                text_cmds.append(cmd_name)
            elif cmd_data["type"] == "embed":
                embed_cmds.append(cmd_name)
            elif cmd_data["type"] == "random":
                random_cmds.append(cmd_name)
        
        if text_cmds:
            embed.add_field(
                name="📝 Text Commands",
                value=", ".join([f"`{self.bot.command_prefix}{cmd}`" for cmd in text_cmds]),
                inline=False
            )
        
        if embed_cmds:
            embed.add_field(
                name="🖼️ Embed Commands",
                value=", ".join([f"`{self.bot.command_prefix}{cmd}`" for cmd in embed_cmds]),
                inline=False
            )
        
        if random_cmds:
            embed.add_field(
                name="🎲 Random Response Commands",
                value=", ".join([f"`{self.bot.command_prefix}{cmd}`" for cmd in random_cmds]),
                inline=False
            )
        
        embed.set_footer(text="Use !custom info <command> to see details | © ZygnalBot")
        await ctx.send(embed=embed)
    
    @custom_command_group.command(name="delete", aliases=["remove"])
    @commands.has_permissions(manage_guild=True)
    async def delete_command(self, ctx, command_name: str):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.custom_commands or command_name not in self.custom_commands[guild_id]:
            return await ctx.send(f"Command `{command_name}` doesn't exist.")
        confirm_embed = discord.Embed(
            title="⚠️ Confirm Deletion",
            description=f"Are you sure you want to delete the command `{self.bot.command_prefix}{command_name}`?",
            color=discord.Color.red()
        )
        confirm_msg = await ctx.send(embed=confirm_embed)
        
        await confirm_msg.add_reaction("✅")
        await confirm_msg.add_reaction("❌")
        
        def reaction_check(reaction, user):
            return user == ctx.author and reaction.message.id == confirm_msg.id and str(reaction.emoji) in ["✅", "❌"]
        
        try:
            reaction, user = await self.bot.wait_for('reaction_add', check=reaction_check, timeout=30)
            
            if str(reaction.emoji) == "✅":
                del self.custom_commands[guild_id][command_name]
                self.save_commands()
                
                success_embed = discord.Embed(
                    title="✅ Command Deleted",
                    description=f"The command `{self.bot.command_prefix}{command_name}` has been deleted.",
                    color=discord.Color.green()
                )
                await ctx.send(embed=success_embed)
            else:
                await ctx.send("Command deletion cancelled.")
                
        except asyncio.TimeoutError:
            await ctx.send("Command deletion timed out.")
    
    @custom_command_group.command(name="info")
    async def command_info(self, ctx, command_name: str):
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.custom_commands or command_name not in self.custom_commands[guild_id]:
            return await ctx.send(f"Command `{command_name}` doesn't exist.")
        
        cmd_data = self.custom_commands[guild_id][command_name]
        creator = await self.bot.fetch_user(cmd_data["created_by"])
        
        embed = discord.Embed(
            title=f"Command Info: {self.bot.command_prefix}{command_name}",
            color=discord.Color.blue()
        )
        
        embed.add_field(name="Type", value=cmd_data["type"].capitalize(), inline=True)
        embed.add_field(name="Created By", value=creator.mention, inline=True)
        embed.add_field(name="Uses", value=str(cmd_data["uses"]), inline=True)
        
        created_at = datetime.fromisoformat(cmd_data["created_at"])
        embed.add_field(name="Created On", value=created_at.strftime("%Y-%m-%d %H:%M:%S"), inline=True)
        
        if cmd_data["type"] == "text":
            preview = cmd_data["response"]
            if len(preview) > 1000:
                preview = preview[:997] + "..."
            embed.add_field(name="Response Preview", value=preview, inline=False)
            
        elif cmd_data["type"] == "embed":
            embed.add_field(name="Embed Title", value=cmd_data["title"] or "None", inline=True)
            
            preview = cmd_data["description"]
            if len(preview) > 1000:
                preview = preview[:997] + "..."
            embed.add_field(name="Embed Description Preview", value=preview, inline=False)
            
        elif cmd_data["type"] == "random":
            responses = cmd_data["responses"]
            count = len(responses)
            
            embed.add_field(name="Response Count", value=str(count), inline=True)
            
            if count <= 5:
                preview = "\n".join([f"{i+1}. {r}" for i, r in enumerate(responses)])
                if len(preview) > 1000:
                    preview = preview[:997] + "..."
                embed.add_field(name="Responses", value=preview, inline=False)
            else:
                preview = "\n".join([f"{i+1}. {r}" for i, r in enumerate(responses[:3])])
                preview += f"\n... and {count-3} more responses"
                embed.add_field(name="Sample Responses", value=preview, inline=False)
        
        embed.set_footer(text="ZygnalBot Custom Commands | © TheHolyOneZ")
        await ctx.send(embed=embed)
    
    @custom_command_group.command(name="edit")
    @commands.has_permissions(manage_guild=True)
    async def edit_command(self, ctx, command_name: str = None):
        guild_id = str(ctx.guild.id)
        
        if not command_name:
            if guild_id not in self.custom_commands or not self.custom_commands[guild_id]:
                return await ctx.send("This server doesn't have any custom commands to edit.")
            
            commands_list = list(self.custom_commands[guild_id].keys())
            
            embed = discord.Embed(
                title="Edit Custom Command",
                description="Which command would you like to edit? Type the command name:",
                color=discord.Color.blue()
            )
            
            commands_text = ", ".join([f"`{cmd}`" for cmd in commands_list])
            embed.add_field(name="Available Commands", value=commands_text, inline=False)
            
            await ctx.send(embed=embed)
            
            def check(m):
                return m.author == ctx.author and m.channel == ctx.channel
            
            try:
                cmd_msg = await self.bot.wait_for('message', check=check, timeout=60)
                command_name = cmd_msg.content.lower()
                
                if command_name not in self.custom_commands[guild_id]:
                    return await ctx.send(f"Command `{command_name}` doesn't exist.")
                
            except asyncio.TimeoutError:
                return await ctx.send("Command edit timed out.")
        
        if guild_id not in self.custom_commands or command_name not in self.custom_commands[guild_id]:
            return await ctx.send(f"Command `{command_name}` doesn't exist.")
        
        cmd_data = self.custom_commands[guild_id][command_name]
        options_embed = discord.Embed(
            title=f"Editing Command: {self.bot.command_prefix}{command_name}",
            description="What would you like to edit? React with the corresponding number:",
            color=discord.Color.blue()
        )
        
        if cmd_data["type"] == "text":
            options_embed.add_field(
                name="Options",
                value="1️⃣ Edit response text\n2️⃣ Change command name",
                inline=False
            )
        elif cmd_data["type"] == "embed":
            options_embed.add_field(
                name="Options",
                value="1️⃣ Edit embed title\n2️⃣ Edit embed description\n3️⃣ Change embed color\n4️⃣ Change command name",
                inline=False
            )
        elif cmd_data["type"] == "random":
            options_embed.add_field(
                name="Options",
                value="1️⃣ Add new responses\n2️⃣ Remove responses\n3️⃣ Change command name",
                inline=False
            )
        
        options_msg = await ctx.send(embed=options_embed)
        if cmd_data["type"] == "text":
            await options_msg.add_reaction("1️⃣")
            await options_msg.add_reaction("2️⃣")
            
            valid_reactions = ["1️⃣", "2️⃣"]
        elif cmd_data["type"] == "embed":
            await options_msg.add_reaction("1️⃣")
            await options_msg.add_reaction("2️⃣")
            await options_msg.add_reaction("3️⃣")
            await options_msg.add_reaction("4️⃣")
            
            valid_reactions = ["1️⃣", "2️⃣", "3️⃣", "4️⃣"]
        elif cmd_data["type"] == "random":
            await options_msg.add_reaction("1️⃣")
            await options_msg.add_reaction("2️⃣")
            await options_msg.add_reaction("3️⃣")
            
            valid_reactions = ["1️⃣", "2️⃣", "3️⃣"]
        
        def reaction_check(reaction, user):
            return user == ctx.author and reaction.message.id == options_msg.id and str(reaction.emoji) in valid_reactions
        
        try:
            reaction, user = await self.bot.wait_for('reaction_add', check=reaction_check, timeout=60)
            
            def message_check(m):
                return m.author == ctx.author and m.channel == ctx.channel
            if cmd_data["type"] == "text":
                if str(reaction.emoji) == "1️⃣":  
                    await ctx.send(f"Current response: ```{cmd_data['response']}```\nEnter the new response text:")
                    
                    content_msg = await self.bot.wait_for('message', check=message_check, timeout=120)
                    
                    if content_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    cmd_data["response"] = content_msg.content
                    self.custom_commands[guild_id][command_name] = cmd_data
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command `{self.bot.command_prefix}{command_name}` response updated!")
                    
                elif str(reaction.emoji) == "2️⃣":  
                    await ctx.send(f"Current name: `{command_name}`\nEnter the new command name:")
                    
                    name_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                    
                    if name_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    new_name = name_msg.content.lower()
                    
                    if new_name in self.bot.all_commands:
                        return await ctx.send(f"⚠️ `{new_name}` is already a built-in command. Please choose a different name.")
                    
                    if new_name in self.custom_commands[guild_id]:
                        return await ctx.send(f"⚠️ `{new_name}` already exists as a custom command.")
                    self.custom_commands[guild_id][new_name] = cmd_data
                    del self.custom_commands[guild_id][command_name]
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command renamed from `{self.bot.command_prefix}{command_name}` to `{self.bot.command_prefix}{new_name}`!")
            elif cmd_data["type"] == "embed":
                if str(reaction.emoji) == "1️⃣":  
                    current_title = cmd_data.get("title", "None")
                    await ctx.send(f"Current title: `{current_title}`\nEnter the new title (or 'none' for no title):")
                    
                    title_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                    
                    if title_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    if title_msg.content.lower() == 'none':
                        cmd_data["title"] = None
                    else:
                        cmd_data["title"] = title_msg.content
                    
                    self.custom_commands[guild_id][command_name] = cmd_data
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command `{self.bot.command_prefix}{command_name}` title updated!")
                    
                elif str(reaction.emoji) == "2️⃣": 
                    await ctx.send(f"Current description: ```{cmd_data['description']}```\nEnter the new description:")
                    
                    desc_msg = await self.bot.wait_for('message', check=message_check, timeout=120)
                    
                    if desc_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    cmd_data["description"] = desc_msg.content
                    self.custom_commands[guild_id][command_name] = cmd_data
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command `{self.bot.command_prefix}{command_name}` description updated!")
                    
                elif str(reaction.emoji) == "3️⃣":  
                    current_color = cmd_data.get("color", "Default")
                    await ctx.send(f"Current color: `{current_color}`\nEnter the new color (hex code like #FF0000 or 'random'):")
                    
                    color_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                    
                    if color_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    if color_msg.content.lower() == 'random':
                        cmd_data["color"] = "random"
                    else:
                        try:
                            color = color_msg.content.lstrip('#')
                            cmd_data["color"] = int(color, 16)
                        except ValueError:
                            await ctx.send("Invalid color format. Using default blue color.")
                            cmd_data["color"] = 0x3498db
                    
                    self.custom_commands[guild_id][command_name] = cmd_data
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command `{self.bot.command_prefix}{command_name}` color updated!")
                    
                elif str(reaction.emoji) == "4️⃣": 
                    await ctx.send(f"Current name: `{command_name}`\nEnter the new command name:")
                    
                    name_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                    
                    if name_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    new_name = name_msg.content.lower()
                    
                    if new_name in self.bot.all_commands:
                        return await ctx.send(f"⚠️ `{new_name}` is already a built-in command. Please choose a different name.")
                    
                    if new_name in self.custom_commands[guild_id]:
                        return await ctx.send(f"⚠️ `{new_name}` already exists as a custom command.")
                    self.custom_commands[guild_id][new_name] = cmd_data
                    del self.custom_commands[guild_id][command_name]
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command renamed from `{self.bot.command_prefix}{command_name}` to `{self.bot.command_prefix}{new_name}`!")
            elif cmd_data["type"] == "random":
                if str(reaction.emoji) == "1️⃣":  
                    current_responses = cmd_data["responses"]
                    await ctx.send(f"You currently have {len(current_responses)} responses. Enter new responses one by one. Type 'done' when finished:")
                    
                    while True:
                        response_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                        
                        if response_msg.content.lower() == 'cancel':
                            return await ctx.send("Command edit cancelled.")
                        
                        if response_msg.content.lower() == 'done':
                            break
                        
                        current_responses.append(response_msg.content)
                        await ctx.message.add_reaction("✅")
                    
                    cmd_data["responses"] = current_responses
                    self.custom_commands[guild_id][command_name] = cmd_data
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command `{self.bot.command_prefix}{command_name}` responses updated! Now has {len(current_responses)} responses.")
                    
                elif str(reaction.emoji) == "2️⃣":  
                    current_responses = cmd_data["responses"]
                    
                    if len(current_responses) <= 1:
                        return await ctx.send("⚠️ You need at least one response. Add more responses before removing any.")
                    responses_text = "\n".join([f"{i+1}. {r}" for i, r in enumerate(current_responses)])
                    if len(responses_text) > 1900:
                        chunks = [responses_text[i:i+1900] for i in range(0, len(responses_text), 1900)]
                        for chunk in chunks:
                            await ctx.send(f"```{chunk}```")
                    else:
                        await ctx.send(f"```{responses_text}```")
                    
                    await ctx.send("Enter the numbers of the responses to remove (comma-separated, e.g. '1,3,5'):")
                    
                    remove_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                    
                    if remove_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    try:
                        indices = [int(idx.strip()) - 1 for idx in remove_msg.content.split(',')]
                        indices.sort(reverse=True)  
                        if any(idx < 0 or idx >= len(current_responses) for idx in indices):
                            return await ctx.send("⚠️ One or more indices are out of range.")
                        for idx in indices:
                            del current_responses[idx]
                        
                        if not current_responses:
                            return await ctx.send("⚠️ You can't remove all responses. Command edit cancelled.")
                        
                        cmd_data["responses"] = current_responses
                        self.custom_commands[guild_id][command_name] = cmd_data
                        self.save_commands()
                        
                        await ctx.send(f"✅ Removed {len(indices)} responses. Command `{self.bot.command_prefix}{command_name}` now has {len(current_responses)} responses.")
                        
                    except ValueError:
                        await ctx.send("⚠️ Invalid format. Please use comma-separated numbers.")
                    
                elif str(reaction.emoji) == "3️⃣":  
                    await ctx.send(f"Current name: `{command_name}`\nEnter the new command name:")
                    
                    name_msg = await self.bot.wait_for('message', check=message_check, timeout=60)
                    
                    if name_msg.content.lower() == 'cancel':
                        return await ctx.send("Command edit cancelled.")
                    
                    new_name = name_msg.content.lower()
                    
                    if new_name in self.bot.all_commands:
                        return await ctx.send(f"⚠️ `{new_name}` is already a built-in command. Please choose a different name.")
                    
                    if new_name in self.custom_commands[guild_id]:
                        return await ctx.send(f"⚠️ `{new_name}` already exists as a custom command.")
                    self.custom_commands[guild_id][new_name] = cmd_data
                    del self.custom_commands[guild_id][command_name]
                    self.save_commands()
                    
                    await ctx.send(f"✅ Command renamed from `{self.bot.command_prefix}{command_name}` to `{self.bot.command_prefix}{new_name}`!")
            
        except asyncio.TimeoutError:
            await ctx.send("⏱️ Command edit timed out.")
    
    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        if message.guild:  
            return           
        guild_id = str(message.guild.id)
        
        if guild_id not in self.custom_commands:
            return
        prefix = self.bot.command_prefix
        if not message.content.startswith(prefix):
            return
        cmd_name = message.content[len(prefix):].split()[0].lower()
        
        if cmd_name in self.custom_commands[guild_id]:
            self.custom_commands[guild_id][cmd_name]["uses"] += 1
            self.save_commands()
            
            cmd_data = self.custom_commands[guild_id][cmd_name]
            if cmd_data["type"] == "text":
                await message.channel.send(cmd_data["response"])
                
            elif cmd_data["type"] == "embed":
                if cmd_data["color"] == "random":
                    color = discord.Color.random()
                else:
                    try:
                        color = discord.Color(cmd_data["color"])
                    except:
                        color = discord.Color.blue()
                
                embed = discord.Embed(
                    title=cmd_data["title"],
                    description=cmd_data["description"],
                    color=color
                )
                embed.set_footer(text=f"Custom Command | {message.guild.name}")
                
                await message.channel.send(embed=embed)
                
            elif cmd_data["type"] == "random":
                response = random.choice(cmd_data["responses"])
                await message.channel.send(response)

class BirthdayModal(discord.ui.Modal):
    def __init__(self, title="Enter Your Birthday"):
        super().__init__(title=title)
        
        self.month = TextInput(
            label="Month (1-12)",
            placeholder="Enter month number (1-12)",
            required=True,
            min_length=1,
            max_length=2
        )
        self.add_item(self.month)
        
        self.day = TextInput(
            label="Day (1-31)",
            placeholder="Enter day number (1-31)",
            required=True,
            min_length=1,
            max_length=2
        )
        self.add_item(self.day)
        
        self.year = TextInput(
            label="Year (Optional)",
            placeholder="Enter year (e.g., 1995)",
            required=False,
            min_length=4,
            max_length=4
        )
        self.add_item(self.year)

    REASSURANCE_MESSAGE = "Note: If you see any error messages, don't worry - the changes have still been applied successfully!"

    async def on_submit(self, interaction: discord.Interaction):
        try:
            month = int(self.month.value)
            day = int(self.day.value)
            year = int(self.year.value) if self.year.value else None
            
            if month < 1 or month > 12 or day < 1 or day > 31:
                await interaction.response.send_message("Invalid date values.", ephemeral=True)
                return None, None, None
                
            return month, day, year
        except ValueError:
            await interaction.response.send_message("Please enter valid date values.", ephemeral=True)
            return None, None, None

class AdminBirthdayModal(discord.ui.Modal):
    def __init__(self, title="Add Member Birthday"):
        super().__init__(title=title)
        
        self.user_id = TextInput(
            label="User ID",
            placeholder="Enter the user's ID",
            required=True
        )
        self.add_item(self.user_id)
        
        self.month = TextInput(
            label="Month (1-12)",
            placeholder="Enter month number (1-12)",
            required=True,
            min_length=1,
            max_length=2
        )
        self.add_item(self.month)
        
        self.day = TextInput(
            label="Day (1-31)",
            placeholder="Enter day number (1-31)",
            required=True,
            min_length=1,
            max_length=2
        )
        self.add_item(self.day)
        
        self.year = TextInput(
            label="Year (Optional)",
            placeholder="Enter year (e.g., 1995)",
            required=False,
            min_length=4,
            max_length=4
        )
        self.add_item(self.year)
    REASSURANCE_MESSAGE = "Note: If you see any error messages, don't worry - the changes have still been applied successfully!"

class EmbedCustomizationModal(discord.ui.Modal):
    def __init__(self, title="Customize Birthday Embed"):
        super().__init__(title=title)
        
        self.embed_title = TextInput(
            label="Embed Title",
            placeholder="Enter a title for the embed",
            default="🎂 Birthday Registration",
            required=True
        )
        self.add_item(self.embed_title)
        
        self.embed_description = TextInput(
            label="Embed Description",
            placeholder="Enter a description for the embed",
            default="Click the button below to register your birthday!",
            required=True,
            style=discord.TextStyle.paragraph
        )
        self.add_item(self.embed_description)
        
        self.embed_footer = TextInput(
            label="Embed Footer",
            placeholder="Enter footer text (optional)",
            default="Your birthday will be celebrated on the server!",
            required=False
        )
        self.add_item(self.embed_footer)
        
        self.button_text = TextInput(
            label="Button Text",
            placeholder="Text to display on the button",
            default="Register Birthday",
            required=True
        )
        self.add_item(self.button_text)
        
        self.embed_color = TextInput(
            label="Embed Color (Hex)",
            placeholder="Enter a hex color code (e.g., #FF5733)",
            default="#FF5733",
            required=False
        )
        self.add_item(self.embed_color)
    REASSURANCE_MESSAGE = "Note: If you see any error messages, don't worry - the changes have still been applied successfully!"

class BirthdayView(discord.ui.View):
    def __init__(self, birthday_system, button_text="Register Birthday", button_style=ButtonStyle.primary, emoji="🎂"):
        super().__init__(timeout=None)
        self.birthday_system = birthday_system
        
        self.add_item(Button(
            style=button_style,
            label=button_text,
            emoji=emoji,
            custom_id="birthday_register_button"
        ))
    
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.data["custom_id"] == "birthday_register_button":
            await self.birthday_system.handle_birthday_button(interaction)
        return True


class BirthdayReminder(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.birthdays_file = "data/birthdays.json"
        self.config_file = "data/birthday_config.json"
        self.birthdays = {}  
        self.configs = {}    
        
        os.makedirs("data", exist_ok=True)
        
        self.load_data()
    
    def load_data(self):
        
        try:
            if os.path.exists(self.birthdays_file):
                with open(self.birthdays_file, 'r') as f:
                    self.birthdays = json.load(f)
            
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    self.configs = json.load(f)
        except Exception as e:
            print(f"Error loading birthday data: {e}")
    
    def save_data(self):
        
        try:
            with open(self.birthdays_file, 'w') as f:
                json.dump(self.birthdays, f, indent=4)
            
            with open(self.config_file, 'w') as f:
                json.dump(self.configs, f, indent=4)
        except Exception as e:
            print(f"Error saving birthday data: {e}")
    
    def get_guild_birthdays(self, guild_id: str) -> Dict:
        
        return self.birthdays.get(str(guild_id), {})
    
    def get_guild_config(self, guild_id: str) -> Dict:
        
        if str(guild_id) not in self.configs:
           
            self.configs[str(guild_id)] = {
                "announcement_channel": None,
                "role_id": None,
                "embed_settings": {
                    "title": "🎂 Birthday Registration",
                    "description": "Click the button below to register your birthday!",
                    "footer": "Your birthday will be celebrated on the server!",
                    "color": "#FF5733",
                    "button_text": "Register Birthday",
                    "button_style": "primary",
                    "button_emoji": "🎂"
                },
                "announcement_message": "Happy Birthday to {user_mention}! 🎂🎉",
                "enabled": True
            }
            self.save_data()
        
        return self.configs[str(guild_id)]
    
    async def add_birthday(self, guild_id: str, user_id: str, month: int, day: int, year: Optional[int] = None):
        
        if str(guild_id) not in self.birthdays:
            self.birthdays[str(guild_id)] = {}
        
        self.birthdays[str(guild_id)][str(user_id)] = {
            "month": month,
            "day": day
        }
        
        if year:
            self.birthdays[str(guild_id)][str(user_id)]["year"] = year
        
        self.save_data()
    
    async def remove_birthday(self, guild_id: str, user_id: str):
        
        if str(guild_id) in self.birthdays and str(user_id) in self.birthdays[str(guild_id)]:
            del self.birthdays[str(guild_id)][str(user_id)]
            self.save_data()
            return True
        return False
    
    async def update_config(self, guild_id: str, config_key: str, value):
        
        guild_config = self.get_guild_config(str(guild_id))
        
        if "." in config_key:
            main_key, sub_key = config_key.split(".", 1)
            if main_key in guild_config:
                guild_config[main_key][sub_key] = value
        else:
            guild_config[config_key] = value
        
        self.save_data()
    
    async def handle_birthday_button(self, interaction: discord.Interaction):
        
        modal = BirthdayModal()
        await interaction.response.send_modal(modal)
        
        try:
            await modal.wait()
            
            month, day, year = await modal.on_submit(interaction)
            if month and day:
                await self.add_birthday(str(interaction.guild_id), str(interaction.user.id), month, day, year)
                await interaction.followup.send("Your birthday has been registered! 🎉", ephemeral=True)
        except Exception as e:
            print(f"Error in birthday modal: {e}")
    
    async def create_birthday_embed(self, guild_id: str):
        
        config = self.get_guild_config(str(guild_id))
        embed_settings = config["embed_settings"]
        
        color_hex = embed_settings.get("color", "#FF5733").lstrip('#')
        color_int = int(color_hex, 16)
        
        embed = discord.Embed(
            title=embed_settings.get("title", "🎂 Birthday Registration"),
            description=embed_settings.get("description", "Click the button below to register your birthday!"),
            color=color_int
        )
        
        if embed_settings.get("footer"):
            embed.set_footer(text=embed_settings.get("footer"))
        
        button_style_map = {
            "primary": ButtonStyle.primary,
            "secondary": ButtonStyle.secondary,
            "success": ButtonStyle.success,
            "danger": ButtonStyle.danger
        }
        
        button_style = button_style_map.get(
            embed_settings.get("button_style", "primary").lower(), 
            ButtonStyle.primary
        )
        
        view = BirthdayView(
            self,
            button_text=embed_settings.get("button_text", "Register Birthday"),
            button_style=button_style,
            emoji=embed_settings.get("button_emoji", "🎂")
        )
        
        return embed, view
    
    async def admin_add_birthday(self, interaction: discord.Interaction):
        modal = AdminBirthdayModal()
        await interaction.response.send_modal(modal)
        
        await modal.wait()
        
        try:
            user_id = modal.user_id.value
            month = int(modal.month.value)
            day = int(modal.day.value)
            year = int(modal.year.value) if modal.year.value else None
            
            user = interaction.guild.get_member(int(user_id))
            if not user:
                await interaction.followup.send("User not found in this server.", ephemeral=True)
                return
            
            if month < 1 or month > 12 or day < 1 or day > 31:
                await interaction.followup.send("Invalid date values.", ephemeral=True)
                return
            
            await self.add_birthday(str(interaction.guild_id), user_id, month, day, year)
            await interaction.followup.send(f"Birthday for {user.display_name} has been added!", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Error adding birthday: {e}", ephemeral=True)
    
    async def customize_embed(self, interaction: discord.Interaction):
        config = self.get_guild_config(str(interaction.guild_id))
        embed_settings = config["embed_settings"]
        
        modal = EmbedCustomizationModal()
       
        modal.embed_title.default = embed_settings.get("title", "🎂 Birthday Registration")
        modal.embed_description.default = embed_settings.get("description", "Click the button below to register your birthday!")
        modal.embed_footer.default = embed_settings.get("footer", "Your birthday will be celebrated on the server!")
        modal.button_text.default = embed_settings.get("button_text", "Register Birthday")
        modal.embed_color.default = embed_settings.get("color", "#FF5733")
        
        await interaction.response.send_modal(modal)
        
        await modal.wait()
        
        try:
            
            embed_settings["title"] = modal.embed_title.value
            embed_settings["description"] = modal.embed_description.value
            embed_settings["footer"] = modal.embed_footer.value
            embed_settings["button_text"] = modal.button_text.value
            embed_settings["color"] = modal.embed_color.value
            
            await self.update_config(str(interaction.guild_id), "embed_settings", embed_settings)
            
            embed, view = await self.create_birthday_embed(str(interaction.guild_id))
            await interaction.followup.send("Here's a preview of your customized birthday embed:", embed=embed, view=view, ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Error customizing embed: {e}", ephemeral=True)
    
    async def setup_birthday_channel(self, interaction: discord.Interaction, channel_id: str):
        
        try:
            channel = interaction.guild.get_channel(int(channel_id))
            if not channel:
                await interaction.response.send_message("Channel not found.", ephemeral=True)
                return
            
            await self.update_config(str(interaction.guild_id), "announcement_channel", channel_id)
            
            try:
                await interaction.response.send_message(f"Birthday announcements will now be sent to {channel.mention}!", ephemeral=True)
            except discord.errors.InteractionResponded:
                
                await interaction.followup.send(f"Birthday announcements will now be sent to {channel.mention}!", ephemeral=True)
        except Exception as e:
            try:
                await interaction.response.send_message(f"Error setting birthday channel: {e}", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Error setting birthday channel: {e}", ephemeral=True)

    async def post_birthday_embed(self, interaction: discord.Interaction, channel_id: str):
        
        try:
            channel = interaction.guild.get_channel(int(channel_id))
            if not channel:
                await interaction.response.send_message("Channel not found.", ephemeral=True)
                return
            
            embed, view = await self.create_birthday_embed(str(interaction.guild_id))
            await channel.send(embed=embed, view=view)
            
            try:
                await interaction.response.send_message(f"Birthday registration embed posted to {channel.mention}!", ephemeral=True)
            except discord.errors.InteractionResponded:
                
                await interaction.followup.send(f"Birthday registration embed posted to {channel.mention}!", ephemeral=True)
        except Exception as e:
            try:
                await interaction.response.send_message(f"Error posting embed: {e}", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Error posting embed: {e}", ephemeral=True)

    
    @tasks.loop(hours=24)
    async def check_birthdays(self):
        today = datetime.now()
        current_month = today.month
        current_day = today.day
        
        for guild_id, guild_birthdays in self.birthdays.items():
            config = self.get_guild_config(guild_id)
            
            if not config["enabled"] or not config["announcement_channel"]:
                continue
            
            try:
                guild = self.bot.get_guild(int(guild_id))
                if not guild:
                    continue
                
                channel = guild.get_channel(int(config["announcement_channel"]))
                if not channel:
                    continue
                
                for user_id, birthday_data in guild_birthdays.items():
                    if birthday_data["month"] == current_month and birthday_data["day"] == current_day:
                       
                        user = guild.get_member(int(user_id))
                        if user:
                            message = config["announcement_message"].replace("{user_mention}", user.mention)
                            await channel.send(message)
                            
                            if config["role_id"]:
                                try:
                                    role = guild.get_role(int(config["role_id"]))
                                    if role:
                                        await user.add_roles(role)
                                except Exception as e:
                                    print(f"Error assigning birthday role: {e}")
            except Exception as e:
                print(f"Error checking birthdays for guild {guild_id}: {e}")
    
    @commands.command(name="birthday_help")
    async def birthday_help(self, ctx):
        embed = discord.Embed(
            title="🎂 Birthday Reminder System - Command Guide",
            description="Complete list of commands for the Birthday Reminder system\n If it says 'Something went wrong' it Still works. (Discords UI)",
            
            color=0xFF5733
        )
        
        embed.add_field(
            name="__User Commands__",
            value="Commands available to all server members",
            inline=False
        )
        
        embed.add_field(
            name="!birthday_set",
            value="Opens an interactive form to set your birthday\n"
                "**Usage:** `!birthday_set`",
            inline=True
        )
        
        embed.add_field(
            name="!view_birthday",
            value="View your currently registered birthday\n"
                "**Usage:** `!view_birthday`",
            inline=True
        )
        
        embed.add_field(
            name="!remove_birthday",
            value="Remove your birthday from the system\n"
                "**Usage:** `!remove_birthday`",
            inline=True
        )
        
        embed.add_field(
            name="__Admin Commands__",
            value="Commands available to server administrators only",
            inline=False
        )
        
        embed.add_field(
            name="!birthday_setup",
            value="Opens the main configuration dashboard\n"
                "**Usage:** `!birthday_setup`",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_add",
            value="Manually add a birthday for a user\n"
                "**Usage:** `!birthday_add @user month day [year]`",
            inline=True
        )
        
        embed.add_field(
            name="!list_birthdays",
            value="List all birthdays registered in the server\n"
                "**Usage:** `!list_birthdays`",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_post",
            value="Post the birthday registration embed\n"
                "**Usage:** `!birthday_post #channel`",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_customize",
            value="Customize the registration embed appearance\n"
                "**Usage:** `!birthday_customize`",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_settings",
            value="View current birthday system settings\n"
                "**Usage:** `!birthday_settings`",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_channel",
            value="Set the announcement channel\n"
                "**Usage:** `!birthday_channel #channel`",
            inline=True
        )
        
        embed.add_field(
            name="!set_birthday_role",
            value="Set the role given on birthdays\n"
                "**Usage:** `!set_birthday_role role_id`",
            inline=True
        )
        
        embed.add_field(
            name="!set_announcement_message",
            value="Set the birthday announcement message\n"
                "**Usage:** `!set_announcement_message [text]`\n"
                "Use `{user_mention}` to mention the user",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_enable",
            value="Enable the birthday system\n"
                "**Usage:** `!birthday_enable`",
            inline=True
        )
        
        embed.add_field(
            name="!birthday_disable",
            value="Disable the birthday system\n"
                "**Usage:** `!birthday_disable`",
            inline=True
        )
        
        embed.add_field(
            name="!remove_user_birthday",
            value="Remove a user's birthday (admin only)\n"
                "**Usage:** `!remove_user_birthday user_id`",
            inline=True
        )
        
        embed.add_field(
            name="!toggle_birthday_system",
            value="Enable or disable the system\n"
                "**Usage:** `!toggle_birthday_system true/false`",
            inline=True
        )
        
        embed.add_field(
            name="__Configuration Tips__",
            value="• Set up a dedicated channel for birthday announcements\n"
                "• Create a special birthday role with unique permissions\n"
                "• Customize the registration embed to match your server theme\n"
                "• Encourage members to register their birthdays",
            inline=False
        )
        
        current_year = datetime.now().year
        
        try:
            if self.bot.user and self.bot.user.avatar and self.bot.user.avatar.url:
                avatar_url = self.bot.user.avatar.url
            else:
                
                avatar_url = "https://cdn.discordapp.com/embed/avatars/0.png"
        except:
            avatar_url = "https://cdn.discordapp.com/embed/avatars/0.png"
        
        embed.set_footer(
            text=f"ZygnalBot Birthday System © {current_year} | Made by TheZ",
            icon_url=avatar_url
        )
        
        embed.set_thumbnail(url=avatar_url)
        
        await ctx.send(embed=embed)

    @commands.command(name="list_birthdays")
    async def list_birthdays_cmd(self, ctx):
        guild_birthdays = self.get_guild_birthdays(str(ctx.guild.id))
        
        if not guild_birthdays:
            await ctx.send("No birthdays have been registered in this server yet.")
            return
        
        sorted_birthdays = []
        for user_id, birthday_data in guild_birthdays.items():
            try:
                member = ctx.guild.get_member(int(user_id))
                name = member.display_name if member else f"User ID: {user_id}"
                
                month = birthday_data["month"]
                day = birthday_data["day"]
                year = birthday_data.get("year", "N/A")
                
                sorted_birthdays.append({
                    "name": name,
                    "month": month,
                    "day": day,
                    "year": year,
                    "date_value": month * 100 + day  
                })
            except Exception as e:
                print(f"Error processing birthday for {user_id}: {e}")
        
        sorted_birthdays.sort(key=lambda x: x["date_value"])
        
        birthdays_per_page = 10
        pages = []
        
        for i in range(0, len(sorted_birthdays), birthdays_per_page):
            page_birthdays = sorted_birthdays[i:i+birthdays_per_page]
            
            embed = discord.Embed(
                title="🎂 Server Birthdays",
                description="Here are all the registered birthdays:",
                color=0xFF5733
            )
            
            for birthday in page_birthdays:
                month_name = datetime(2000, birthday["month"], 1).strftime("%B")
                embed.add_field(
                    name=birthday["name"],
                    value=f"{month_name} {birthday['day']}" + (f" ({birthday['year']})" if birthday["year"] != "N/A" else ""),
                    inline=False
                )
            
            embed.set_footer(text=f"Page {len(pages)+1}/{(len(sorted_birthdays)-1)//birthdays_per_page+1}")
            pages.append(embed)
        
        if pages:
            await ctx.send(embed=pages[0])
        else:
            await ctx.send("Error generating birthday list.")
    
    @commands.command(name="remove_user_birthday")
    @commands.has_permissions(administrator=True)
    async def remove_user_birthday_cmd(self, ctx, user_id: str):
        try:
            success = await self.remove_birthday(str(ctx.guild.id), user_id)
            
            if success:
                user = ctx.guild.get_member(int(user_id))
                name = user.display_name if user else f"User ID: {user_id}"
                await ctx.send(f"Birthday for {name} has been removed.")
            else:
                await ctx.send("No birthday found for this user.")
        except Exception as e:
            await ctx.send(f"Error removing birthday: {e}")
    
    @commands.command(name="set_birthday_role")
    @commands.has_permissions(administrator=True)
    async def set_birthday_role_cmd(self, ctx, role_id: str):
        try:
            role = ctx.guild.get_role(int(role_id))
            if not role:
                await ctx.send("Role not found.")
                return
            
            await self.update_config(str(ctx.guild.id), "role_id", role_id)
            await ctx.send(f"Birthday role has been set to {role.name}!")
        except Exception as e:
            await ctx.send(f"Error setting birthday role: {e}")
    
    async def set_birthday_role_interaction(self, interaction, role_id):
        try:
            role = interaction.guild.get_role(int(role_id))
            if not role:
                await interaction.response.send_message("Role not found.", ephemeral=True)
                return
            
            await self.update_config(str(interaction.guild_id), "role_id", role_id)
            
            try:
                await interaction.response.send_message(f"Birthday role has been set to {role.name}!", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Birthday role has been set to {role.name}!", ephemeral=True)
        except Exception as e:
            try:
                await interaction.response.send_message(f"Error setting birthday role: {e}", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Error setting birthday role: {e}", ephemeral=True)

    async def set_announcement_message_interaction(self, interaction, message):
        try:
            await self.update_config(str(interaction.guild_id), "announcement_message", message)
            
            try:
                await interaction.response.send_message("Birthday announcement message has been updated!", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send("Birthday announcement message has been updated!", ephemeral=True)
        except Exception as e:
            try:
                await interaction.response.send_message(f"Error setting announcement message: {e}", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Error setting announcement message: {e}", ephemeral=True)

    async def toggle_system_interaction(self, interaction, enabled):
        try:
            status = "enabled" if enabled else "disabled"
            await self.update_config(str(interaction.guild_id), "enabled", enabled)
            
            try:
                await interaction.response.send_message(f"Birthday system has been {status}!", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Birthday system has been {status}!", ephemeral=True)
        except Exception as e:
            try:
                await interaction.response.send_message(f"Error toggling birthday system: {e}", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Error toggling birthday system: {e}", ephemeral=True)

    async def show_settings_interaction(self, interaction):
        try:
            guild_id = str(interaction.guild_id)
            settings = self.get_guild_settings(guild_id)
            
            embed = discord.Embed(
                title="🎂 Birthday System Settings",
                color=discord.Color.purple()
            )
            
            channel = interaction.guild.get_channel(int(settings.get("announcement_channel", 0) or 0))
            role = interaction.guild.get_role(int(settings.get("role_id", 0) or 0))
            
            embed.add_field(name="System Enabled", value="✅ Yes" if settings.get("enabled") else "❌ No", inline=True)
            embed.add_field(name="Announcement Channel", value=channel.mention if channel else "Not set", inline=True)
            embed.add_field(name="Birthday Role", value=role.name if role else "Not set", inline=True)
            embed.add_field(name="Announcement Message", value=settings.get("announcement_message", "Happy Birthday to {user_mention}! 🎂🎉"), inline=False)
            
            try:
                await interaction.response.send_message(embed=embed, ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            try:
                await interaction.response.send_message(f"Error showing settings: {e}", ephemeral=True)
            except discord.errors.InteractionResponded:
                await interaction.followup.send(f"Error showing settings: {e}", ephemeral=True)

    @commands.command(name="set_announcement_message")
    @commands.has_permissions(administrator=True)
    async def set_announcement_message_cmd(self, ctx, *, message: str):
        try:
            if not message or len(message) > 1000:
                await ctx.send("Message must be between 1 and 1000 characters.")
                return
            
            await self.update_config(str(ctx.guild.id), "announcement_message", message)
            
            preview = message.replace("{user_mention}", ctx.author.mention)
            await ctx.send(f"Birthday announcement message set! Preview:\n\n{preview}")
        except Exception as e:
            await ctx.send(f"Error setting announcement message: {e}")
    
    @commands.command(name="toggle_birthday_system")
    @commands.has_permissions(administrator=True)
    async def toggle_system_cmd(self, ctx, enabled: bool):
        try:
            await self.update_config(str(ctx.guild.id), "enabled", enabled)
            status = "enabled" if enabled else "disabled"
            await ctx.send(f"Birthday system has been {status}!")
        except Exception as e:
            await ctx.send(f"Error toggling birthday system: {e}")
    
    @commands.command(name="birthday_settings")
    @commands.has_permissions(administrator=True)
    async def show_settings_cmd(self, ctx):
        config = self.get_guild_config(str(ctx.guild.id))
        
        embed = discord.Embed(
            title="🎂 Birthday System Settings",
            description="Current configuration for the birthday system:",
            color=0x3498db
        )
        
        status = "Enabled" if config["enabled"] else "Disabled"
        embed.add_field(name="System Status", value=status, inline=False)
        
        channel_id = config["announcement_channel"]
        channel_value = "Not set"
        if channel_id:
            channel = ctx.guild.get_channel(int(channel_id))
            channel_value = channel.mention if channel else f"Invalid Channel (ID: {channel_id})"
        embed.add_field(name="Announcement Channel", value=channel_value, inline=False)
        
        role_id = config["role_id"]
        role_value = "Not set"
        if role_id:
            role = ctx.guild.get_role(int(role_id))
            role_value = role.name if role else f"Invalid Role (ID: {role_id})"
        embed.add_field(name="Birthday Role", value=role_value, inline=False)
        
        message = config["announcement_message"]
        embed.add_field(name="Announcement Message", value=message, inline=False)
        
        embed_settings = config["embed_settings"]
        embed.add_field(
            name="Registration Embed",
            value=f"Title: {embed_settings['title']}\nButton: {embed_settings['button_text']}",
            inline=False
        )
        
        guild_birthdays = self.get_guild_birthdays(str(ctx.guild.id))
        embed.add_field(name="Registered Birthdays", value=str(len(guild_birthdays)), inline=False)
        
        await ctx.send(embed=embed)
    
    @commands.command(name="birthday")
    async def birthday_cmd(self, ctx):
        await self.birthday_help(ctx)
    
    @commands.command(name="birthday_set")
    async def birthday_set_cmd(self, ctx):
        view = discord.ui.View()
        view.add_item(discord.ui.Button(
            style=ButtonStyle.primary, 
            label="Set Birthday", 
            custom_id="set_birthday_button", 
            emoji="🎂"
        ))
        await ctx.send("Click the button below to set your birthday:", view=view)
    
    @commands.command(name="birthday_setup")
    @commands.has_permissions(administrator=True)
    async def birthday_setup_cmd(self, ctx):
        view = discord.ui.View(timeout=None)
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.primary,
            label="Set Announcement Channel",
            custom_id="birthday_set_channel",
            emoji="📢"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.primary,
            label="Set Birthday Role",
            custom_id="birthday_set_role",
            emoji="🏷️"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.primary,
            label="Customize Embed",
            custom_id="birthday_customize_embed",
            emoji="✏️"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.primary,
            label="Set Announcement Message",
            custom_id="birthday_set_message",
            emoji="💬"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.success,
            label="Enable System",
            custom_id="birthday_enable",
            emoji="✅"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.danger,
            label="Disable System",
            custom_id="birthday_disable",
            emoji="❌"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.secondary,
            label="View Settings",
            custom_id="birthday_view_settings",
            emoji="⚙️"
        ))
        
        view.add_item(discord.ui.Button(
            style=ButtonStyle.secondary,
            label="Post Registration Embed",
            custom_id="birthday_post_embed",
            emoji="📝"
        ))
        
        embed = discord.Embed(
            title="🎂 Birthday System Setup",
            description="Configure the birthday system using the buttons below:\n If it Says 'Something went wrong, Try again later' you can safely ignore it it still got applied succesfully!",
            color=0x3498db
        )
        
        await ctx.send(embed=embed, view=view)
    
    @commands.Cog.listener()
    async def on_interaction(self, interaction: discord.Interaction):
        if not interaction.data or "custom_id" not in interaction.data:
            return
        
        custom_id = interaction.data["custom_id"]
        
        if custom_id == "set_birthday_button":
            await self.handle_birthday_button(interaction)
        
        elif custom_id == "birthday_set_channel":
            
            modal = discord.ui.Modal(title="Set Announcement Channel")
            modal.add_item(discord.ui.TextInput(
                label="Channel ID",
                placeholder="Enter the channel ID for birthday announcements",
                required=True
            ))
            await interaction.response.send_modal(modal)
            
            await modal.wait()
            channel_id = modal.children[0].value
            await self.setup_birthday_channel(interaction, channel_id)
        
        elif custom_id == "birthday_set_role":
            
            modal = discord.ui.Modal(title="Set Birthday Role")
            modal.add_item(discord.ui.TextInput(
                label="Role ID",
                placeholder="Enter the role ID to assign on birthdays",
                required=True
            ))
            await interaction.response.send_modal(modal)
            
            await modal.wait()
            role_id = modal.children[0].value
            
            try:
                role = interaction.guild.get_role(int(role_id))
                if not role:
                    await interaction.response.send_message("Role not found.", ephemeral=True)
                    return
                
                await self.update_config(str(interaction.guild_id), "role_id", role_id)
                
                try:
                    await interaction.response.send_message(f"Birthday role has been set to {role.name}!", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send(f"Birthday role has been set to {role.name}!", ephemeral=True)
            except Exception as e:
                try:
                    await interaction.response.send_message(f"Error setting birthday role: {e}", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send(f"Error setting birthday role: {e}", ephemeral=True)
        
        elif custom_id == "birthday_customize_embed":
            await self.customize_embed(interaction)
        
        elif custom_id == "birthday_set_message":
            
            modal = discord.ui.Modal(title="Set Announcement Message")
            modal.add_item(discord.ui.TextInput(
                label="Message",
                placeholder="Enter the birthday announcement message (use {user_mention} for the user)",
                required=True,
                style=discord.TextStyle.paragraph,
                default="Happy Birthday to {user_mention}! 🎂🎉"
            ))
            await interaction.response.send_modal(modal)
            
            await modal.wait()
            message = modal.children[0].value
            
            try:
                await self.update_config(str(interaction.guild_id), "announcement_message", message)
                
                try:
                    await interaction.response.send_message("Birthday announcement message has been updated!", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send("Birthday announcement message has been updated!", ephemeral=True)
            except Exception as e:
                try:
                    await interaction.response.send_message(f"Error setting announcement message: {e}", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send(f"Error setting announcement message: {e}", ephemeral=True)
        
        elif custom_id == "birthday_enable":
           
            try:
                await self.update_config(str(interaction.guild_id), "enabled", True)
                
                try:
                    await interaction.response.send_message("Birthday system has been enabled!", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send("Birthday system has been enabled!", ephemeral=True)
            except Exception as e:
                try:
                    await interaction.response.send_message(f"Error enabling birthday system: {e}", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send(f"Error enabling birthday system: {e}", ephemeral=True)
        
        elif custom_id == "birthday_disable":
            
            try:
                await self.update_config(str(interaction.guild_id), "enabled", False)
                
                try:
                    await interaction.response.send_message("Birthday system has been disabled!", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send("Birthday system has been disabled!", ephemeral=True)
            except Exception as e:
                try:
                    await interaction.response.send_message(f"Error disabling birthday system: {e}", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send(f"Error disabling birthday system: {e}", ephemeral=True)
        
        elif custom_id == "birthday_view_settings":
           
            try:
                guild_id = str(interaction.guild_id)
                
                try:
                    with open('data/birthday_config.json', 'r') as f:
                        birthday_config = json.load(f)
                        
                    guild_settings = birthday_config.get(guild_id, {})
                    
                    embed = discord.Embed(
                        title="🎂 Birthday System Settings",
                        color=discord.Color.purple()
                    )
                    
                    channel_id = guild_settings.get("announcement_channel", "0")
                    role_id = guild_settings.get("role_id", "0")
                    enabled = guild_settings.get("enabled", False)
                    announcement_message = guild_settings.get("announcement_message", 
                                                            "Happy Birthday to {user_mention}! 🎂🎉")
                    
                    embed_settings = guild_settings.get("embed_settings", {})
                    embed_title = embed_settings.get("title", "🎂 Birthday Registration")
                    embed_description = embed_settings.get("description", "Click the button below to register your birthday!")
                    
                    channel = interaction.guild.get_channel(int(channel_id)) if channel_id and channel_id != "0" else None
                    role = interaction.guild.get_role(int(role_id)) if role_id and role_id != "0" else None
                    
                    embed.add_field(name="System Enabled", value="✅ Yes" if enabled else "❌ No", inline=True)
                    embed.add_field(name="Announcement Channel", value=channel.mention if channel else "Not set", inline=True)
                    embed.add_field(name="Birthday Role", value=role.name if role else "Not set", inline=True)
                    embed.add_field(name="Announcement Message", value=announcement_message, inline=False)
                    
                    if embed_settings:
                        embed.add_field(name="Registration Embed", 
                                    value=f"**Title:** {embed_title}\n**Description:** {embed_description}", 
                                    inline=False)
                    
                    try:
                        with open('data/birthdays.json', 'r') as f:
                            birthdays = json.load(f)
                            
                        guild_birthdays = birthdays.get(guild_id, {})
                        birthday_count = len(guild_birthdays)
                        
                        embed.add_field(name="Registered Birthdays", value=str(birthday_count), inline=True)
                    except:
                        embed.add_field(name="Registered Birthdays", value="0", inline=True)
                    
                    try:
                        await interaction.response.send_message(embed=embed, ephemeral=True)
                    except discord.errors.InteractionResponded:
                        await interaction.followup.send(embed=embed, ephemeral=True)
                        
                except FileNotFoundError:
                    await interaction.response.send_message("Birthday configuration not found. Please set up the birthday system first.", ephemeral=True)
                    
            except Exception as e:
                try:
                    await interaction.response.send_message(f"Error showing settings: {e}", ephemeral=True)
                except discord.errors.InteractionResponded:
                    await interaction.followup.send(f"Error showing settings: {e}", ephemeral=True)

        
        elif custom_id == "birthday_post_embed":
            
            modal = discord.ui.Modal(title="Post Registration Embed")
            modal.add_item(discord.ui.TextInput(
                label="Channel ID",
                placeholder="Enter the channel ID to post the embed",
                required=True
            ))
            await interaction.response.send_modal(modal)
            
            await modal.wait()
            channel_id = modal.children[0].value
            await self.post_birthday_embed(interaction, channel_id)


    
    @commands.command(name="view_birthday")
    async def view_birthday_cmd(self, ctx):
        guild_birthdays = self.get_guild_birthdays(str(ctx.guild.id))
        user_id = str(ctx.author.id)
        
        if user_id not in guild_birthdays:
            await ctx.send("You haven't registered your birthday yet. Use `!birthday set` to register.")
            return
        
        birthday_data = guild_birthdays[user_id]
        month = birthday_data["month"]
        day = birthday_data["day"]
        year = birthday_data.get("year", "Not provided")
        
        month_name = datetime(2000, month, 1).strftime("%B")
        
        embed = discord.Embed(
            title="🎂 Your Birthday",
            description=f"Your registered birthday is:",
            color=0xFF5733
        )
        
        embed.add_field(
            name="Date",
            value=f"{month_name} {day}" + (f" ({year})" if year != "Not provided" else ""),
            inline=False
        )
        today = datetime.now()
        this_year_birthday = datetime(today.year, month, day)
        next_year_birthday = datetime(today.year + 1, month, day)
        
        if this_year_birthday < today:
            next_birthday = next_year_birthday
        else:
            next_birthday = this_year_birthday
        
        days_until = (next_birthday - today).days
        
        embed.add_field(
            name="Days Until Your Birthday",
            value=f"{days_until} days" if days_until > 0 else "Today is your birthday! 🎉",
            inline=False
        )
        
        await ctx.send(embed=embed)
    
    @commands.command(name="remove_birthday")
    async def remove_own_birthday_cmd(self, ctx):
        success = await self.remove_birthday(str(ctx.guild.id), str(ctx.author.id))
        
        if success:
            await ctx.send("Your birthday has been removed from the system.")
        else:
            await ctx.send("You don't have a birthday registered in the system.")
    
    @commands.command(name="birthday_post")
    @commands.has_permissions(administrator=True)
    async def post_birthday_embed_cmd(self, ctx, channel: discord.TextChannel):
        try:
            embed, view = await self.create_birthday_embed(str(ctx.guild.id))
            await channel.send(embed=embed, view=view)
            await ctx.send(f"Birthday registration embed posted to {channel.mention}!")
        except Exception as e:
            await ctx.send(f"Error posting embed: {e}")
    
    @commands.command(name="birthday_channel")
    @commands.has_permissions(administrator=True)
    async def set_birthday_channel_cmd(self, ctx, channel: discord.TextChannel):
        try:
            await self.update_config(str(ctx.guild.id), "announcement_channel", str(channel.id))
            await ctx.send(f"Birthday announcements will now be sent to {channel.mention}!")
        except Exception as e:
            await ctx.send(f"Error setting birthday channel: {e}")
    
    @commands.command(name="birthday_add")
    @commands.has_permissions(administrator=True)
    async def add_birthday_cmd(self, ctx, member: discord.Member, month: int, day: int, year: int = None):
        try:
            if month < 1 or month > 12 or day < 1 or day > 31:
                await ctx.send("Invalid date values.")
                return
            
            await self.add_birthday(str(ctx.guild.id), str(member.id), month, day, year)
            
            month_name = datetime(2000, month, 1).strftime("%B")
            year_str = f" ({year})" if year else ""
            
            await ctx.send(f"Birthday for {member.display_name} has been set to {month_name} {day}{year_str}!")
        except Exception as e:
            await ctx.send(f"Error adding birthday: {e}")
    
    @commands.command(name="birthday_enable")
    @commands.has_permissions(administrator=True)
    async def enable_birthday_system_cmd(self, ctx):
        await self.update_config(str(ctx.guild.id), "enabled", True)
        await ctx.send("Birthday system has been enabled!")
    
    @commands.command(name="birthday_disable")
    @commands.has_permissions(administrator=True)
    async def disable_birthday_system_cmd(self, ctx):
        await self.update_config(str(ctx.guild.id), "enabled", False)
        await ctx.send("Birthday system has been disabled!")
    
    @commands.command(name="birthday_customize")
    @commands.has_permissions(administrator=True)
    async def customize_birthday_embed_cmd(self, ctx):
        class DummyInteraction:
            def __init__(self, ctx):
                self.guild_id = ctx.guild.id
                self.guild = ctx.guild
                self.response = self
                self.followup = ctx
            
            async def send_modal(self, modal):
                await ctx.send("Please use the birthday_setup command instead for a better UI experience.")
                return False
            
            async def send_message(self, content, **kwargs):
                await ctx.send(content, **kwargs)
        
        await ctx.send("The customization UI is only available through the setup dashboard. Please use `!birthday_setup` instead.")
    
    def cog_unload(self):
        
        self.check_birthdays.cancel()
    
    async def cog_load(self):
       
        self.check_birthdays.start()

from typing import Dict, List, Optional, Union


class SocialMediaManager(commands.Cog):
    
    def __init__(self, bot):
        self.bot = bot
        self.config_path = "data/social_media_config.json"
        self.config = self.load_config()
        self.platform_colors = {
            "youtube": 0xFF0000,
            "twitch": 0x6441A4,
            "twitter": 0x1DA1F2,
            "reddit": 0xFF4500,
            "linkedin": 0x0077B5,
            "instagram": 0xE1306C,
            "tiktok": 0x000000,
            "facebook": 0x3b5998,
        }
        self.platform_icons = {
            "youtube": "https://i.imgur.com/3Vj3hYJ.png",
            "twitch": "https://i.imgur.com/OQI3ItU.png",
            "twitter": "https://i.imgur.com/FSoYKOl.png",
            "reddit": "https://i.imgur.com/rI9ZmPK.png",
            "linkedin": "https://i.imgur.com/RXLvVLr.png",
            "instagram": "https://i.imgur.com/Hp6Lajh.png",
            "tiktok": "https://i.imgur.com/KxbRB9H.png",
            "facebook": "https://i.imgur.com/jVz8U3X.png",
        }
        self.active_menus = {}
        self.check_updates.start()
        
    def load_config(self) -> dict:
       
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r') as f:
                    return json.load(f)
            else:
                return self.create_default_config()
        except Exception as e:
            logging.error(f"Error loading social media config: {e}")
            return self.create_default_config()
    
    def create_default_config(self) -> dict:
        
        default_config = {
            "guilds": {}
        }
        self.save_config(default_config)
        return default_config
    
    def save_config(self, config=None) -> None:
        
        if config is None:
            config = self.config
        try:
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(config, f, indent=4)
        except Exception as e:
            logging.error(f"Error saving social media config: {e}")
    
    def get_guild_config(self, guild_id: str) -> dict:
        
        guild_id = str(guild_id)
        if guild_id not in self.config["guilds"]:
            self.config["guilds"][guild_id] = {
                "platforms": {
                    "youtube": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["youtube"], "mention_role_id": None},
                    "twitch": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["twitch"], "mention_role_id": None},
                    "twitter": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["twitter"], "mention_role_id": None},
                    "reddit": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["reddit"], "mention_role_id": None},
                    "linkedin": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["linkedin"], "mention_role_id": None},
                    "instagram": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["instagram"], "mention_role_id": None},
                    "tiktok": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["tiktok"], "mention_role_id": None},
                    "facebook": {"enabled": False, "accounts": {}, "channel_id": None, "embed_color": self.platform_colors["facebook"], "mention_role_id": None},
                },
                "last_check": {},
                "settings": {
                    "update_frequency": 5,
                    "show_metrics": True,
                    "show_thumbnails": True,
                    "show_description": True,
                    "max_description_length": 200,
                    "filter_keywords": [],
                    "blacklisted_keywords": []
                }
            }
            self.save_config()
        return self.config["guilds"][guild_id]
    
    @commands.Cog.listener()
    async def on_ready(self):
       
        logging.info("Social Media Manager is ready!")
    
    @commands.command(name="socialmedia")
    @commands.has_permissions(administrator=True)
    async def social_media_command(self, ctx):

        embed = await self.create_main_dashboard(ctx.guild.id)
        
        view = self.create_platform_selection_view(ctx.guild.id)
        
        message = await ctx.send(embed=embed, view=view)
        
        self.active_menus[ctx.guild.id] = {
            "message_id": message.id,
            "channel_id": ctx.channel.id,
            "current_page": "main",
            "current_platform": None
        }
        
        try:
            await ctx.message.delete()
        except:
            pass
    
    async def create_main_dashboard(self, guild_id: int) -> discord.Embed:
     
        guild_config = self.get_guild_config(str(guild_id))
        
        embed = discord.Embed(
            title="📱 Social Media Integration Dashboard",
            description="Configure automatic posting of content from various social media platforms.\n"
                        "Click on a platform button below to configure its settings.",
            color=0x3498db
        )
        
        for platform, config in guild_config["platforms"].items():
            status = "✅ Enabled" if config["enabled"] else "❌ Disabled"
            accounts = len(config["accounts"])
            channel = f"<#{config['channel_id']}>" if config["channel_id"] else "Not set"
            
            embed.add_field(
                name=f"{platform.title()}",
                value=f"Status: {status}\nAccounts: {accounts}\nChannel: {channel}",
                inline=True
            )
        
        embed.set_footer(text="ZygnalBot Social Media Integration • Click a button below to configure")
        return embed
    
    def create_platform_selection_view(self, guild_id: int) -> View:
        
        view = View(timeout=300)
        
        for platform in self.platform_colors.keys():
            button = Button(
                label=platform.title(),
                style=discord.ButtonStyle.primary,
                custom_id=f"socialmedia:{platform}"
            )
            button.callback = self.platform_button_callback
            view.add_item(button)
        
        settings_button = Button(
            label="Global Settings",
            style=discord.ButtonStyle.secondary,
            custom_id="socialmedia:settings"
        )
        settings_button.callback = self.settings_button_callback
        view.add_item(settings_button)
        
        export_button = Button(
            label="Export Config",
            style=discord.ButtonStyle.success,
            custom_id="socialmedia:export"
        )
        export_button.callback = self.export_button_callback
        view.add_item(export_button)
        
        import_button = Button(
            label="Import Config",
            style=discord.ButtonStyle.danger,
            custom_id="socialmedia:import"
        )
        import_button.callback = self.import_button_callback
        view.add_item(import_button)
        
        return view
    
    async def platform_button_callback(self, interaction: discord.Interaction):

        platform = interaction.data["custom_id"].split(":")[1]
        guild_id = interaction.guild_id
        
        if guild_id in self.active_menus:
            self.active_menus[guild_id]["current_page"] = "platform"
            self.active_menus[guild_id]["current_platform"] = platform
        
        embed = await self.create_platform_config_embed(guild_id, platform)
        
        view = self.create_platform_config_view(guild_id, platform)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def settings_button_callback(self, interaction: discord.Interaction):
        
        guild_id = interaction.guild_id
        
        if guild_id in self.active_menus:
            self.active_menus[guild_id]["current_page"] = "settings"
        
        embed = await self.create_settings_embed(guild_id)
        
        view = self.create_settings_view(guild_id)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def export_button_callback(self, interaction: discord.Interaction):
        
        guild_id = str(interaction.guild_id)
        
        if guild_id in self.config["guilds"]:
            
            config_json = json.dumps(self.config["guilds"][guild_id], indent=4)
            
            file = discord.File(
                fp=io.StringIO(config_json),
                filename=f"socialmedia_config_{guild_id}.json"
            )
            
            await interaction.response.send_message(
                "Here's your social media configuration export:",
                file=file,
                ephemeral=True
            )
        else:
            await interaction.response.send_message(
                "No configuration found to export.",
                ephemeral=True
            )
    
    async def import_button_callback(self, interaction: discord.Interaction):
        
        await interaction.response.send_message(
            "Please upload your configuration JSON file with the command `!import_socialmedia`",
            ephemeral=True
        )
    
    async def create_platform_config_embed(self, guild_id: int, platform: str) -> discord.Embed:
        
        guild_config = self.get_guild_config(str(guild_id))
        platform_config = guild_config["platforms"][platform]
        
        embed = discord.Embed(
            title=f"{platform.title()} Configuration",
            description=f"Configure {platform.title()} integration settings.",
            color=self.platform_colors[platform]
        )
        
        status = "Enabled" if platform_config["enabled"] else "Disabled"
        embed.add_field(
            name="Status",
            value=f"{'✅' if platform_config['enabled'] else '❌'} {status}",
            inline=False
        )
        
        channel_text = f"<#{platform_config['channel_id']}>" if platform_config["channel_id"] else "Not set"
        embed.add_field(
            name="Destination Channel",
            value=channel_text,
            inline=True
        )
        
        role_text = f"<@&{platform_config['mention_role_id']}>" if platform_config["mention_role_id"] else "None"
        embed.add_field(
            name="Mention Role",
            value=role_text,
            inline=True
        )
        
        accounts_text = ""
        if platform_config["accounts"]:
            for account_id, account_info in platform_config["accounts"].items():
                accounts_text += f"• {account_info['name']} ({account_id})\n"
        else:
            accounts_text = "No accounts configured"
        
        embed.add_field(
            name="Configured Accounts",
            value=accounts_text,
            inline=False
        )
        
        if platform in self.platform_icons:
            embed.set_thumbnail(url=self.platform_icons[platform])
        
        embed.set_footer(text="Use the buttons below to modify configuration")
        return embed
    
    def create_platform_config_view(self, guild_id: int, platform: str) -> View:
        
        guild_config = self.get_guild_config(str(guild_id))
        platform_config = guild_config["platforms"][platform]
        
        view = View(timeout=300)
        
        toggle_label = "Disable" if platform_config["enabled"] else "Enable"
        toggle_style = discord.ButtonStyle.danger if platform_config["enabled"] else discord.ButtonStyle.success
        toggle_button = Button(
            label=toggle_label,
            style=toggle_style,
            custom_id=f"socialmedia:{platform}:toggle"
        )
        toggle_button.callback = self.toggle_platform_callback
        view.add_item(toggle_button)
        
        channel_button = Button(
            label="Set Channel",
            style=discord.ButtonStyle.primary,
            custom_id=f"socialmedia:{platform}:channel"
        )
        channel_button.callback = self.set_channel_callback
        view.add_item(channel_button)
        
        role_button = Button(
            label="Set Mention Role",
            style=discord.ButtonStyle.primary,
            custom_id=f"socialmedia:{platform}:role"
        )
        role_button.callback = self.set_role_callback
        view.add_item(role_button)

        add_account_button = Button(
            label="Add Account",
            style=discord.ButtonStyle.success,
            custom_id=f"socialmedia:{platform}:add_account"
        )
        add_account_button.callback = self.add_account_callback
        view.add_item(add_account_button)
        
        if platform_config["accounts"]:
            manage_accounts_button = Button(
                label="Manage Accounts",
                style=discord.ButtonStyle.secondary,
                custom_id=f"socialmedia:{platform}:manage_accounts"
            )
            manage_accounts_button.callback = self.manage_accounts_callback
            view.add_item(manage_accounts_button)
        
        preview_button = Button(
            label="Preview Post",
            style=discord.ButtonStyle.secondary,
            custom_id=f"socialmedia:{platform}:preview"
        )
        preview_button.callback = self.preview_callback
        view.add_item(preview_button)
        
        back_button = Button(
            label="Back to Dashboard",
            style=discord.ButtonStyle.danger,
            custom_id="socialmedia:back"
        )
        back_button.callback = self.back_button_callback
        view.add_item(back_button)
        
        return view
    
    async def toggle_platform_callback(self, interaction: discord.Interaction):
        
        custom_id = interaction.data["custom_id"]
        platform = custom_id.split(":")[1]
        guild_id = str(interaction.guild_id)
        
        current_status = self.config["guilds"][guild_id]["platforms"][platform]["enabled"]
        self.config["guilds"][guild_id]["platforms"][platform]["enabled"] = not current_status
        self.save_config()
        
        embed = await self.create_platform_config_embed(interaction.guild_id, platform)
        view = self.create_platform_config_view(interaction.guild_id, platform)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def set_channel_callback(self, interaction: discord.Interaction):
        
        custom_id = interaction.data["custom_id"]
        platform = custom_id.split(":")[1]
        
        await interaction.response.send_message(
            "Please mention the channel where you want to post updates. Example: #announcements",
            ephemeral=True
        )
        
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id and len(m.channel_mentions) > 0
        
        try:
            message = await self.bot.wait_for('message', check=check, timeout=60.0)
            
            channel = message.channel_mentions[0]
            
            guild_id = str(interaction.guild_id)
            self.config["guilds"][guild_id]["platforms"][platform]["channel_id"] = channel.id
            self.save_config()
            
            try:
                await message.delete()
            except:
                pass
            
            embed = await self.create_platform_config_embed(interaction.guild_id, platform)
            view = self.create_platform_config_view(interaction.guild_id, platform)
            
            menu_data = self.active_menus.get(interaction.guild_id, {})
            if menu_data:
                channel_id = menu_data.get("channel_id")
                message_id = menu_data.get("message_id")
                if channel_id and message_id:
                    channel = interaction.guild.get_channel(channel_id)
                    if channel:
                        try:
                            message = await channel.fetch_message(message_id)
                            await message.edit(embed=embed, view=view)
                        except:
                            pass
            
            await interaction.followup.send(
                f"✅ Successfully set {platform} updates to post in {channel.mention}",
                ephemeral=True
            )
            
        except asyncio.TimeoutError:
            await interaction.followup.send(
                "Channel selection timed out. Please try again.",
                ephemeral=True
            )
    
    async def set_role_callback(self, interaction: discord.Interaction):
        
        custom_id = interaction.data["custom_id"]
        platform = custom_id.split(":")[1]
        
        select = Select(
            placeholder="Select a role to mention",
            custom_id=f"socialmedia:{platform}:role_select",
            min_values=1,
            max_values=1
        )
        
        roles = interaction.guild.roles
        
        filtered_roles = [role for role in roles if role.name != "@everyone"]
        filtered_roles.sort(key=lambda r: r.position, reverse=True)
        
        select.add_option(label="None (No role mention)", value="0")
        
        for role in filtered_roles[:24]:
            select.add_option(label=role.name, value=str(role.id))
        
        view = View(timeout=60)
        view.add_item(select)
        
        async def role_select_callback(select_interaction):
            role_id = select_interaction.data["values"][0]
            
            guild_id = str(interaction.guild_id)
            if role_id == "0":
                self.config["guilds"][guild_id]["platforms"][platform]["mention_role_id"] = None
                role_name = "None"
            else:
                self.config["guilds"][guild_id]["platforms"][platform]["mention_role_id"] = int(role_id)
                role = interaction.guild.get_role(int(role_id))
                role_name = role.name if role else "Unknown"
            
            self.save_config()
            
            embed = await self.create_platform_config_embed(interaction.guild_id, platform)
            platform_view = self.create_platform_config_view(interaction.guild_id, platform)
            
            menu_data = self.active_menus.get(interaction.guild_id, {})
            if menu_data:
                channel_id = menu_data.get("channel_id")
                message_id = menu_data.get("message_id")
                if channel_id and message_id:
                    channel = interaction.guild.get_channel(channel_id)
                    if channel:
                        try:
                            message = await channel.fetch_message(message_id)
                            await message.edit(embed=embed, view=platform_view)
                        except:
                            pass
            
            await select_interaction.response.send_message(
                f"✅ Successfully set mention role to {role_name}",
                ephemeral=True
            )
        
        select.callback = role_select_callback
        
        await interaction.response.send_message(
            "Select a role to mention when posting updates:",
            view=view,
            ephemeral=True
        )
    
    async def add_account_callback(self, interaction: discord.Interaction):
        
        custom_id = interaction.data["custom_id"]
        platform = custom_id.split(":")[1]
        
        if platform == "youtube":
            await interaction.response.send_message(
                "Please enter the YouTube channel ID or URL to track:",
                ephemeral=True
            )
        elif platform == "twitch":
            await interaction.response.send_message(
                "Please enter the Twitch channel name to track:",
                ephemeral=True
            )
        elif platform == "twitter":
            await interaction.response.send_message(
                "Please enter the Twitter username (without @) to track:",
                ephemeral=True
            )
        elif platform == "reddit":
            await interaction.response.send_message(
                "Please enter the Reddit username or subreddit (with r/ prefix) to track:",
                ephemeral=True
            )
        else:
            await interaction.response.send_message(
                f"Please enter the {platform} account name/ID to track:",
                ephemeral=True
            )
        
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
        
        try:
            message = await self.bot.wait_for('message', check=check, timeout=60.0)
            account_input = message.content.strip()
            
            account_id, account_name = await self.process_account_input(platform, account_input)
            
            if account_id:
                
                guild_id = str(interaction.guild_id)
                self.config["guilds"][guild_id]["platforms"][platform]["accounts"][account_id] = {
                    "name": account_name,
                    "last_post_id": None,
                    "added_at": datetime.now().isoformat()
                }
                self.save_config()
                
                try:
                    await message.delete()
                except:
                    pass
                
                embed = await self.create_platform_config_embed(interaction.guild_id, platform)
                view = self.create_platform_config_view(interaction.guild_id, platform)
                
                menu_data = self.active_menus.get(interaction.guild_id, {})
                if menu_data:
                    channel_id = menu_data.get("channel_id")
                    message_id = menu_data.get("message_id")
                    if channel_id and message_id:
                        channel = interaction.guild.get_channel(channel_id)
                        if channel:
                            try:
                                message = await channel.fetch_message(message_id)
                                await message.edit(embed=embed, view=view)
                            except:
                                pass
                
                await interaction.followup.send(
                    f"✅ Successfully added {platform} account: {account_name}",
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    f"❌ Failed to process the {platform} account. Please check the input and try again.",
                    ephemeral=True
                )
                
        except asyncio.TimeoutError:
            await interaction.followup.send(
                "Account input timed out. Please try again.",
                ephemeral=True
            )
    
    async def process_account_input(self, platform: str, account_input: str) -> tuple:
        
        try:
            if platform == "youtube":
                
                if "youtube.com/channel/" in account_input:
                    channel_id = account_input.split("youtube.com/channel/")[1].split("/")[0]
                elif "youtube.com/c/" in account_input or "youtube.com/user/" in account_input:

                    channel_id = account_input
                else:
                    channel_id = account_input
                
                channel_name = f"YouTube Channel {channel_id}"
                return channel_id, channel_name
                
            elif platform == "twitch":
                
                channel_name = account_input.lower().strip()
                
                return channel_name, channel_name
                
            elif platform == "twitter":
                
                username = account_input.replace("@", "").lower().strip()
                return username, f"@{username}"
                
            elif platform == "reddit":
                
                if account_input.startswith("r/"):
                    
                    subreddit = account_input.strip()
                    return subreddit, subreddit
                elif account_input.startswith("u/"):
                    
                    username = account_input.strip()
                    return username, username
                else:
                    
                    username = f"u/{account_input.strip()}"
                    return username, username
            
            else:
                
                return account_input.strip(), account_input.strip()
                
        except Exception as e:
            logging.error(f"Error processing {platform} account input: {e}")
            return None, None
    
    async def manage_accounts_callback(self, interaction: discord.Interaction):
       
        custom_id = interaction.data["custom_id"]
        platform = custom_id.split(":")[1]
        guild_id = str(interaction.guild_id)
        
        platform_config = self.config["guilds"][guild_id]["platforms"][platform]
        
        if not platform_config["accounts"]:
            await interaction.response.send_message(
                f"No {platform} accounts configured yet. Add some first!",
                ephemeral=True
            )
            return
        
        select = Select(
            placeholder=f"Select {platform} account to remove",
            custom_id=f"socialmedia:{platform}:remove_account",
            min_values=1,
            max_values=1
        )
        
        for account_id, account_info in platform_config["accounts"].items():
            select.add_option(label=account_info["name"], value=account_id)
        
        view = View(timeout=60)
        view.add_item(select)
        
        async def account_select_callback(select_interaction):
            account_id = select_interaction.data["values"][0]
            account_name = platform_config["accounts"][account_id]["name"]
            
            del self.config["guilds"][guild_id]["platforms"][platform]["accounts"][account_id]
            self.save_config()
            
            embed = await self.create_platform_config_embed(interaction.guild_id, platform)
            platform_view = self.create_platform_config_view(interaction.guild_id, platform)
            
            menu_data = self.active_menus.get(interaction.guild_id, {})
            if menu_data:
                channel_id = menu_data.get("channel_id")
                message_id = menu_data.get("message_id")
                if channel_id and message_id:
                    channel = interaction.guild.get_channel(channel_id)
                    if channel:
                        try:
                            message = await channel.fetch_message(message_id)
                            await message.edit(embed=embed, view=platform_view)
                        except:
                            pass
            
            await select_interaction.response.send_message(
                f"✅ Successfully removed {platform} account: {account_name}",
                ephemeral=True
            )
        
        select.callback = account_select_callback
        
        await interaction.response.send_message(
            f"Select a {platform} account to remove:",
            view=view,
            ephemeral=True
        )
    
    async def preview_callback(self, interaction: discord.Interaction):
    
        custom_id = interaction.data["custom_id"]
        platform = custom_id.split(":")[1]
        
        embed = await self.create_sample_post_embed(interaction.guild_id, platform)
        
        await interaction.response.send_message(
            f"Here's a preview of how {platform} posts will look:",
            embed=embed,
            ephemeral=True
        )
    
    async def create_sample_post_embed(self, guild_id: int, platform: str) -> discord.Embed:
     
        guild_config = self.get_guild_config(str(guild_id))
        platform_config = guild_config["platforms"][platform]
        
        if platform == "youtube":
            title = "New YouTube Video!"
            description = "Just uploaded a new video! Check it out!"
            url = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
            thumbnail = "https://i.ytimg.com/vi/dQw4w9WgXcQ/maxresdefault.jpg"
            author_name = "Sample YouTube Channel"
            author_icon = self.platform_icons["youtube"]
            fields = [
                {"name": "Duration", "value": "3:32", "inline": True},
                {"name": "Views", "value": "1,234", "inline": True},
                {"name": "Likes", "value": "567", "inline": True}
            ]
            
        elif platform == "twitch":
            title = "Now Live on Twitch!"
            description = "Playing some awesome games! Come join the stream!"
            url = "https://www.twitch.tv/sample"
            thumbnail = "https://static-cdn.jtvnw.net/previews-ttv/live_user_sample-320x180.jpg"
            author_name = "SampleTwitchChannel"
            author_icon = self.platform_icons["twitch"]
            fields = [
                {"name": "Game", "value": "Just Chatting", "inline": True},
                {"name": "Viewers", "value": "1,234", "inline": True},
                {"name": "Started", "value": "1 hour ago", "inline": True}
            ]
            
        elif platform == "twitter":
            title = "New Tweet!"
            description = "This is a sample tweet with some #hashtags and @mentions. Check out this cool content I just shared!"
            url = "https://twitter.com/sample/status/123456789"
            thumbnail = None
            author_name = "@SampleTwitterUser"
            author_icon = self.platform_icons["twitter"]
            fields = [
                {"name": "Retweets", "value": "42", "inline": True},
                {"name": "Likes", "value": "123", "inline": True},
                {"name": "Posted", "value": "5 minutes ago", "inline": True}
            ]
            
        elif platform == "reddit":
            title = "New Reddit Post in r/sample"
            description = "This is a sample Reddit post with some interesting content. What do you think about this topic?"
            url = "https://www.reddit.com/r/sample/comments/123456/sample_post/"
            thumbnail = None
            author_name = "u/SampleRedditUser"
            author_icon = self.platform_icons["reddit"]
            fields = [
                {"name": "Upvotes", "value": "789", "inline": True},
                {"name": "Comments", "value": "56", "inline": True},
                {"name": "Posted", "value": "2 hours ago", "inline": True}
            ]
            
        else:
            
            title = f"New {platform.title()} Update!"
            description = f"This is a sample {platform.title()} post. Check out this new content!"
            url = f"https://www.{platform}.com/sample"
            thumbnail = None
            author_name = f"Sample{platform.title()}User"
            author_icon = self.platform_icons.get(platform, None)
            fields = [
                {"name": "Likes", "value": "123", "inline": True},
                {"name": "Comments", "value": "45", "inline": True},
                {"name": "Posted", "value": "Just now", "inline": True}
            ]
        
        embed = discord.Embed(
            title=title,
            description=description,
            url=url,
            color=platform_config["embed_color"]
        )
        
        embed.set_author(name=author_name, icon_url=author_icon)
        
        if thumbnail and guild_config["settings"]["show_thumbnails"]:
            embed.set_thumbnail(url=thumbnail)
        
        for field in fields:
            embed.add_field(name=field["name"], value=field["value"], inline=field["inline"])
        
        embed.set_footer(text=f"ZygnalBot {platform.title()} Integration • Sample Post")
        
        embed.timestamp = datetime.now()
        
        return embed
    
    async def back_button_callback(self, interaction: discord.Interaction):
        
        guild_id = interaction.guild_id
        
        if guild_id in self.active_menus:
            self.active_menus[guild_id]["current_page"] = "main"
            self.active_menus[guild_id]["current_platform"] = None
    
        embed = await self.create_main_dashboard(guild_id)
        
        view = self.create_platform_selection_view(guild_id)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def create_settings_embed(self, guild_id: int) -> discord.Embed:
        
        guild_config = self.get_guild_config(str(guild_id))
        settings = guild_config["settings"]
        
        embed = discord.Embed(
            title="⚙️ Social Media Global Settings",
            description="Configure global settings for all social media integrations.",
            color=0x7289da
        )
        
        embed.add_field(
            name="Update Frequency",
            value=f"{settings['update_frequency']} minutes",
            inline=True
        )
        
        embed.add_field(
            name="Show Metrics",
            value="✅ Enabled" if settings["show_metrics"] else "❌ Disabled",
            inline=True
        )
        
        embed.add_field(
            name="Show Thumbnails",
            value="✅ Enabled" if settings["show_thumbnails"] else "❌ Disabled",
            inline=True
        )
        
        embed.add_field(
            name="Show Description",
            value="✅ Enabled" if settings["show_description"] else "❌ Disabled",
            inline=True
        )
        
        embed.add_field(
            name="Max Description Length",
            value=f"{settings['max_description_length']} characters",
            inline=True
        )
        
        filter_keywords = ", ".join(settings["filter_keywords"]) if settings["filter_keywords"] else "None"
        embed.add_field(
            name="Filter Keywords",
            value=filter_keywords,
            inline=False
        )
        
        blacklisted = ", ".join(settings["blacklisted_keywords"]) if settings["blacklisted_keywords"] else "None"
        embed.add_field(
            name="Blacklisted Keywords",
            value=blacklisted,
            inline=False
        )
        
        embed.set_footer(text="Use the buttons below to modify settings")
        return embed
    
    def create_settings_view(self, guild_id: int) -> View:
    
        view = View(timeout=300)
        
        frequency_button = Button(
            label="Update Frequency",
            style=discord.ButtonStyle.primary,
            custom_id="socialmedia:settings:frequency"
        )
        frequency_button.callback = self.update_frequency_callback
        view.add_item(frequency_button)
        
        guild_config = self.get_guild_config(str(guild_id))
        settings = guild_config["settings"]
        
        metrics_label = "Disable Metrics" if settings["show_metrics"] else "Enable Metrics"
        metrics_button = Button(
            label=metrics_label,
            style=discord.ButtonStyle.secondary,
            custom_id="socialmedia:settings:metrics"
        )
        metrics_button.callback = self.toggle_metrics_callback
        view.add_item(metrics_button)
        
        thumbnails_label = "Disable Thumbnails" if settings["show_thumbnails"] else "Enable Thumbnails"
        thumbnails_button = Button(
            label=thumbnails_label,
            style=discord.ButtonStyle.secondary,
            custom_id="socialmedia:settings:thumbnails"
        )
        thumbnails_button.callback = self.toggle_thumbnails_callback
        view.add_item(thumbnails_button)
        
        description_label = "Disable Description" if settings["show_description"] else "Enable Description"
        description_button = Button(
            label=description_label,
            style=discord.ButtonStyle.secondary,
            custom_id="socialmedia:settings:description"
        )
        description_button.callback = self.toggle_description_callback
        view.add_item(description_button)
        
        length_button = Button(
            label="Description Length",
            style=discord.ButtonStyle.primary,
            custom_id="socialmedia:settings:length"
        )
        length_button.callback = self.set_description_length_callback
        view.add_item(length_button)
        
        keywords_button = Button(
            label="Manage Keywords",
            style=discord.ButtonStyle.primary,
            custom_id="socialmedia:settings:keywords"
        )
        keywords_button.callback = self.manage_keywords_callback
        view.add_item(keywords_button)
        
        back_button = Button(
            label="Back to Dashboard",
            style=discord.ButtonStyle.danger,
            custom_id="socialmedia:back"
        )
        back_button.callback = self.back_button_callback
        view.add_item(back_button)
        
        return view
    
    async def update_frequency_callback(self, interaction: discord.Interaction):
        
        await interaction.response.send_message(
            "Please enter the update frequency in minutes (1-60):",
            ephemeral=True
        )
        
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
        
        try:
            message = await self.bot.wait_for('message', check=check, timeout=60.0)
            try:
                frequency = int(message.content.strip())
                if 1 <= frequency <= 60:
                    
                    guild_id = str(interaction.guild_id)
                    self.config["guilds"][guild_id]["settings"]["update_frequency"] = frequency
                    self.save_config()
                    
                    try:
                        await message.delete()
                    except:
                        pass
                    
                    embed = await self.create_settings_embed(interaction.guild_id)
                    view = self.create_settings_view(interaction.guild_id)
                    
                    menu_data = self.active_menus.get(interaction.guild_id, {})
                    if menu_data:
                        channel_id = menu_data.get("channel_id")
                        message_id = menu_data.get("message_id")
                        if channel_id and message_id:
                            channel = interaction.guild.get_channel(channel_id)
                            if channel:
                                try:
                                    message = await channel.fetch_message(message_id)
                                    await message.edit(embed=embed, view=view)
                                except:
                                    pass
                    
                    await interaction.followup.send(
                        f"✅ Successfully set update frequency to {frequency} minutes",
                        ephemeral=True
                    )
                else:
                    await interaction.followup.send(
                        "❌ Frequency must be between 1 and 60 minutes. Please try again.",
                        ephemeral=True
                    )
            except ValueError:
                await interaction.followup.send(
                    "❌ Please enter a valid number. Try again.",
                    ephemeral=True
                )
                
        except asyncio.TimeoutError:
            await interaction.followup.send(
                "Frequency input timed out. Please try again.",
                ephemeral=True
            )
    
    async def toggle_metrics_callback(self, interaction: discord.Interaction):
        
        guild_id = str(interaction.guild_id)
        
        current_setting = self.config["guilds"][guild_id]["settings"]["show_metrics"]
        self.config["guilds"][guild_id]["settings"]["show_metrics"] = not current_setting
        self.save_config()
        
        embed = await self.create_settings_embed(interaction.guild_id)
        view = self.create_settings_view(interaction.guild_id)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def toggle_thumbnails_callback(self, interaction: discord.Interaction):
        
        guild_id = str(interaction.guild_id)
        
        current_setting = self.config["guilds"][guild_id]["settings"]["show_thumbnails"]
        self.config["guilds"][guild_id]["settings"]["show_thumbnails"] = not current_setting
        self.save_config()
        
        embed = await self.create_settings_embed(interaction.guild_id)
        view = self.create_settings_view(interaction.guild_id)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def toggle_description_callback(self, interaction: discord.Interaction):
        
        guild_id = str(interaction.guild_id)
        
        current_setting = self.config["guilds"][guild_id]["settings"]["show_description"]
        self.config["guilds"][guild_id]["settings"]["show_description"] = not current_setting
        self.save_config()
        
        embed = await self.create_settings_embed(interaction.guild_id)
        view = self.create_settings_view(interaction.guild_id)
        
        await interaction.response.edit_message(embed=embed, view=view)
    
    async def set_description_length_callback(self, interaction: discord.Interaction):
        
        await interaction.response.send_message(
            "Please enter the maximum description length (10-2000 characters):",
            ephemeral=True
        )
        
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
        
        try:
            message = await self.bot.wait_for('message', check=check, timeout=60.0)
            try:
                length = int(message.content.strip())
                if 10 <= length <= 2000:
                    
                    guild_id = str(interaction.guild_id)
                    self.config["guilds"][guild_id]["settings"]["max_description_length"] = length
                    self.save_config()
                    
                    try:
                        await message.delete()
                    except:
                        pass
                    
                    embed = await self.create_settings_embed(interaction.guild_id)
                    view = self.create_settings_view(interaction.guild_id)
                    
                    menu_data = self.active_menus.get(interaction.guild_id, {})
                    if menu_data:
                        channel_id = menu_data.get("channel_id")
                        message_id = menu_data.get("message_id")
                        if channel_id and message_id:
                            channel = interaction.guild.get_channel(channel_id)
                            if channel:
                                try:
                                    message = await channel.fetch_message(message_id)
                                    await message.edit(embed=embed, view=view)
                                except:
                                    pass
                    
                    await interaction.followup.send(
                        f"✅ Successfully set maximum description length to {length} characters",
                        ephemeral=True
                    )
                else:
                    await interaction.followup.send(
                        "❌ Length must be between 10 and 2000 characters. Please try again.",
                        ephemeral=True
                    )
            except ValueError:
                await interaction.followup.send(
                    "❌ Please enter a valid number. Try again.",
                    ephemeral=True
                )
                
        except asyncio.TimeoutError:
            await interaction.followup.send(
                "Length input timed out. Please try again.",
                ephemeral=True
            )
    
    async def manage_keywords_callback(self, interaction: discord.Interaction):
        
        view = View(timeout=60)
        
        add_filter_button = Button(
            label="Add Filter Keywords",
            style=discord.ButtonStyle.primary,
            custom_id="socialmedia:settings:add_filter"
        )
        add_filter_button.callback = self.add_filter_keywords_callback
        view.add_item(add_filter_button)
        
        remove_filter_button = Button(
            label="Remove Filter Keywords",
            style=discord.ButtonStyle.secondary,
            custom_id="socialmedia:settings:remove_filter"
        )
        remove_filter_button.callback = self.remove_filter_keywords_callback
        view.add_item(remove_filter_button)
        
        add_blacklist_button = Button(
            label="Add Blacklist Keywords",
            style=discord.ButtonStyle.primary,
            custom_id="socialmedia:settings:add_blacklist"
        )
        add_blacklist_button.callback = self.add_blacklist_keywords_callback
        view.add_item(add_blacklist_button)
        
        remove_blacklist_button = Button(
            label="Remove Blacklist Keywords",
            style=discord.ButtonStyle.secondary,
            custom_id="socialmedia:settings:remove_blacklist"
        )
        remove_blacklist_button.callback = self.remove_blacklist_keywords_callback
        view.add_item(remove_blacklist_button)
        
        await interaction.response.send_message(
            "Select an option to manage keywords:",
            view=view,
            ephemeral=True
        )
    
    async def add_filter_keywords_callback(self, interaction: discord.Interaction):
        
        await interaction.response.send_message(
            "Please enter filter keywords (comma-separated) to only post content containing these words:",
            ephemeral=True
        )
        
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
        
        try:
            message = await self.bot.wait_for('message', check=check, timeout=60.0)
            keywords = [keyword.strip() for keyword in message.content.split(",") if keyword.strip()]
            
            if keywords:
                
                guild_id = str(interaction.guild_id)
                current_keywords = self.config["guilds"][guild_id]["settings"]["filter_keywords"]
                
                for keyword in keywords:
                    if keyword not in current_keywords:
                        current_keywords.append(keyword)
                
                self.save_config()
                
                try:
                    await message.delete()
                except:
                    pass
                
                embed = await self.create_settings_embed(interaction.guild_id)
                view = self.create_settings_view(interaction.guild_id)
                
                menu_data = self.active_menus.get(interaction.guild_id, {})
                if menu_data:
                    channel_id = menu_data.get("channel_id")
                    message_id = menu_data.get("message_id")
                    if channel_id and message_id:
                        channel = interaction.guild.get_channel(channel_id)
                        if channel:
                            try:
                                message = await channel.fetch_message(message_id)
                                await message.edit(embed=embed, view=view)
                            except:
                                pass
                
                await interaction.followup.send(
                    f"✅ Successfully added {len(keywords)} filter keywords",
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    "❌ No valid keywords provided. Please try again.",
                    ephemeral=True
                )
                
        except asyncio.TimeoutError:
            await interaction.followup.send(
                "Keyword input timed out. Please try again.",
                ephemeral=True
            )
    
    async def remove_filter_keywords_callback(self, interaction: discord.Interaction):
        
        guild_id = str(interaction.guild_id)
        current_keywords = self.config["guilds"][guild_id]["settings"]["filter_keywords"]
        
        if not current_keywords:
            await interaction.response.send_message(
                "No filter keywords to remove.",
                ephemeral=True
            )
            return
    
        select = Select(
            placeholder="Select keywords to remove",
            custom_id="socialmedia:settings:remove_filter_select",
            min_values=1,
            max_values=min(len(current_keywords), 25)  
        )
        
        for keyword in current_keywords[:25]:  
            select.add_option(label=keyword, value=keyword)
        
        view = View(timeout=60)
        view.add_item(select)
        
        async def keyword_select_callback(select_interaction):
            selected_keywords = select_interaction.data["values"]
            
            for keyword in selected_keywords:
                if keyword in self.config["guilds"][guild_id]["settings"]["filter_keywords"]:
                    self.config["guilds"][guild_id]["settings"]["filter_keywords"].remove(keyword)
            
            self.save_config()
            
            embed = await self.create_settings_embed(interaction.guild_id)
            settings_view = self.create_settings_view(interaction.guild_id)
            
            menu_data = self.active_menus.get(interaction.guild_id, {})
            if menu_data:
                channel_id = menu_data.get("channel_id")
                message_id = menu_data.get("message_id")
                if channel_id and message_id:
                    channel = interaction.guild.get_channel(channel_id)
                    if channel:
                        try:
                            message = await channel.fetch_message(message_id)
                            await message.edit(embed=embed, view=settings_view)
                        except:
                            pass
            
            await select_interaction.response.send_message(
                f"✅ Successfully removed {len(selected_keywords)} filter keywords",
                ephemeral=True
            )
        
        select.callback = keyword_select_callback
        
        await interaction.response.send_message(
            "Select filter keywords to remove:",
            view=view,
            ephemeral=True
        )
    
    async def add_blacklist_keywords_callback(self, interaction: discord.Interaction):
        
        await interaction.response.send_message(
            "Please enter blacklist keywords (comma-separated) to exclude content containing these words:",
            ephemeral=True
        )
        
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
        
        try:
            message = await self.bot.wait_for('message', check=check, timeout=60.0)
            keywords = [keyword.strip() for keyword in message.content.split(",") if keyword.strip()]
            
            if keywords:
                
                guild_id = str(interaction.guild_id)
                current_keywords = self.config["guilds"][guild_id]["settings"]["blacklisted_keywords"]
                
                for keyword in keywords:
                    if keyword not in current_keywords:
                        current_keywords.append(keyword)
                
                self.save_config()
                
                try:
                    await message.delete()
                except:
                    pass
            
                embed = await self.create_settings_embed(interaction.guild_id)
                view = self.create_settings_view(interaction.guild_id)
                
                menu_data = self.active_menus.get(interaction.guild_id, {})
                if menu_data:
                    channel_id = menu_data.get("channel_id")
                    message_id = menu_data.get("message_id")
                    if channel_id and message_id:
                        channel = interaction.guild.get_channel(channel_id)
                        if channel:
                            try:
                                message = await channel.fetch_message(message_id)
                                await message.edit(embed=embed, view=view)
                            except:
                                pass
                
                await interaction.followup.send(
                    f"✅ Successfully added {len(keywords)} blacklist keywords",
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    "❌ No valid keywords provided. Please try again.",
                    ephemeral=True
                )
                
        except asyncio.TimeoutError:
            await interaction.followup.send(
                "Keyword input timed out. Please try again.",
                ephemeral=True
            )
    
    async def remove_blacklist_keywords_callback(self, interaction: discord.Interaction):
        
        guild_id = str(interaction.guild_id)
        current_keywords = self.config["guilds"][guild_id]["settings"]["blacklisted_keywords"]
        
        if not current_keywords:
            await interaction.response.send_message(
                "No blacklist keywords to remove.",
                ephemeral=True
            )
            return
        
        select = Select(
            placeholder="Select keywords to remove",
            custom_id="socialmedia:settings:remove_blacklist_select",
            min_values=1,
            max_values=min(len(current_keywords), 25)  
        )
        
        for keyword in current_keywords[:25]: 
            select.add_option(label=keyword, value=keyword)
        
        view = View(timeout=60)
        view.add_item(select)
        
        async def keyword_select_callback(select_interaction):
            selected_keywords = select_interaction.data["values"]
            
            for keyword in selected_keywords:
                if keyword in self.config["guilds"][guild_id]["settings"]["blacklisted_keywords"]:
                    self.config["guilds"][guild_id]["settings"]["blacklisted_keywords"].remove(keyword)
            
            self.save_config()
            
            embed = await self.create_settings_embed(interaction.guild_id)
            settings_view = self.create_settings_view(interaction.guild_id)
            
            menu_data = self.active_menus.get(interaction.guild_id, {})
            if menu_data:
                channel_id = menu_data.get("channel_id")
                message_id = menu_data.get("message_id")
                if channel_id and message_id:
                    channel = interaction.guild.get_channel(channel_id)
                    if channel:
                        try:
                            message = await channel.fetch_message(message_id)
                            await message.edit(embed=embed, view=settings_view)
                        except:
                            pass
            
            await select_interaction.response.send_message(
                f"✅ Successfully removed {len(selected_keywords)} blacklist keywords",
                ephemeral=True
            )
        
        select.callback = keyword_select_callback
        
        await interaction.response.send_message(
            "Select blacklist keywords to remove:",
            view=view,
            ephemeral=True
        )
    
    @tasks.loop(minutes=1)
    async def check_updates(self):
    
        try:
            
            for guild_id, guild_config in self.config["guilds"].items():
                
                guild = self.bot.get_guild(int(guild_id))
                if not guild:
                    continue
                
                for platform, platform_config in guild_config["platforms"].items():
                    
                    if not platform_config["enabled"]:
                        continue
                    
                    if not platform_config["channel_id"]:
                        continue
                    
                    channel = guild.get_channel(int(platform_config["channel_id"]))
                    if not channel:
                        continue
                    
                    update_frequency = guild_config["settings"]["update_frequency"]
                    last_check = guild_config.get("last_check", {}).get(platform, 0)
                    current_time = datetime.now().timestamp()
                    
                    if current_time - last_check < update_frequency * 60:
                        continue
                    
                    if "last_check" not in guild_config:
                        guild_config["last_check"] = {}
                    guild_config["last_check"][platform] = current_time
                    self.save_config()
                    
                    for account_id, account_info in platform_config["accounts"].items():
                        try:
                            
                            new_posts = await self.get_new_posts(platform, account_id, account_info)
                            
                            if new_posts:
                                
                                filtered_posts = self.filter_posts(new_posts, guild_config["settings"])
                                
                                for post in filtered_posts:
                                    embed = await self.create_post_embed(guild_id, platform, account_id, post)
                                    
                                    mention_text = ""
                                    if platform_config["mention_role_id"]:
                                        mention_text = f"<@&{platform_config['mention_role_id']}>"
                                    
                                    await channel.send(content=mention_text, embed=embed)
                                    
                                    if post.get("id"):
                                        self.config["guilds"][guild_id]["platforms"][platform]["accounts"][account_id]["last_post_id"] = post["id"]
                                        self.save_config()
                                    
                                    await asyncio.sleep(1)
                        except Exception as e:
                            logging.error(f"Error checking updates for {platform} account {account_id}: {e}")
                            continue
        except Exception as e:
            logging.error(f"Error in check_updates task: {e}")
    
    @check_updates.before_loop
    async def before_check_updates(self):
        
        await self.bot.wait_until_ready()
    
    async def get_new_posts(self, platform: str, account_id: str, account_info: dict) -> list:
        



        

        # In a real implementation, this would connect to the platform APIs
        
        # Example structure of a post:
        # {
        #     "id": "unique_post_id",
        #     "title": "Post title",
        #     "content": "Post content",
        #     "url": "https://platform.com/post/url",
        #     "thumbnail": "https://platform.com/thumbnail.jpg",
        #     "author": "Author name",
        #     "timestamp": datetime.now().timestamp(),
        #     "metrics": {
        #         "likes": 123,
        #         "comments": 45,
        #         "shares": 67
        #     }
        # }
        
        return []
    
    def filter_posts(self, posts: list, settings: dict) -> list:
        filtered_posts = []
        
        for post in posts:
        
            if not all(key in post for key in ["id", "title", "content", "url"]):
                continue
            
            if settings["filter_keywords"]:
                
                if not any(keyword.lower() in post["title"].lower() or keyword.lower() in post["content"].lower() 
                          for keyword in settings["filter_keywords"]):
                    continue
            
            if settings["blacklisted_keywords"]:
            
                if any(keyword.lower() in post["title"].lower() or keyword.lower() in post["content"].lower() 
                      for keyword in settings["blacklisted_keywords"]):
                    continue
            
            filtered_posts.append(post)
        
        return filtered_posts
    
    async def create_post_embed(self, guild_id: int, platform: str, account_id: str, post: dict) -> discord.Embed:
      
        guild_config = self.get_guild_config(str(guild_id))
        platform_config = guild_config["platforms"][platform]
        settings = guild_config["settings"]
        
        embed = discord.Embed(
            title=post["title"],
            url=post["url"],
            color=platform_config["embed_color"]
        )
        
        if settings["show_description"] and "content" in post:
            
            max_length = settings["max_description_length"]
            content = post["content"]
            if len(content) > max_length:
                content = content[:max_length] + "..."
            embed.description = content
        
        author_name = post.get("author", platform_config["accounts"][account_id]["name"])
        author_icon = self.platform_icons.get(platform)
        embed.set_author(name=author_name, icon_url=author_icon)
        
        if settings["show_thumbnails"] and "thumbnail" in post:
            embed.set_thumbnail(url=post["thumbnail"])
        
        if settings["show_metrics"] and "metrics" in post:
            metrics = post["metrics"]
            for key, value in metrics.items():
                embed.add_field(name=key.title(), value=str(value), inline=True)
        
        if "timestamp" in post:
            embed.timestamp = datetime.fromtimestamp(post["timestamp"])
        else:
            embed.timestamp = datetime.now()
        
        embed.set_footer(text=f"ZygnalBot {platform.title()} Integration")
        
        return embed
    
    @commands.command(name="import_socialmedia")
    @commands.has_permissions(administrator=True)
    async def import_socialmedia(self, ctx):
       
        if not ctx.message.attachments:
            await ctx.send("Please attach a JSON configuration file.")
            return
        
        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.json'):
            await ctx.send("Please attach a valid JSON file.")
            return
        
        try:
            
            content = await attachment.read()
            config_data = json.loads(content.decode('utf-8'))
            
            guild_id = str(ctx.guild.id)
            self.config["guilds"][guild_id] = config_data
            self.save_config()
            
            await ctx.send("✅ Social media configuration imported successfully!")
        except Exception as e:
            await ctx.send(f"❌ Error importing configuration: {str(e)}")
    
    @commands.command(name="export_socialmedia")
    @commands.has_permissions(administrator=True)
    async def export_socialmedia(self, ctx):
       
        guild_id = str(ctx.guild.id)
        
        if guild_id in self.config["guilds"]:
            
            config_json = json.dumps(self.config["guilds"][guild_id], indent=4)
            
            file = discord.File(
                fp=io.StringIO(config_json),
                filename=f"socialmedia_config_{guild_id}.json"
            )
            
            await ctx.send("Here's your social media configuration export:", file=file)
        else:
            await ctx.send("No configuration found to export.")

class PrizeModal(discord.ui.Modal):
    def __init__(self, settings):
        super().__init__(title="Set Prize")
        self.settings = settings
        self.prize_input = discord.ui.TextInput(label="Enter the prize", style=discord.TextStyle.short)
        self.add_item(self.prize_input)

    async def on_submit(self, interaction: discord.Interaction):
        self.settings["prize"] = self.prize_input.value
        await interaction.response.send_message(f"Prize set to: {self.prize_input.value}", ephemeral=True)

class DurationModal(discord.ui.Modal):
    def __init__(self, settings):
        super().__init__(title="Set Duration")
        self.settings = settings
        self.duration_input = discord.ui.TextInput(label="Enter duration in hours", style=discord.TextStyle.short)
        self.add_item(self.duration_input)

    async def on_submit(self, interaction: discord.Interaction):
        self.settings["duration"] = int(self.duration_input.value)
        await interaction.response.send_message(f"Duration set to: {self.duration_input.value} hours", ephemeral=True)

class WinnersModal(discord.ui.Modal):
    def __init__(self, settings):
        super().__init__(title="Set Winners")
        self.settings = settings
        self.winners_input = discord.ui.TextInput(label="Enter number of winners", style=discord.TextStyle.short)
        self.add_item(self.winners_input)

    async def on_submit(self, interaction: discord.Interaction):
        self.settings["winners"] = int(self.winners_input.value)
        await interaction.response.send_message(f"Winners set to: {self.winners_input.value}", ephemeral=True)

class RequirementsModal(discord.ui.Modal):
    def __init__(self, settings):
        super().__init__(title="Set Requirements")
        self.settings = settings
        self.req_input = discord.ui.TextInput(label="Enter requirements", style=discord.TextStyle.paragraph)
        self.add_item(self.req_input)

    async def on_submit(self, interaction: discord.Interaction):
        self.settings["requirements"] = self.req_input.value
        await interaction.response.send_message("Requirements set!", ephemeral=True)

class NoteModal(discord.ui.Modal):
    def __init__(self, settings):
        super().__init__(title="Add Note")
        self.settings = settings
        self.note_input = discord.ui.TextInput(
            label="Additional Information",
            style=discord.TextStyle.paragraph,
            placeholder="e.g., Winners please DM me to claim your prize",
            required=False
        )
        self.add_item(self.note_input)

    async def on_submit(self, interaction: discord.Interaction):
        self.settings["note"] = self.note_input.value
        await interaction.response.send_message("Note added successfully!", ephemeral=True)

class GiveawayButtons(discord.ui.View):
    def __init__(self, bot, ctx, settings):
        super().__init__(timeout=300)
        self.bot = bot
        self.ctx = ctx
        self.settings = settings

    @discord.ui.button(label="Add Note", style=discord.ButtonStyle.primary)
    async def note_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
        await interaction.response.send_modal(NoteModal(self.settings))

    @discord.ui.button(label="Set Prize", style=discord.ButtonStyle.success)
    async def prize_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
        await interaction.response.send_modal(PrizeModal(self.settings))

    @discord.ui.button(label="Set Duration", style=discord.ButtonStyle.primary)
    async def duration_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
        await interaction.response.send_modal(DurationModal(self.settings))

    @discord.ui.button(label="Set Winners", style=discord.ButtonStyle.primary)
    async def winners_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
        await interaction.response.send_modal(WinnersModal(self.settings))

    @discord.ui.button(label="Set Requirements", style=discord.ButtonStyle.secondary)
    async def requirements_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
        await interaction.response.send_modal(RequirementsModal(self.settings))
        
    @discord.ui.button(label="Toggle Entry Method", style=discord.ButtonStyle.secondary)
    async def toggle_entry_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
            
        self.settings["use_buttons"] = not self.settings.get("use_buttons", True)
        
        new_method = "Buttons" if self.settings["use_buttons"] else "Emoji Reactions"
        await interaction.response.send_message(f"Entry method set to: **{new_method}**", ephemeral=True)

    @discord.ui.button(label="Start Giveaway", style=discord.ButtonStyle.success)
    async def start_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return
        if not all([self.settings["prize"], self.settings["duration"], self.settings["winners"]]):
            await interaction.response.send_message("Please set all required fields first!", ephemeral=True)
            return
        
        await interaction.message.delete()
        await self.bot.get_cog('GiveawaySystem').create_giveaway(self.ctx, self.settings)
        self.stop()


class GiveawayEntryView(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=None)  
        self.bot = bot

    @discord.ui.button(label="Enter Giveaway", emoji="🎉", style=discord.ButtonStyle.success, custom_id="giveaway_enter")
    async def enter_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        
        message_id = interaction.message.id
        
        giveaway_cog = self.bot.get_cog('GiveawaySystem')
        if not giveaway_cog:
            await interaction.response.send_message("Giveaway system is not available.", ephemeral=True)
            return
            
        if message_id not in giveaway_cog.active_giveaways:
            await interaction.response.send_message("This giveaway is no longer active.", ephemeral=True)
            return
            
        giveaway_data = giveaway_cog.active_giveaways[message_id]
        
        if "entries" not in giveaway_data:
            giveaway_data["entries"] = set()
            
        user_id = interaction.user.id
        
        if user_id in giveaway_data["entries"]:
            
            await interaction.response.send_message("You have already entered this giveaway!", ephemeral=True)
        else:
            
            giveaway_data["entries"].add(user_id)
            await interaction.response.send_message("You have entered the giveaway! Good luck! 🍀", ephemeral=True)

class GiveawaySystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_giveaways = {}
        self.giveaway_task = self.bot.loop.create_task(self.check_giveaways())
        self.entry_update_task = self.bot.loop.create_task(self.update_giveaway_entries())
        self.use_buttons = True  

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def giveaway(self, ctx):
        settings = {
            "prize": None,
            "duration": None,
            "winners": None,
            "requirements": None,
            "note": None,
            "announcement_channel": None,
            "use_buttons": self.use_buttons
        }
       
        setup_embed = discord.Embed(
            title="🎉 Giveaway Setup Panel",
            description="First, select the announcement channel below!",
            color=discord.Color.blue()
        )
       
        channel_select = discord.ui.ChannelSelect(
            placeholder="Select announcement channel",
            channel_types=[discord.ChannelType.text],
            min_values=1,
            max_values=1
        )

        avatar_url = str(self.bot.user.display_avatar) if self.bot.user.display_avatar else None
        setup_embed.set_footer(text="Powered by ZygnalBot © 2025 TheHolyOneZ", icon_url=avatar_url)
       
        channel_view = discord.ui.View()
        channel_view.add_item(channel_select)
       
        setup_msg = await ctx.send(embed=setup_embed, view=channel_view)
       
        async def channel_callback(interaction):
            if interaction.user != ctx.author:
                await interaction.response.send_message("Only the giveaway creator can modify settings!", ephemeral=True)
                return
               
            settings["announcement_channel"] = interaction.data["values"][0]
            view = GiveawayButtons(self.bot, ctx, settings)
            await interaction.response.edit_message(content="Configure your giveaway settings:", view=view)
       
        channel_select.callback = channel_callback

    async def update_giveaway_entries(self):
        await self.bot.wait_until_ready()
        while not self.bot.is_closed():
            try:
                for giveaway_id, data in list(self.active_giveaways.items()):
                    channel = self.bot.get_channel(data["channel_id"])
                    if not channel:
                        continue
                        
                    try:
                        message = await channel.fetch_message(giveaway_id)
                        
                        if data.get("use_buttons", False):
                            entry_count = len(data.get("entries", set()))
                        else:
                            reactions = message.reactions
                            if reactions:
                                entry_count = reactions[0].count - 1  
                            else:
                                entry_count = 0
                        
                        embed = message.embeds[0]
                        embed_desc_lines = embed.description.split('\n')
                        
                        for i, line in enumerate(embed_desc_lines):
                            if line.startswith("**Entries:**"):
                                embed_desc_lines[i] = f"**Entries:** {entry_count}"
                                break
                        else:
                            
                            embed_desc_lines.insert(-2, f"**Entries:** {entry_count}")
                        
                        embed.description = '\n'.join(embed_desc_lines)
                        
                        if data.get("use_buttons", False):
                            await message.edit(embed=embed)
                        else:
                            await message.edit(embed=embed)
                            
                    except discord.NotFound:
                        
                        continue
                    except Exception as e:
                        print(f"Error updating giveaway entries: {e}")
                        
                await asyncio.sleep(30)  
            except Exception as e:
                print(f"Error in entry update task: {e}")
                await asyncio.sleep(30)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def gtoggle(self, ctx):
        
        self.use_buttons = not self.use_buttons
        mode = "Buttons" if self.use_buttons else "Emoji Reactions"
        await ctx.send(f"Giveaway entry mode set to: **{mode}**")

    async def create_giveaway(self, ctx, settings):
        channel = self.bot.get_channel(int(settings["announcement_channel"]))
        use_buttons = settings.get("use_buttons", self.use_buttons)
        
        duration_multiplier = 3600
        
        end_time = int(time.time() + (settings['duration'] * duration_multiplier))
        
        embed = discord.Embed(
                title="🎉 NEW GIVEAWAY! 🎉",
                description=f"**Prize:** {settings['prize']}\n"
                        f"**Winners:** {settings['winners']}\n"
                        f"**Duration:** {settings['duration']} hours\n"  
                        f"**Host:** {ctx.author.mention}\n"
                        f"**Ends:** <t:{end_time}:R>\n"
                        f"**Entries:** 0\n\n"
                        f"{'Click the Enter button below' if use_buttons else 'React with 🎉'} to enter!",
                color=discord.Color.green()
            )

        if settings.get('requirements'):
            embed.add_field(name="📋 Requirements", value=settings['requirements'], inline=False)
            
        if settings.get('note'):
            embed.add_field(name="📝 Note", value=settings['note'], inline=False)

        avatar_url = str(self.bot.user.display_avatar) if self.bot.user.display_avatar else None
        embed.set_footer(text="Powered by ZygnalBot © 2025 TheHolyOneZ", icon_url=avatar_url)
        
        if use_buttons:
            view = GiveawayEntryView(self.bot)
            giveaway_msg = await channel.send(embed=embed, view=view)
        else:
            giveaway_msg = await channel.send(embed=embed)
            await giveaway_msg.add_reaction("🎉")
        
        self.active_giveaways[giveaway_msg.id] = {
            "prize": settings['prize'],
            "winners": settings['winners'],
            "end_time": time.time() + (settings['duration'] * duration_multiplier),  
            "channel_id": channel.id,
            "requirements": settings['requirements'],
            "note": settings.get('note'),
            "use_buttons": use_buttons,
            "entries": set()
        }

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def gend(self, ctx, message_id: int):
        if message_id in self.active_giveaways:
            data = self.active_giveaways[message_id]
            channel = self.bot.get_channel(data["channel_id"])
            message = await channel.fetch_message(message_id)
            
            if data.get("use_buttons", False):
                
                user_ids = data.get("entries", set())
                users = [self.bot.get_user(user_id) for user_id in user_ids if self.bot.get_user(user_id)]
            else:
                
                users = [user async for user in message.reactions[0].users() if not user.bot]
            
            if not users:
                await channel.send("No valid entries for the giveaway!")
                return
                
            winners = random.sample(users, min(data["winners"], len(users)))
            winner_text = ", ".join(w.mention for w in winners)
            note_text = f"\n\n📝 **Note:** {data['note']}" if data.get('note') else ""
            await channel.send(f"🎉 Congratulations {winner_text}! You won: {data['prize']}{note_text}")
            
            try:
                embed = message.embeds[0]
                embed.description = embed.description.replace("React with 🎉 to enter!", "**GIVEAWAY ENDED**").replace("Click the Enter button below to enter!", "**GIVEAWAY ENDED**")
                embed.color = discord.Color.red()
                
                if data.get("use_buttons", False):
                
                    view = discord.ui.View.from_message(message)
                    for child in view.children:
                        child.disabled = True
                    await message.edit(embed=embed, view=view)
                else:
                    await message.edit(embed=embed)
            except:
                pass
                
            del self.active_giveaways[message_id]

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def greroll(self, ctx, message_id: int):
        try:
            message_id = int(message_id)
            channel = ctx.channel
            message = await channel.fetch_message(message_id)
            
            giveaway_data = next((data for msg_id, data in self.active_giveaways.items() if msg_id == message_id), None)
            
            if giveaway_data and giveaway_data.get("use_buttons", False):
                user_ids = giveaway_data.get("entries", set())
                users = [self.bot.get_user(user_id) for user_id in user_ids if self.bot.get_user(user_id)]
            else:
              
                reactions = message.reactions
                if not reactions:
                    await ctx.send("No reactions found on this message!")
                    return
                    
                users = [user for user in await reactions[0].users().flatten() if not user.bot]
            
            if not users:
                await channel.send("No valid entries for reroll!")
                return
                
            winner = random.choice(users)
            await channel.send(f"🎉 New winner: {winner.mention}!")
        except Exception as e:
            await ctx.send(f"Error rerolling giveaway: {str(e)}")

    async def check_giveaways(self):
        await self.bot.wait_until_ready()
        while not self.bot.is_closed():
            try:
                current_time = time.time()
                ended_giveaways = []
                
                for giveaway_id, data in list(self.active_giveaways.items()):
                    if current_time >= data["end_time"]:
                        channel = self.bot.get_channel(data["channel_id"])
                        if channel:
                            try:
                                message = await channel.fetch_message(giveaway_id)
                                
                                users = []
                                if data.get("use_buttons", False):
                                   
                                    user_ids = data.get("entries", set())
                                    users = [self.bot.get_user(user_id) for user_id in user_ids if self.bot.get_user(user_id)]
                                else:
                                    
                                    try:
                                    
                                        if message.reactions:
                                            
                                            for reaction in message.reactions:
                                                if str(reaction.emoji) == "🎉":
                                                    
                                                    reaction_users = [user async for user in reaction.users() if not user.bot]
                                                    users = reaction_users
                                                    break
                                    except Exception as e:
                                        print(f"Error getting reactions: {e}")
                                
                                if not users:
                                    await channel.send("No valid entries for the giveaway!")
                                else:
                                   
                                    winners = random.sample(users, min(data["winners"], len(users)))
                                    winner_text = ", ".join(w.mention for w in winners)
                                    note_text = f"\n\n📝 **Note:** {data['note']}" if data.get('note') else ""
                                    await channel.send(f"🎉 Congratulations {winner_text}! You won: {data['prize']}{note_text}")
                                
                                try:
                                    embed = message.embeds[0]
                                    
                                    embed.description = embed.description.replace("React with 🎉 to enter!", "**GIVEAWAY ENDED**").replace("Click the Enter button below to enter!", "**GIVEAWAY ENDED**")
                                    embed.color = discord.Color.red()
                                    
                                    if data.get("use_buttons", False):
                                        try:
                                            view = discord.ui.View.from_message(message)
                                            for child in view.children:
                                                child.disabled = True
                                            await message.edit(embed=embed, view=view)
                                        except Exception as e:
                                            print(f"Error updating view: {e}")
                                            await message.edit(embed=embed)
                                    else:
                                        await message.edit(embed=embed)
                                except Exception as e:
                                    print(f"Error updating ended giveaway message: {e}")
                                
                                ended_giveaways.append(giveaway_id)
                            except discord.NotFound:
                                print(f"Message {giveaway_id} not found, removing giveaway")
                                ended_giveaways.append(giveaway_id)
                            except Exception as e:
                                print(f"Error ending giveaway {giveaway_id}: {e}")
                                ended_giveaways.append(giveaway_id)
                        else:
                            print(f"Channel for giveaway {giveaway_id} not found, removing giveaway")
                            ended_giveaways.append(giveaway_id)
                
                for giveaway_id in ended_giveaways:
                    self.active_giveaways.pop(giveaway_id, None)
                
                await asyncio.sleep(10)  
            except Exception as e:
                print(f"Error in giveaway check task: {e}")
                await asyncio.sleep(10)

class Sudo(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_panels = {}

    class SudoView(View):
        def __init__(self, guild):
            super().__init__(timeout=300)
            self.guild = guild
            self.channel_id = None
            self.user_id = None
            self.message = None
            
            self.channel_select = Select(
                placeholder="Select Channel",
                options=[discord.SelectOption(
                    label=channel.name,
                    value=str(channel.id),
                    description=f"#{channel.name}"
                ) for channel in self.guild.text_channels[:25]]
            )
            self.channel_select.callback = self.select_channel
            self.add_item(self.channel_select)

        async def select_channel(self, interaction):
            self.channel_id = int(self.channel_select.values[0])
            await interaction.response.send_message(
                f"✅ Selected Channel: #{interaction.guild.get_channel(self.channel_id).name}",
                ephemeral=True
            )

        @discord.ui.button(label="Custom Input", style=discord.ButtonStyle.primary)
        async def custom_input(self, interaction: discord.Interaction, button: discord.ui.Button):
            if not self.channel_id:
                await interaction.response.send_message("❌ Please select a channel first!", ephemeral=True)
                return
            await interaction.response.send_modal(Sudo.SudoModal(self))

        @discord.ui.button(label="Execute", style=discord.ButtonStyle.success)
        async def execute(self, interaction: discord.Interaction, button: discord.ui.Button):
            if not all([self.channel_id, self.user_id, self.message]):
                await interaction.response.send_message("❌ Please complete all fields!", ephemeral=True)
                return

            channel = interaction.guild.get_channel(self.channel_id)
            member = interaction.guild.get_member(self.user_id)
            
            try:
                webhook = await channel.create_webhook(name=member.display_name)
                await webhook.send(
                    content=self.message,
                    username=member.display_name,
                    avatar_url=member.avatar.url if member.avatar else member.default_avatar.url,
                    allowed_mentions=discord.AllowedMentions(everyone=False)
                )
                await interaction.response.send_message("✅ Message successfully sent!", ephemeral=True)
            except Exception as e:
                logging.error(f"Error sending message: {e}")
                await interaction.response.send_message("⚠️ Failed to send the message!", ephemeral=True)
            finally:
                if 'webhook' in locals():
                    await webhook.delete()

        @discord.ui.button(label="Close", style=discord.ButtonStyle.danger)
        async def close_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
            await interaction.message.delete()

    class SudoModal(Modal, title="Message Configuration"):
        def __init__(self, view):
            super().__init__()
            self.view = view
            self.add_item(TextInput(
                label="User ID",
                required=True,
                placeholder="Enter the user ID here"
            ))
            self.add_item(TextInput(
                label="Message",
                style=discord.TextStyle.paragraph,
                required=True,
                placeholder="Enter your message here"
            ))

        async def on_submit(self, interaction: discord.Interaction):
            try:
                user_id = int(self.children[0].value)
                member = interaction.guild.get_member(user_id)
                
                if member:
                    self.view.user_id = user_id
                    self.view.message = self.children[1].value
                    await interaction.response.send_message(
                        f"✅ Message configured for {member.display_name}",
                        ephemeral=True
                    )
                else:
                    await interaction.response.send_message(
                        "❌ User not found in this server",
                        ephemeral=True
                    )
            except ValueError:
                await interaction.response.send_message(
                    "❌ Please enter a valid user ID",
                    ephemeral=True
                )

    @commands.command()
    @commands.has_permissions(administrator=True)
    @commands.guild_only()
    async def sudo(self, ctx):
        
        embed = discord.Embed(
            title="💫 Sudo Panel",
            description="Select a channel and configure your message using the buttons below.",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Instructions",
            value="1. Select a channel from the dropdown\n2. Click 'Custom Input' to set user and message\n3. Click 'Execute' to send"
        )
        embed.set_footer(
            text=f"Requested by {ctx.author}",
            icon_url=ctx.author.avatar.url if ctx.author.avatar else None
        )
        await ctx.send(embed=embed, view=self.SudoView(ctx.guild))

class SecurityAudit(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.risk_levels = {
            "CRITICAL": "🔴",
            "HIGH": "🟠",
            "MEDIUM": "🟡",
            "LOW": "🟢",
            "PASS": "✅"
        }

    class SecurityAuditView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=300)
            self.current_page = 0
            self.pages = []
            
        @discord.ui.button(label="◀️", style=discord.ButtonStyle.gray)
        async def prev_button(self, interaction: discord.Interaction, button: discord.ui.Button):
            self.current_page = max(0, self.current_page - 1)
            await interaction.response.edit_message(embed=self.pages[self.current_page])
            
        @discord.ui.button(label="▶️", style=discord.ButtonStyle.gray)
        async def next_button(self, interaction: discord.Interaction, button: discord.ui.Button):
            self.current_page = min(len(self.pages) - 1, self.current_page + 1)
            await interaction.response.edit_message(embed=self.pages[self.current_page])

        @discord.ui.button(label="Export Report", style=discord.ButtonStyle.green)
        async def export_button(self, interaction: discord.Interaction, button: discord.ui.Button):
            report = "# Security Audit Report\n\n"
            for page in self.pages:
                report += f"## {page.title}\n"
                for field in page.fields:
                    report += f"### {field.name}\n{field.value}\n\n"
            
            file = discord.File(io.StringIO(report), filename="security_audit.md")
            await interaction.response.send_message(file=file, ephemeral=True)

    @commands.command(name="security_audit", aliases=["audit", "check_security"])
    @commands.has_permissions(administrator=True)
    async def advanced_security_audit(self, ctx):
        disclaimer_embed = discord.Embed(
            title="🛡️ Security Audit Disclaimer",
            description=(
                "**Note:** The following security audit provides recommendations based on best practices. "
                "All findings are suggestions to enhance server security and can be adapted based on your specific needs.\n\n"
                "Every server is unique - use these insights as guidelines rather than strict requirements."
            ),
            color=discord.Color.blue()
        )
        await ctx.send(embed=disclaimer_embed)

        loading_embed = discord.Embed(
            title="🔍 Initiating Security Audit",
            description="Running comprehensive security analysis...",
            color=discord.Color.blue()
        )
        audit_msg = await ctx.send(embed=loading_embed)

        audit_results = {
            "Administrative Security": await self.check_admin_security(ctx),
            "Role Security": await self.check_role_security(ctx),
            "Channel Security": await self.check_channel_security(ctx),
            "Member Security": await self.check_member_security(ctx),
            "Integration Security": await self.check_integration_security(ctx)
        }

        view = self.SecurityAuditView()
        for category, results in audit_results.items():
            embed = discord.Embed(
                title=f"🛡️ {category}",
                description=f"Security analysis for {ctx.guild.name}",
                color=self.get_risk_color(results["risk_level"])
            )
            
            for check_name, check_data in results["checks"].items():
                embed.add_field(
                    name=f"{self.risk_levels[check_data['risk_level']]} {check_name}",
                    value=f"```\n{check_data['details']}\n```",
                    inline=False
                )
            
            embed.set_footer(text=f"Powered by ZygnalBot | © 2025 TheHolyOneZ | Risk Level: {results['risk_level']}")
            view.pages.append(embed)

        await audit_msg.edit(embed=view.pages[0], view=view)

    async def check_admin_security(self, ctx):
        checks = {}
        risk_level = "PASS"

        admin_roles = [role for role in ctx.guild.roles if role.permissions.administrator]
        if len(admin_roles) > 2:
            checks["Administrative Roles"] = {
                "risk_level": "HIGH",
                "details": f"Found {len(admin_roles)} admin roles. Recommended: 2 or fewer."
            }
            risk_level = self.escalate_risk(risk_level, "HIGH")

        if not ctx.guild.mfa_level:
            checks["2FA Enforcement"] = {
                "risk_level": "CRITICAL",
                "details": "Two-factor authentication is not required for administrative actions."
            }
            risk_level = self.escalate_risk(risk_level, "CRITICAL")

        bot_role = ctx.guild.me.top_role
        for role in admin_roles:
            if role >= bot_role:
                checks[f"Role Hierarchy: {role.name}"] = {
                    "risk_level": "CRITICAL",
                    "details": "Administrative role is positioned above the bot's role. This can bypass security measures."
                }
                risk_level = self.escalate_risk(risk_level, "CRITICAL")

        dangerous_combos = {
            "manage_guild": ["manage_roles", "manage_channels"],
            "manage_webhooks": ["administrator"],
            "manage_roles": ["kick_members", "ban_members"]
        }
        
        for role in ctx.guild.roles:
            role_perms = dict(role.permissions)
            for base_perm, risky_perms in dangerous_combos.items():
                if role_perms.get(base_perm) and any(role_perms.get(p) for p in risky_perms):
                    checks[f"Permission Combo: {role.name}"] = {
                        "risk_level": "HIGH",
                        "details": f"Role has dangerous permission combination: {base_perm} + {', '.join(risky_perms)}"
                    }
                    risk_level = self.escalate_risk(risk_level, "HIGH")

        vanity_roles = [r for r in ctx.guild.roles if r.permissions.manage_guild]
        if len(vanity_roles) > 1:
            checks["Vanity URL Management"] = {
                "risk_level": "MEDIUM",
                "details": f"{len(vanity_roles)} roles can modify server's vanity URL"
            }
            risk_level = self.escalate_risk(risk_level, "MEDIUM")

        audit_log_roles = [r for r in ctx.guild.roles if r.permissions.view_audit_log]
        if len(audit_log_roles) > 3:
            checks["Audit Log Access"] = {
                "risk_level": "MEDIUM",
                "details": f"{len(audit_log_roles)} roles can view audit logs. Recommend limiting access."
            }
            risk_level = self.escalate_risk(risk_level, "MEDIUM")

        mention_roles = [r for r in ctx.guild.roles if r.permissions.mention_everyone]
        if len(mention_roles) > 2:
            checks["Mass Mention Permissions"] = {
                "risk_level": "HIGH",
                "details": f"{len(mention_roles)} roles can mention @everyone/@here"
            }
            risk_level = self.escalate_risk(risk_level, "HIGH")

        integration_roles = [r for r in ctx.guild.roles if r.permissions.manage_guild]
        if len(integration_roles) > 2:
            checks["Integration Management"] = {
                "risk_level": "HIGH",
                "details": f"{len(integration_roles)} roles can manage integrations/webhooks"
            }
            risk_level = self.escalate_risk(risk_level, "HIGH")

        mod_roles = [r for r in ctx.guild.roles if any([r.permissions.kick_members, r.permissions.ban_members])]
        admin_mod_overlap = set(admin_roles) & set(mod_roles)
        if admin_mod_overlap:
            checks["Role Separation"] = {
                "risk_level": "MEDIUM",
                "details": "Administrative and moderator permissions should be separated into distinct roles"
            }
            risk_level = self.escalate_risk(risk_level, "MEDIUM")

        for role in ctx.guild.roles:
            if role.permissions.administrator and role.position > 1:
                lower_roles = [r for r in ctx.guild.roles if r.position < role.position]
                checks[f"Permission Inheritance: {role.name}"] = {
                    "risk_level": "HIGH",
                    "details": f"Administrative role can be inherited by {len(lower_roles)} lower roles"
                }
                risk_level = self.escalate_risk(risk_level, "HIGH")

        bot_members = [m for m in ctx.guild.members if m.bot]
        for bot in bot_members:
            if any(role.permissions.administrator for role in bot.roles):
                checks[f"Bot Permissions: {bot.name}"] = {
                    "risk_level": "CRITICAL",
                    "details": "Bot has administrative permissions. High security risk!"
                }
                risk_level = self.escalate_risk(risk_level, "CRITICAL")

        return {"risk_level": risk_level, "checks": checks}


    async def check_role_security(self, ctx):
        checks = {}
        risk_level = "PASS"

        dangerous_perms = [
            "administrator", "manage_guild", "manage_roles",
            "manage_channels", "manage_webhooks", "manage_emojis",
            "kick_members", "ban_members"
        ]

        for role in ctx.guild.roles:
            role_perms = [perm[0] for perm in role.permissions if perm[1]]
            dangerous_count = len(set(dangerous_perms) & set(role_perms))
            
            if dangerous_count > 0 and role < ctx.guild.me.top_role:
                checks[f"Role: {role.name}"] = {
                    "risk_level": "HIGH",
                    "details": f"Has {dangerous_count} dangerous permissions but is below bot role."
                }
                risk_level = self.escalate_risk(risk_level, "HIGH")

        return {"risk_level": risk_level, "checks": checks}

    async def check_channel_security(self, ctx):
        checks = {}
        risk_level = "PASS"

        for channel in ctx.guild.channels:
           
            if isinstance(channel, discord.TextChannel):
                webhooks = await channel.webhooks()
                if len(webhooks) > 0:
                    checks[f"Channel: {channel.name}"] = {
                        "risk_level": "MEDIUM",
                        "details": f"Has {len(webhooks)} webhooks. Review for security."
                    }
                    risk_level = self.escalate_risk(risk_level, "MEDIUM")

            if channel.overwrites_for(ctx.guild.default_role).send_messages:
                checks[f"Channel Permissions: {channel.name}"] = {
                    "risk_level": "HIGH",
                    "details": "@everyone can send messages in this channel."
                }
                risk_level = self.escalate_risk(risk_level, "HIGH")

        return {"risk_level": risk_level, "checks": checks}


    async def check_member_security(self, ctx):
        checks = {}
        risk_level = "PASS"

        verification_levels = {
            discord.VerificationLevel.none: "CRITICAL",
            discord.VerificationLevel.low: "HIGH",
            discord.VerificationLevel.medium: "MEDIUM",
            discord.VerificationLevel.high: "LOW",
            discord.VerificationLevel.highest: "PASS"
        }

        current_level = ctx.guild.verification_level
        checks["Verification Level"] = {
            "risk_level": verification_levels[current_level],
            "details": f"Current: {current_level.name}. Recommended: highest"
        }
        risk_level = self.escalate_risk(risk_level, verification_levels[current_level])

        if ctx.guild.explicit_content_filter != discord.ContentFilter.all_members:
            checks["Content Filter"] = {
                "risk_level": "HIGH",
                "details": "Content filter not set to maximum security."
            }
            risk_level = self.escalate_risk(risk_level, "HIGH")

        return {"risk_level": risk_level, "checks": checks}

    async def check_integration_security(self, ctx):
        checks = {}
        risk_level = "PASS"

        bots = [m for m in ctx.guild.members if m.bot]
        if len(bots) > 10:
            checks["Bot Count"] = {
                "risk_level": "MEDIUM",
                "details": f"Found {len(bots)} bots. Review for necessary permissions."
            }
            risk_level = self.escalate_risk(risk_level, "MEDIUM")

        integrations = await ctx.guild.integrations()
        for integration in integrations:
            checks[f"Integration: {integration.name}"] = {
                "risk_level": "LOW",
                "details": f"Type: {integration.type}. Review permissions."
            }
            risk_level = self.escalate_risk(risk_level, "LOW")

        return {"risk_level": risk_level, "checks": checks}

    def get_risk_color(self, risk_level):
        colors = {
            "CRITICAL": discord.Color.dark_red(),
            "HIGH": discord.Color.red(),
            "MEDIUM": discord.Color.orange(),
            "LOW": discord.Color.green(),
            "PASS": discord.Color.blue()
        }
        return colors.get(risk_level, discord.Color.default())

    def escalate_risk(self, current_risk, new_risk):
        risk_levels = ["PASS", "LOW", "MEDIUM", "HIGH", "CRITICAL"]
        current_index = risk_levels.index(current_risk)
        new_index = risk_levels.index(new_risk)
        return risk_levels[max(current_index, new_index)]

class TranslationSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.translator = Translator()
        self.auto_translate_channels = {}
        self.selected_manual_lang = None
        self.selected_auto_lang = None
        self.common_languages = {
            "Arabic": "ar", "Chinese": "zh-cn", "Dutch": "nl",
            "English": "en", "French": "fr", "German": "de",
            "Hindi": "hi", "Italian": "it", "Japanese": "ja",
            "Korean": "ko", "Portuguese": "pt", "Russian": "ru",
            "Spanish": "es", "Turkish": "tr", "Vietnamese": "vi"
        }

    @commands.command()
    async def translate(self, ctx):
        await self.create_translation_ui(ctx)

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.guild:  
            return   
        if message.channel.id in self.auto_translate_channels and not message.author.bot:
            target_lang = self.auto_translate_channels[message.channel.id]
            try:
                translation = await self.translator.translate(message.content, dest=target_lang)
                if translation.src != target_lang:
                    embed = discord.Embed(
                        title="🌐 Auto Translation",
                        description=f"**Original** ({translation.src}):\n{message.content}\n\n**Translation** ({target_lang}):\n{translation.text}",
                        color=discord.Color.blue()
                    )
                    embed.set_footer(text=f"From: {message.author.display_name} | Target Language: {target_lang}")
                    await message.reply(embed=embed, mention_author=False)
            except Exception as e:
                pass

    async def create_translation_ui(self, ctx):
        embed = discord.Embed(
            title="🌐 Advanced Translation System",
            description="Select target language and enter text to translate\nSupports 15+ languages with auto-detection",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="✨ Features",
            value="• Text Translation with Language Selection\n• Customizable Auto-Translation\n• Smart Language Detection\n• Multiple Language Support\n• Real-time Translation"
        )
        embed.set_footer(text="Powered by Google Translate | Character limit: 1000 | ZygnalBot - TheHolyOneZ")

        class TranslationView(discord.ui.View):
            def __init__(self, cog, timeout=180):
                super().__init__(timeout=timeout)
                self.cog = cog
                self.manual_lang = None
                self.auto_lang = None

            @discord.ui.select(
                placeholder="Choose language for manual translation",
                options=[discord.SelectOption(label=lang, value=code, emoji="🔤")
                        for lang, code in self.common_languages.items()]
            )
            async def manual_select(self, interaction: discord.Interaction, select: discord.ui.Select):
                self.manual_lang = select.values[0]
                lang_name = [k for k, v in self.cog.common_languages.items() if v == select.values[0]][0]
                await interaction.response.send_message(f"Manual translation language set to: {lang_name}", ephemeral=True)

            @discord.ui.select(
                placeholder="Choose language for auto-translation",
                options=[discord.SelectOption(label=lang, value=code, emoji="🌐")
                        for lang, code in self.common_languages.items()]
            )
            async def auto_select(self, interaction: discord.Interaction, select: discord.ui.Select):
                if not (interaction.user.guild_permissions.manage_channels or 
                        interaction.user.guild_permissions.administrator):
                    await interaction.response.send_message(
                        "🔒 This feature requires Manage Channels or Administrator permissions", 
                        ephemeral=True
                    )
                    return
                    
                self.auto_lang = select.values[0]
                lang_name = [k for k, v in self.cog.common_languages.items() if v == select.values[0]][0]
                await interaction.response.send_message(
                    f"🌐 Auto-translation language set to: {lang_name}", 
                    ephemeral=True
                )

            @discord.ui.button(label="Translate Text", style=discord.ButtonStyle.primary, emoji="🔄")
            async def translate(self, interaction: discord.Interaction, button: discord.ui.Button):
                if not self.manual_lang:
                    await interaction.response.send_message("Please select a target language first!", ephemeral=True)
                    return
                modal = TranslationModal(self.cog.translator, self.manual_lang)
                await interaction.response.send_modal(modal)

            @discord.ui.button(label="Auto-Translate: Off", style=discord.ButtonStyle.red, emoji="🤖")
            async def auto_translate(self, interaction: discord.Interaction, button: discord.ui.Button):
                if not (interaction.user.guild_permissions.manage_channels or 
                        interaction.user.guild_permissions.administrator):
                    await interaction.response.send_message(
                        "🔒 This feature requires Manage Channels or Administrator permissions",
                        ephemeral=True
                    )
                    return

                channel_id = interaction.channel.id
                if channel_id in self.cog.auto_translate_channels:
                    del self.cog.auto_translate_channels[channel_id]
                    button.label = "Auto-Translate: Off"
                    button.style = discord.ButtonStyle.red
                    await interaction.response.edit_message(view=self)
                    await interaction.followup.send("🔴 Auto-translation disabled for this channel", ephemeral=True)
                else:
                    if not self.auto_lang:
                        await interaction.response.send_message("⚠️ Please select a target language first", ephemeral=True)
                        return
                        
                    self.cog.auto_translate_channels[channel_id] = self.auto_lang
                    button.label = "Auto-Translate: On"
                    button.style = discord.ButtonStyle.green
                    await interaction.response.edit_message(view=self)
                    lang_name = [k for k, v in self.cog.common_languages.items() if v == self.auto_lang][0]
                    await interaction.followup.send(f"🟢 Auto-translation enabled | Language: {lang_name}", ephemeral=True)


            @discord.ui.button(label="Detect Language", style=discord.ButtonStyle.secondary, emoji="🔍")
            async def detect_language(self, interaction: discord.Interaction, button: discord.ui.Button):
                modal = LanguageDetectionModal(self.cog.translator)
                await interaction.response.send_modal(modal)

        view = TranslationView(self, timeout=180)
        await ctx.send(embed=embed, view=view)


class TranslationModal(discord.ui.Modal):
    def __init__(self, translator, target_lang):
        super().__init__(title="Enter Text to Translate")
        self.translator = translator
        self.target_lang = target_lang
        
        self.text_input = discord.ui.TextInput(
            label="Text to translate",
            style=discord.TextStyle.paragraph,
            placeholder="Enter your text here...",
            required=True,
            max_length=1000
        )
        self.add_item(self.text_input)

    async def on_submit(self, interaction):
        try:
            translation = await self.translator.translate(
                self.text_input.value,
                dest=self.target_lang
            )
            
            result_embed = discord.Embed(
                title="Translation Result",
                color=discord.Color.green()
            )
            result_embed.add_field(
                name=f"Original ({translation.src})",
                value=self.text_input.value,
                inline=False
            )
            result_embed.add_field(
                name=f"Translation ({self.target_lang})",
                value=translation.text,
                inline=False
            )
            result_embed.set_footer(text=f"Detected language: {translation.src}")
            
            await interaction.response.send_message(embed=result_embed)
            
        except Exception as e:
            await interaction.response.send_message(
                "Translation service temporarily unavailable. Please try again later.",
                ephemeral=True
            )

class LanguageDetectionModal(discord.ui.Modal):
    def __init__(self, translator):
        super().__init__(title="Detect Language")
        self.translator = translator
        
        self.text_input = discord.ui.TextInput(
            label="Enter text to detect language",
            style=discord.TextStyle.paragraph,
            placeholder="Enter text here...",
            required=True,
            max_length=1000
        )
        self.add_item(self.text_input)

    async def on_submit(self, interaction):
        try:
            detection = await self.translator.detect(self.text_input.value)
            embed = discord.Embed(
                title="Language Detection Result",
                description=f"Text: {self.text_input.value}",
                color=discord.Color.blue()
            )
            embed.add_field(name="Detected Language", value=detection.lang)
            embed.add_field(name="Confidence", value=f"{detection.confidence:.2%}")
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await interaction.response.send_message(
                "Language detection failed. Please try again.",
                ephemeral=True
            )

class AntiNukeConfirmView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=60.0)
        self.antinuke = antinuke_system

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user.guild_permissions.administrator
       
    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.red, emoji="✅")
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        default_settings = {
            "ban_protection": True,
            "channel_protection": True,
            "role_protection": True,
            "webhook_protection": True,
            "bot_protection": True
        }
        
        default_thresholds = {
            "ban_limit": 3,
            "kick_limit": 5,
            "channel_limit": 2,
            "role_limit": 2,
            "webhook_limit": 3
        }

        self.antinuke.settings[interaction.guild_id] = default_settings
        self.antinuke.thresholds[interaction.guild_id] = default_thresholds

        embed = discord.Embed(
            title="✅ Settings Reset Complete",
            description="All anti-nuke settings have been reset to default values",
            color=discord.Color.green()
        )
        await interaction.response.edit_message(embed=embed, view=AntiNukeView(self.antinuke))
        self.stop()
       
    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.gray, emoji="❌")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.edit_message(view=AntiNukeView(self.antinuke))
        self.stop()

class WhitelistManagementView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=None)
        self.antinuke = antinuke_system

    @discord.ui.select(
        cls=discord.ui.UserSelect,
        placeholder="Add Users to Whitelist",
        min_values=1,
        max_values=25,
        custom_id="user_select"
    )
    async def user_select(self, interaction: discord.Interaction, select: discord.ui.UserSelect):
        await interaction.response.defer()
        added_items = []
        
        for user in select.values:
            if user.id not in self.antinuke.whitelist:
                self.antinuke.whitelist.add(user.id)
                added_items.append(f"User: {user.mention}")
        
        embed = discord.Embed(
            title="✅ Whitelist Updated",
            description=f"Added to whitelist:\n" + "\n".join(added_items),
            color=discord.Color.gold()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

    @discord.ui.select(
        cls=discord.ui.RoleSelect,
        placeholder="Add Roles to Whitelist",
        min_values=1,
        max_values=25,
        custom_id="role_select"
    )
    async def role_select(self, interaction: discord.Interaction, select: discord.ui.RoleSelect):
        await interaction.response.defer()
        added_items = []
        
        for role in select.values:
            if role.id not in self.antinuke.whitelist:
                self.antinuke.whitelist.add(role.id)
                added_items.append(f"Role: {role.mention}")
        
        embed = discord.Embed(
            title="✅ Whitelist Updated",
            description=f"Added to whitelist:\n" + "\n".join(added_items),
            color=discord.Color.gold()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

    @discord.ui.button(label="View Whitelist", style=discord.ButtonStyle.blurple)
    async def view_whitelist(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            whitelist = list(self.antinuke.whitelist)
            user_mentions = []
            role_mentions = []
            
            for id in whitelist:
                role = interaction.guild.get_role(id)
                if role:
                    role_mentions.append(f"🎭 {role.mention} (ID: {role.id})")
            
            for id in whitelist:
                user = interaction.guild.get_member(id)
                if user:
                    user_mentions.append(f"👤 {user.mention} (ID: {user.id})")
            
            embed = discord.Embed(
                title="📋 Current Whitelist",
                color=discord.Color.gold(),
                timestamp=datetime.now()
            )
            
            if role_mentions:
                embed.add_field(name="🎭 Whitelisted Roles", value="\n".join(role_mentions), inline=False)
            if user_mentions:
                embed.add_field(name="👤 Whitelisted Users", value="\n".join(user_mentions), inline=False)
            
            if not (user_mentions or role_mentions):
                embed.description = "No entries in whitelist"
            else:
                embed.set_footer(text=f"Total Entries: {len(user_mentions) + len(role_mentions)}")
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"Error viewing whitelist: {str(e)}", ephemeral=True)

    @discord.ui.button(label="Remove from Whitelist", style=discord.ButtonStyle.red)
    async def remove_whitelist(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        whitelist = list(self.antinuke.whitelist)
        options = []

        for id in whitelist:
            role = interaction.guild.get_role(id)
            if role:
                options.append(discord.SelectOption(
                    label=f"🎭 Role: {role.name}",
                    description=f"Role ID: {role.id}",
                    value=str(role.id),
                    emoji="🎭"
                ))

        for id in whitelist:
            user = interaction.guild.get_member(id)
            if user:
                options.append(discord.SelectOption(
                    label=f"👤 User: {user.name}",
                    description=f"User ID: {user.id}",
                    value=str(user.id),
                    emoji="👤"
                ))

        if not options:
            return await interaction.followup.send("No items in whitelist to remove!", ephemeral=True)

        select = discord.ui.Select(
            placeholder="Select items to remove from whitelist",
            min_values=1,
            max_values=len(options),
            options=options
        )

        async def remove_callback(interaction: discord.Interaction):
            removed_items = []
            for value in select.values:
                item_id = int(value)
                self.antinuke.whitelist.remove(item_id)
                
                if item_id < 9223372036854775807:
                    user = interaction.guild.get_member(item_id)
                    removed_items.append(f"👤 User: {user.mention if user else item_id}")
                else:
                    role = interaction.guild.get_role(item_id)
                    removed_items.append(f"🎭 Role: {role.mention if role else item_id}")

            embed = discord.Embed(
                title="✅ Removed from Whitelist",
                description="\n".join(removed_items),
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)

        select.callback = remove_callback
        view = discord.ui.View()
        view.add_item(select)
        await interaction.followup.send("Select items to remove:", view=view, ephemeral=True)


    @discord.ui.button(label="Back", style=discord.ButtonStyle.gray)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        advanced_view = AdvancedSettingsView(self.antinuke)
        embed = discord.Embed(
            title="⚙️ Advanced Settings",
            description="Configure advanced anti-nuke settings",
            color=discord.Color.blue()
        )
        await interaction.response.edit_message(embed=embed, view=advanced_view)


class ThresholdSettingsModal1(discord.ui.Modal):
    def __init__(self, antinuke_system):
        super().__init__(title="Primary Thresholds")
        self.antinuke = antinuke_system
        
        key_thresholds = {
            'ban_limit': antinuke_system.thresholds['ban_limit'],
            'kick_limit': antinuke_system.thresholds['kick_limit'],
            'channel_delete_limit': antinuke_system.thresholds['channel_delete_limit'],
            'role_delete_limit': antinuke_system.thresholds['role_delete_limit'],
            'webhook_create_limit': antinuke_system.thresholds['webhook_create_limit']
        }
        
        for threshold, current in key_thresholds.items():
            self.add_item(discord.ui.TextInput(
                label=threshold.replace('_', ' ').title(),
                placeholder=f"Current: {current}",
                default=str(current),
                min_length=1,
                max_length=2,
                required=True
            ))

    async def on_submit(self, interaction: discord.Interaction):
        updates = {}
        for item in self.children:
            try:
                value = int(item.value)
                if 1 <= value <= 99:
                    updates[item.label.lower().replace(' ', '_')] = value
            except ValueError:
                continue
                
        self.antinuke.thresholds.update(updates)
        
        embed = discord.Embed(
            title="Primary Thresholds Updated",
            color=discord.Color.green()
        )
        for k, v in updates.items():
            embed.add_field(name=k.replace('_', ' ').title(), value=f"New limit: {v}")
            
        await interaction.response.send_message(embed=embed, ephemeral=True)

class ThresholdSettingsModal2(discord.ui.Modal):
    def __init__(self, antinuke_system):
        super().__init__(title="Secondary Thresholds")
        self.antinuke = antinuke_system
        
        secondary_thresholds = {
            'mass_mention_limit': antinuke_system.thresholds['mass_mention_limit'],
            'emoji_delete_limit': antinuke_system.thresholds['emoji_delete_limit'],
            'bot_add_limit': antinuke_system.thresholds['bot_add_limit']
        }
        
        for threshold, current in secondary_thresholds.items():
            self.add_item(discord.ui.TextInput(
                label=threshold.replace('_', ' ').title(),
                placeholder=f"Current: {current}",
                default=str(current),
                min_length=1,
                max_length=2,
                required=True
            ))

    async def on_submit(self, interaction: discord.Interaction):
        updates = {}
        for item in self.children:
            try:
                value = int(item.value)
                if 1 <= value <= 99:
                    updates[item.label.lower().replace(' ', '_')] = value
            except ValueError:
                continue
                
        self.antinuke.thresholds.update(updates)
        
        embed = discord.Embed(
            title="Secondary Thresholds Updated",
            color=discord.Color.green()
        )
        for k, v in updates.items():
            embed.add_field(name=k.replace('_', ' ').title(), value=f"New limit: {v}")
            
        await interaction.response.send_message(embed=embed, ephemeral=True)

class ProtectionToggleView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=None)
        self.antinuke = antinuke_system
        
        protections = [
            ("Ban Protection", "ban_protection"),
            ("Channel Protection", "channel_protection"), 
            ("Role Protection", "role_protection"),
            ("Webhook Protection", "webhook_protection"),
            ("Bot Protection", "bot_protection")
        ]
        
        for label, feature in protections:
            self.add_item(ToggleButton(label, feature))

class ToggleButton(discord.ui.Button):
    def __init__(self, label, feature):
        super().__init__(
            label=label,
            style=discord.ButtonStyle.green,
            custom_id=f"toggle_{feature}_{int(time.time())}"  
        )
        self.feature = feature

    async def callback(self, interaction: discord.Interaction):
        guild_id = interaction.guild_id
        if guild_id not in self.view.antinuke.settings:
            self.view.antinuke.settings[guild_id] = {}
        
        current = self.view.antinuke.settings[guild_id].get(self.feature, False)
        self.view.antinuke.settings[guild_id][self.feature] = not current
        
        self.style = discord.ButtonStyle.green if not current else discord.ButtonStyle.red
        
        embed = discord.Embed(
            title="🔄 Protection Status Updated",
            description=f"{self.label} is now {'enabled' if not current else 'disabled'}",
            color=discord.Color.green() if not current else discord.Color.red()
        )
        
        embed.add_field(
            name="Current Status",
            value="✅ Active" if not current else "❌ Inactive",
            inline=False
        )
        
        await interaction.response.edit_message(embed=embed, view=self.view)

class ThresholdButton(discord.ui.Button):
    def __init__(self):
        super().__init__(
            label="Set Limits",  
            style=discord.ButtonStyle.blurple,
            custom_id="threshold_settings"
        )

    async def callback(self, interaction: discord.Interaction):
        modal = ThresholdModal(self.view.antinuke)
        await interaction.response.send_modal(modal)

class ThresholdModal(discord.ui.Modal):
    def __init__(self, antinuke):
        super().__init__(title="🎚️ Threshold Settings")
        self.antinuke = antinuke
       
        for i, (threshold, value) in enumerate(antinuke.thresholds.items()):
            self.add_item(
                discord.ui.TextInput(
                    label=threshold.replace('_', ' ').title(),
                    placeholder=f"Current: {value}",
                    default=str(value),
                    required=True,
                    min_length=1,
                    max_length=2,
                    row=i
                )
            )

    async def on_submit(self, interaction: discord.Interaction):
        updates = {}
        for child in self.children:
            try:
                value = int(child.value)
                if value < 1:
                    raise ValueError
                updates[child.label.lower().replace(' ', '_')] = value
            except ValueError:
                await interaction.response.send_message(
                    f"❌ Invalid value for {child.label}. Please use numbers between 1-99.",
                    ephemeral=True
                )
                return

        self.antinuke.thresholds.update(updates)
       
        embed = discord.Embed(
            title="✅ Thresholds Updated",
            color=discord.Color.green()
        )
        for key, value in updates.items():
            embed.add_field(name=key.replace('_', ' ').title(), value=f"New limit: {value}")
           
        await interaction.response.send_message(embed=embed, ephemeral=True)

class WhitelistButton(discord.ui.Button):
    def __init__(self):
        super().__init__(
            label="Manage Whitelist",  
            style=discord.ButtonStyle.grey,
            custom_id="whitelist_manager"
        )

    async def callback(self, interaction: discord.Interaction):
        embed = discord.Embed(
            title="⭐ Whitelist Manager",
            description="Select users/roles to whitelist",
            color=discord.Color.gold()
        )
        
        whitelist_view = WhitelistView(self.view.antinuke)
        await interaction.response.send_message(embed=embed, view=whitelist_view, ephemeral=True)

class WhitelistView(discord.ui.View):
    def __init__(self, system):
        super().__init__(timeout=None)
        self.system = system
        
        self.add_item(discord.ui.UserSelect(
            placeholder="Select Users to Whitelist",
            min_values=1,
            max_values=25
        ))
        
        self.add_item(discord.ui.RoleSelect(
            placeholder="Select Roles to Whitelist",
            min_values=1,
            max_values=25
        ))

    @discord.ui.select(cls=discord.ui.UserSelect)
    async def user_select(self, interaction: discord.Interaction, select: discord.ui.UserSelect):
        await self.handle_select(interaction, select.values, "users")

    @discord.ui.select(cls=discord.ui.RoleSelect) 
    async def role_select(self, interaction: discord.Interaction, select: discord.ui.RoleSelect):
        await self.handle_select(interaction, select.values, "roles")

    async def handle_select(self, interaction: discord.Interaction, selected, type_str):
        added_items = []
        for item in selected:
            self.system.whitelist.add(item.id)
            added_items.append(f"{'User' if type_str == 'users' else 'Role'}: {item.mention}")
            
        embed = discord.Embed(
            title="✨ Whitelist Updated",
            description=f"Added to whitelist:\n" + "\n".join(added_items),
            color=discord.Color.gold()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class ResetButton(discord.ui.Button):
    def __init__(self):
        super().__init__(
            label="Reset Settings",
            style=discord.ButtonStyle.danger,
            custom_id="reset_settings"
        )

    async def callback(self, interaction: discord.Interaction):
        reset_confirm = ResetConfirmationView(self.view.antinuke)
        embed = discord.Embed(
            title="⚠️ Confirm Reset",
            description="Are you sure you want to reset all anti-nuke settings?",
            color=discord.Color.orange()
        )
        await interaction.response.send_message(embed=embed, view=reset_confirm, ephemeral=True)

class WhitelistRemoveModal(discord.ui.Modal):
    def __init__(self, antinuke_system):
        super().__init__(title="Remove from Whitelist")
        self.antinuke = antinuke_system
        
        self.id_input = discord.ui.TextInput(
            label="User/Role ID to remove",
            placeholder="Enter ID to remove from whitelist"
        )
        self.add_item(self.id_input)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            id_to_remove = int(self.id_input.value)
            if id_to_remove in self.antinuke.whitelist:
                self.antinuke.whitelist.remove(id_to_remove)
                await interaction.response.send_message("✅ Successfully removed from whitelist!", ephemeral=True)
            else:
                await interaction.response.send_message("❌ ID not found in whitelist", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ Please enter a valid ID", ephemeral=True)

class ResetConfirmationView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=None)
        self.antinuke = antinuke_system

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild_id = interaction.guild_id
        self.system.settings[guild_id] = {}
        self.system.violation_counts[guild_id] = {}
        
        embed = discord.Embed(
            title="🔄 Settings Reset",
            description="All anti-nuke settings have been reset to default.",
            color=discord.Color.green()
        )
        await interaction.response.edit_message(embed=embed, view=None)

class AntiNukeSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.violation_counts = {}
        self.action_cooldowns = {}
        self.settings = {}
        self.thresholds = {
            "ban_limit": 3,
            "kick_limit": 5,
            "channel_delete_limit": 2,
            "role_delete_limit": 2,
            "webhook_create_limit": 3,
            "mass_mention_limit": 5,
            "emoji_delete_limit": 3,
            "bot_add_limit": 2
        }
        self.action_logs = {}
        self.whitelist = set()
        self.violation_counts = {}
        self.protected_roles = set()
        self.alert_channels = {}  
        self.action_cooldowns = {}
        self.last_actions = {}

    @commands.command(name="antinuke", aliases=["an"])
    @commands.has_permissions(administrator=True)
    async def antinuke_settings(self, ctx):
        embed = discord.Embed(
            title="🛡️ Anti-Nuke Control Panel",
            description="Configure server protection settings\n\n**⚠️ Important:** For optimal protection, ensure the bot role is placed directly under the server owner role in the hierarchy.",
            color=discord.Color.blue()
        )

        guild_settings = self.settings.get(ctx.guild.id, {})
        guild_thresholds = self.thresholds.get(ctx.guild.id, self.thresholds)

        protection_status = "\n".join(
            f"{protection.replace('_', ' ').title()}: {'✅' if enabled else '❌'}"
            for protection, enabled in guild_settings.items()
        ) or "No protections configured"
        embed.add_field(name="Active Protections", value=protection_status, inline=True)

        limits_status = "\n".join(
            f"{limit.replace('_', ' ').title()}: {value}"
            for limit, value in guild_thresholds.items()
        ) or "Default limits"
        embed.add_field(name="Current Limits", value=limits_status, inline=True)

        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")

        view = AntiNukeView(self)
        await ctx.send(embed=embed, view=view)

    @commands.command(name="setalertchannel")
    @commands.has_permissions(administrator=True)
    async def set_alert_channel(self, ctx, channel: discord.TextChannel = None):
        
        channel = channel or ctx.channel
        self.alert_channels[ctx.guild.id] = channel.id
        
        embed = discord.Embed(
            title="✅ Alert Channel Set",
            description=f"Anti-Nuke alerts will now be sent to {channel.mention}",
            color=discord.Color.green()
        )
        await ctx.send(embed=embed)

    @commands.command(name="addprotected")
    @commands.has_permissions(administrator=True)
    async def add_protected_role(self, ctx, role: discord.Role):
        
        self.protected_roles.add(role.id)
        await ctx.send(f"✅ Added {role.mention} to protected roles")

    @commands.command(name="removeprotected")
    @commands.has_permissions(administrator=True)
    async def remove_protected_role(self, ctx, role: discord.Role):
       
        if role.id in self.protected_roles:
            self.protected_roles.remove(role.id)
            await ctx.send(f"✅ Removed {role.mention} from protected roles")
        else:
            await ctx.send(f"❌ {role.mention} is not in the protected roles list")

    @commands.command(name="listprotected")
    @commands.has_permissions(administrator=True)
    async def list_protected_roles(self, ctx):
        
        if not self.protected_roles:
            await ctx.send("No protected roles configured")
            return
            
        roles = [ctx.guild.get_role(role_id) for role_id in self.protected_roles]
        roles = [role.mention for role in roles if role]
        
        embed = discord.Embed(
            title="Protected Roles",
            description="\n".join(roles) or "No valid protected roles",
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed)

    async def get_alert_channel(self, guild_id):
        channel_id = self.alert_channels.get(guild_id)
        if not channel_id:
            return None
        return self.bot.get_channel(channel_id)

    async def handle_violation(self, guild, user, violation_type):
        if user.id in self.whitelist:
            return False
        if guild.id not in self.settings:
            return False
        protection_type = violation_type.replace("_limit", "_protection")
        if not self.settings[guild.id].get(protection_type, False):
            return False
            
        if guild.id not in self.violation_counts:
            self.violation_counts[guild.id] = {}
            
        if user.id not in self.violation_counts[guild.id]:
            self.violation_counts[guild.id][user.id] = {}
            
        if violation_type not in self.violation_counts[guild.id][user.id]:
            self.violation_counts[guild.id][user.id][violation_type] = 0
            
        self.violation_counts[guild.id][user.id][violation_type] += 1
        count = self.violation_counts[guild.id][user.id][violation_type]
        
        guild_thresholds = self.thresholds.get(guild.id, self.thresholds)
        threshold = guild_thresholds.get(violation_type, self.thresholds[violation_type])
        
        await self.log_violation(guild, user, violation_type, count, threshold)
        
        if count >= threshold:
            await self.take_action(guild, user, violation_type)
            return True
            
        return False

    async def log_violation(self, guild, user, violation_type, count, threshold):
        alert_channel = await self.get_alert_channel(guild.id)
        if not alert_channel:
            return
            
        embed = discord.Embed(
            title="⚠️ Security Violation Detected",
            description=f"User: {user.mention}\nViolation: {violation_type.replace('_', ' ').title()}\nCount: {count}/{threshold}",
            color=discord.Color.orange(),
            timestamp=datetime.now()
        )
        
        embed.set_footer(text=f"User ID: {user.id}")
        
        try:
            await alert_channel.send(embed=embed)
        except discord.HTTPException:
            pass  

    async def take_action(self, guild, user, violation_type):
        print(f"[DEBUG] Taking action on {user} for {violation_type}")
        now = datetime.now().timestamp()
        cooldown_key = f"{guild.id}:{user.id}"
        if cooldown_key in self.action_cooldowns and now - self.action_cooldowns[cooldown_key] < 10:
            print("[DEBUG] Cooldown active, skipping action.")
            return 
        
        self.action_cooldowns[cooldown_key] = now
        alert_channel = await self.get_alert_channel(guild.id)
        
        try:
            if violation_type in ["ban_limit", "mass_mention_limit"]:
                await guild.ban(user, reason=f"Anti-Nuke: Exceeded {violation_type}")
                action_taken = "Banned"
            elif violation_type in ["kick_limit", "bot_add_limit"]:
                await guild.kick(user, reason=f"Anti-Nuke: Exceeded {violation_type}")
                action_taken = "Kicked"
            else:
                for role in user.roles[1:]:
                    if role.id not in self.protected_roles:
                        try:
                            await user.remove_roles(role, reason=f"Anti-Nuke: Exceeded {violation_type}")
                        except discord.HTTPException:
                            print(f"[DEBUG] Failed to remove role {role.name} from {user}")
                            continue
                action_taken = "Roles Removed"
            
            if alert_channel:
                embed = discord.Embed(
                    title="🛡️ Security Action Taken",
                    description=f"Action: **{action_taken}**\nUser: {user.mention}\nReason: Exceeded {violation_type.replace('_', ' ').title()}",
                    color=discord.Color.red(),
                    timestamp=datetime.now()
                )
                embed.set_footer(text=f"User ID: {user.id}")
                await alert_channel.send(embed=embed)
                print(f"[DEBUG] Alert sent to {alert_channel.name}")
        
        except discord.Forbidden:
            if alert_channel:
                await alert_channel.send(f"⚠️ Failed to take action against {user.mention} - Missing Permissions")
            print(f"[DEBUG] Missing permissions to take action against {user}")
        
        except Exception as e:
            if alert_channel:
                await alert_channel.send(f"⚠️ Error taking action: {str(e)}")
            print(f"[DEBUG] Error taking action: {e}")

    @commands.Cog.listener()
    async def on_member_ban(self, guild, user):
       
        if self.bot.user.id == getattr(guild.me, "id", None):
            return
            
        try:
            async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.ban):
                if entry.target.id == user.id:
              
                    if entry.user.id in self.whitelist:
                        return
                        
                    await self.handle_violation(guild, entry.user, "ban_limit")
                    break
        except discord.HTTPException:
            pass

    @commands.Cog.listener()
    async def on_member_remove(self, member):
       
        guild = member.guild
        
        try:
            async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.kick):
                if entry.target.id == member.id and entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                   
                    if entry.user.id in self.whitelist:
                        return
                        
                    await self.handle_violation(guild, entry.user, "kick_limit")
                    break
        except discord.HTTPException:
            pass

    @commands.Cog.listener()
    async def on_guild_channel_delete(self, channel):
        guild = channel.guild
        try:
            async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.channel_delete):
                if entry.target.id == channel.id and entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                  
                    if entry.user.id in self.whitelist:
                        return
                    await self.handle_violation(guild, entry.user, "channel_delete_limit")
                    break
        except discord.HTTPException:
            pass

    @commands.Cog.listener()
    async def on_guild_role_delete(self, role):
        
        guild = role.guild
        
        if role.id in self.protected_roles:
            
            try:
                async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.role_delete):
                    if entry.target.id == role.id and entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                       
                        await self.take_action(guild, entry.user, "role_delete_limit")
                        break
            except discord.HTTPException:
                pass
            return
            
        try:
            async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.role_delete):
                if entry.target.id == role.id and entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                
                    if entry.user.id in self.whitelist:
                        return
                        
                    await self.handle_violation(guild, entry.user, "role_delete_limit")
                    break
        except discord.HTTPException:
            pass

    @commands.Cog.listener()
    async def on_webhook_update(self, channel):
     
        guild = channel.guild
        
        try:
            async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.webhook_create):
                if entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                    
                    if entry.user.id in self.whitelist:
                        return
                        
                    await self.handle_violation(guild, entry.user, "webhook_create_limit")
                    break
        except discord.HTTPException:
            pass

    @commands.Cog.listener()
    async def on_guild_emojis_update(self, guild, before, after):

        if len(before) > len(after):
            
            try:
                async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.emoji_delete):
                    if entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                      
                        if entry.user.id in self.whitelist:
                            return
                            
                        await self.handle_
                      
                        await self.handle_violation(guild, entry.user, "emoji_delete_limit")
                        break
            except discord.HTTPException:
                pass

    @commands.Cog.listener()
    async def on_guild_integrations_update(self, guild):
   
    
        try:
            async for entry in guild.audit_logs(limit=1, action=discord.AuditLogAction.bot_add):
                if entry.created_at.timestamp() > datetime.now().timestamp() - 5:
                    
                    if entry.user.id in self.whitelist:
                        return
                        
                    await self.handle_violation(guild, entry.user, "bot_add_limit")
                    break
        except discord.HTTPException:
            pass

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.guild:  
            return           
        if message.author.bot or not message.guild:
            return
            
        if message.author.id in self.whitelist:
            return
            
        if len(message.mentions) + len(message.role_mentions) >= 5:
           
            await self.handle_violation(message.guild, message.author, "mass_mention_limit")

    @commands.command(name="addwhitelist")
    @commands.has_permissions(administrator=True)
    async def add_whitelist(self, ctx, user: discord.Member):
       
        self.whitelist.add(user.id)
        await ctx.send(f"✅ Added {user.mention} to the anti-nuke whitelist")

    @commands.command(name="removewhitelist")
    @commands.has_permissions(administrator=True)
    async def remove_whitelist(self, ctx, user: discord.Member):
     
        if user.id in self.whitelist:
            self.whitelist.remove(user.id)
            await ctx.send(f"✅ Removed {user.mention} from the anti-nuke whitelist")
        else:
            await ctx.send(f"❌ {user.mention} is not in the whitelist")

    @commands.command(name="listwhitelist")
    @commands.has_permissions(administrator=True)
    async def list_whitelist(self, ctx):
       
        if not self.whitelist:
            await ctx.send("No users in the whitelist")
            return
            
        users = []
        for user_id in self.whitelist:
            user = ctx.guild.get_member(user_id)
            if user:
                users.append(f"{user.mention} (ID: {user.id})")
            else:
                users.append(f"Unknown User (ID: {user_id})")
                
        embed = discord.Embed(
            title="Anti-Nuke Whitelist",
            description="\n".join(users) or "No users found",
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed)

    @commands.command(name="resetviolations")
    @commands.has_permissions(administrator=True)
    async def reset_violations(self, ctx, user: discord.Member = None):
      
        if user:
            
            if ctx.guild.id in self.violation_counts and user.id in self.violation_counts[ctx.guild.id]:
                self.violation_counts[ctx.guild.id][user.id] = {}
                await ctx.send(f"✅ Reset violation counts for {user.mention}")
            else:
                await ctx.send(f"No violation counts found for {user.mention}")
        else:
            
            if ctx.guild.id in self.violation_counts:
                self.violation_counts[ctx.guild.id] = {}
                await ctx.send("✅ Reset all violation counts for this server")
            else:
                await ctx.send("No violation counts found for this server")

    @commands.command(name="antinukestatus")
    @commands.has_permissions(administrator=True)
    async def antinuke_status(self, ctx):
      
        guild_id = ctx.guild.id
        
        embed = discord.Embed(
            title="🛡️ Anti-Nuke System Status",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        settings = self.settings.get(guild_id, {})
        settings_text = "\n".join(
            f"{k.replace('_', ' ').title()}: {'✅' if v else '❌'}"
            for k, v in settings.items()
        ) or "No settings configured"
        embed.add_field(name="Protection Settings", value=settings_text, inline=False)
        
        thresholds = self.thresholds.get(guild_id, self.thresholds)
        thresholds_text = "\n".join(
            f"{k.replace('_', ' ').title()}: {v}"
            for k, v in thresholds.items()
        )
        embed.add_field(name="Action Thresholds", value=thresholds_text, inline=False)
        
        alert_channel_id = self.alert_channels.get(guild_id)
        alert_channel = ctx.guild.get_channel(alert_channel_id) if alert_channel_id else None
        embed.add_field(
            name="Alert Channel", 
            value=alert_channel.mention if alert_channel else "Not set",
            inline=False
        )
        
        whitelist_count = sum(1 for user_id in self.whitelist if ctx.guild.get_member(user_id))
        embed.add_field(name="Whitelisted Users", value=str(whitelist_count), inline=True)
        
        protected_roles_count = sum(1 for role_id in self.protected_roles if ctx.guild.get_role(role_id))
        embed.add_field(name="Protected Roles", value=str(protected_roles_count), inline=True)
        
        violations_count = 0
        if guild_id in self.violation_counts:
            for user_id, violations in self.violation_counts[guild_id].items():
                violations_count += sum(1 for v in violations.values() if v > 0)
        embed.add_field(name="Active Violations", value=str(violations_count), inline=True)
        
        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")
        await ctx.send(embed=embed)

class ResetConfirmationView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=None)
        self.antinuke = antinuke_system

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild_id = interaction.guild_id
        self.antinuke.settings[guild_id] = {}  
        self.antinuke.violation_counts[guild_id] = {}  
        
        embed = discord.Embed(
            title="🔄 Settings Reset",
            description="All anti-nuke settings have been reset to default.",
            color=discord.Color.green()
        )
        await interaction.response.edit_message(embed=embed, view=None)

class AntiNukeView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=None)
        self.antinuke = antinuke_system

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user.guild_permissions.administrator
    
    @discord.ui.button(label="Quick Setup", style=discord.ButtonStyle.green, row=0)
    async def quick_setup(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild_id = interaction.guild_id
        default_settings = {
            "ban_protection": True,
            "channel_protection": True,
            "role_protection": True,
            "webhook_protection": True,
            "bot_protection": True
        }
        self.antinuke.settings[guild_id] = default_settings
        
        embed = discord.Embed(
            title="✅ Quick Setup Complete",
            description="Anti-Nuke protection has been enabled with recommended settings:",
            color=discord.Color.green()
        )
        
        for protection, status in default_settings.items():
            embed.add_field(
                name=protection.replace('_', ' ').title(),
                value="✅ Enabled" if status else "❌ Disabled",
                inline=True
            )
        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")
        await interaction.response.edit_message(embed=embed, view=self)
        
    @discord.ui.button(label="Advanced Settings", style=discord.ButtonStyle.blurple, row=0)
    async def advanced_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="⚙️ Advanced Anti-Nuke Settings",
            description="Configure detailed protection settings",
            color=discord.Color.blue()
        )
        
        settings_view = AdvancedSettingsView(self.antinuke)

        for threshold, value in self.antinuke.thresholds.items():
            embed.add_field(
                name=str(threshold).replace('_', ' ').title(),
                value=f"Limit: {value}",
                inline=True
            )
            
        guild_settings = self.antinuke.settings.get(interaction.guild_id, {})
        status_text = "\n".join(f"{protection}: {'✅' if enabled else '❌'}"
                               for protection, enabled in guild_settings.items())

        if status_text:
            embed.add_field(name="Current Protections", value=status_text, inline=False)

        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")
        await interaction.response.edit_message(embed=embed, view=settings_view)
        
    @discord.ui.button(label="Set Limits", style=discord.ButtonStyle.secondary, row=0)
    async def set_limits(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="🔒 Anti-Nuke Limits Configuration",
            description="Set action limits for server protection",
            color=discord.Color.gold()
        )
        
        limits_view = LimitsSettingsView(self.antinuke)
        current_limits = self.antinuke.thresholds.get(interaction.guild_id, {
            "ban_limit": 3,
            "kick_limit": 5,
            "channel_limit": 2,
            "role_limit": 2,
            "webhook_limit": 3
        })

        for limit_name, value in current_limits.items():
            embed.add_field(
                name=limit_name.replace('_', ' ').title(),
                value=f"Current: {value}",
                inline=True
            )
        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")
        await interaction.response.edit_message(embed=embed, view=limits_view)
        
    @discord.ui.button(label="Reset Settings", style=discord.ButtonStyle.danger, row=0)
    async def reset_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        confirm_view = AntiNukeConfirmView(self.antinuke)
        embed = discord.Embed(
            title="⚠️ Confirm Reset",
            description="Are you sure you want to reset all anti-nuke settings?",
            color=discord.Color.orange()
        )
        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")
        await interaction.response.edit_message(embed=embed, view=confirm_view)
    
class LimitsSettingsView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=180)
        self.antinuke = antinuke_system
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user.guild_permissions.administrator

    @discord.ui.button(label="Ban Limit", style=discord.ButtonStyle.secondary, row=0)
    async def ban_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(LimitModal("Ban Limit", self.antinuke))

    @discord.ui.button(label="Kick Limit", style=discord.ButtonStyle.secondary, row=0)
    async def kick_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(LimitModal("Kick Limit", self.antinuke))

    @discord.ui.button(label="Channel Limit", style=discord.ButtonStyle.secondary, row=1)
    async def channel_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(LimitModal("Channel Limit", self.antinuke))

    @discord.ui.button(label="Role Limit", style=discord.ButtonStyle.secondary, row=1)
    async def role_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(LimitModal("Role Limit", self.antinuke))

    @discord.ui.button(label="Webhook Limit", style=discord.ButtonStyle.secondary, row=1)
    async def webhook_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(LimitModal("Webhook Limit", self.antinuke))

    @discord.ui.button(label="Back", style=discord.ButtonStyle.danger, row=2)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        main_view = AntiNukeView(self.antinuke)
        await interaction.response.edit_message(view=main_view)

class LimitModal(discord.ui.Modal, title="Set Limit"):
    def __init__(self, limit_type, antinuke_system):
        super().__init__()
        self.limit_type = limit_type
        self.antinuke = antinuke_system
        
        self.limit = discord.ui.TextInput(
            label=f"Enter new {limit_type.lower()}",
            placeholder="Enter a number between 1-10",
            min_length=1,
            max_length=2
        )
        self.add_item(self.limit)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            value = int(self.limit.value)
            if 1 <= value <= 10:
                
                if interaction.guild_id not in self.antinuke.thresholds:
                    self.antinuke.thresholds[interaction.guild_id] = {
                        "ban_limit": 3,
                        "kick_limit": 5,
                        "channel_limit": 2,
                        "role_limit": 2,
                        "webhook_limit": 3
                    }
                
                limit_key = f"{self.limit_type.lower().replace(' ', '_')}"
                self.antinuke.thresholds[interaction.guild_id][limit_key] = value
                await interaction.response.send_message(f"✅ {self.limit_type} set to {value}", ephemeral=True)
            else:
                await interaction.response.send_message("❌ Please enter a number between 1-10", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ Please enter a valid number", ephemeral=True)

class AdvancedSettingsView(discord.ui.View):
    def __init__(self, antinuke_system):
        super().__init__(timeout=None)
        self.antinuke = antinuke_system

    @discord.ui.button(label="Protection Settings", style=discord.ButtonStyle.green)
    async def protection_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="🛡️ Protection Settings",
            description="Configure individual protection features",
            color=discord.Color.blue()
        )
        protection_view = ProtectionToggleView(self.antinuke)
        await interaction.response.edit_message(embed=embed, view=protection_view)

    @discord.ui.button(label="Primary Thresholds", style=discord.ButtonStyle.blurple)
    async def threshold_settings_1(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = ThresholdSettingsModal1(self.antinuke)
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Secondary Thresholds", style=discord.ButtonStyle.blurple)
    async def threshold_settings_2(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = ThresholdSettingsModal2(self.antinuke)
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Whitelist Management", style=discord.ButtonStyle.grey)
    async def whitelist_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="⭐ Whitelist Management",
            description="Add or remove users/roles from whitelist",
            color=discord.Color.gold()
        )
        whitelist_view = WhitelistManagementView(self.antinuke)
        await interaction.response.edit_message(embed=embed, view=whitelist_view)

    @discord.ui.button(label="Back", style=discord.ButtonStyle.red)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        main_view = AntiNukeView(self.antinuke)
        embed = discord.Embed(
            title="🛡️ Anti-Nuke Control Panel",
            description="Configure protection settings using the buttons below",
            color=discord.Color.red()
        )
        embed.set_footer(text="© ZygnalBot Anti-Nuke System | Created by TheZ")
        await interaction.response.edit_message(embed=embed, view=main_view)

class ClearChannel(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.auto_clear_tasks = {}  
        self.enabled = True
        self.default_duration = "7d"
        self.max_duration = "30d"
        self.excluded_channels = {}
        self.log_channel = {}
        self.active_clear_tasks = {}  
        
    def get_task_key(self, guild_id, channel_id):
        return f"{guild_id}_{channel_id}"

    def cog_unload(self):
        for task, _ in self.auto_clear_tasks.values():
            task.cancel()

    async def clear_channel_periodic(self, channel, interval):
        while True:
            try:
                await channel.purge(limit=None)
                await asyncio.sleep(interval)
            except Exception as e:
                print(f"Error in periodic clear for {channel.name}: {e}")
                break

    @commands.command(name="clear_channel")
    @commands.has_permissions(manage_messages=True)
    async def clear_channel(self, ctx, channel: typing.Optional[discord.TextChannel] = None, time_str: str = None):
        channel = channel or ctx.channel
        task_key = self.get_task_key(ctx.guild.id, channel.id)

        if not channel and not time_str:
            status = "Active auto-clear channels:\n"
            if not self.auto_clear_tasks:
                await ctx.send("No active auto-clear channels.")
                return
            
            for key, (task, interval) in self.auto_clear_tasks.items():
                guild_id, chan_id = key.split('_')
                if guild_id == str(ctx.guild.id):
                    chan = self.bot.get_channel(int(chan_id))
                    if chan:
                        status += f"#{chan.name}: Every {self.active_clear_tasks.get(key, 'unknown')} ({interval} seconds)\n"
            await ctx.send(status)
            return

        if channel and not time_str:
            if task_key in self.auto_clear_tasks:
                task, _ = self.auto_clear_tasks[task_key]
                task.cancel()
                del self.auto_clear_tasks[task_key]
                if task_key in self.active_clear_tasks:
                    del self.active_clear_tasks[task_key]
                await ctx.send(f"Disabled auto-clear for {channel.mention}")
            else:
                await ctx.send(f"Auto-clear was not enabled for {channel.mention}")
            return

        time_pattern = re.compile(r'(\d+)([dhms])')
        match = time_pattern.findall(time_str)
        
        if not match:
            await ctx.send("Invalid time format. Use format like: 10s, 1m, 1h")
            return

        total_seconds = 0
        for value, unit in match:
            value = int(value)
            if unit == 'd':
                total_seconds += value * 86400
            elif unit == 'h':
                total_seconds += value * 3600
            elif unit == 'm':
                total_seconds += value * 60
            elif unit == 's':
                total_seconds += value

        if task_key in self.auto_clear_tasks:
            old_task, _ = self.auto_clear_tasks[task_key]
            old_task.cancel()

        task = self.bot.loop.create_task(self.clear_channel_periodic(channel, total_seconds))
        self.auto_clear_tasks[task_key] = (task, total_seconds)
        self.active_clear_tasks[task_key] = time_str
        
        await ctx.send(f"Enabled auto-clear for {channel.mention} every {time_str}")


class RiotGamesAPI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.api_key = os.getenv('RIOT_API_KEY')
        self.regions = ["na1", "euw1", "eun1", "kr", "jp1", "br1", "oc1", "ru", "tr1", "la1", "la2"]
        
    @commands.group(invoke_without_command=True)
    async def lol(self, ctx):
        
        embed = discord.Embed(title="League of Legends Commands", color=discord.Color.blue())
        embed.add_field(name="!lol profile [region] [summoner]", value="Get summoner profile info", inline=False)
        embed.add_field(name="!lol mastery [region] [summoner]", value="Get champion mastery", inline=False)
        embed.add_field(name="!lol match [region] [summoner]", value="Get recent matches", inline=False)
        embed.add_field(name="!lol live [region] [summoner]", value="Get live game info", inline=False)
        embed.add_field(name="Regions: ", value="na1, euw1, eun1, kr, jp1, br1, oc1, ru, tr1, la1, la2", inline=False)
        await ctx.send(embed=embed)

    @commands.group(invoke_without_command=True) 
    async def val(self, ctx):
        
        embed = discord.Embed(title="VALORANT Commands", color=discord.Color.red())
        embed.add_field(name="!val profile [region] [name#tag]", value="Get player profile", inline=False)
        embed.add_field(name="!val matches [region] [name#tag]", value="Get match history", inline=False)
        embed.add_field(name="!val leaderboard [region]", value="Get ranked leaderboard", inline=False)
        embed.add_field(name="Regions: ", value="na1, euw1, eun1, kr, jp1, br1, oc1, ru, tr1, la1, la2", inline=False)
        await ctx.send(embed=embed)

    @commands.group(invoke_without_command=True)
    async def tft(self, ctx):
        
        embed = discord.Embed(title="Teamfight Tactics Commands", color=discord.Color.gold())
        embed.add_field(name="!tft profile [region] [summoner]", value="Get TFT profile", inline=False)
        embed.add_field(name="!tft matches [region] [summoner]", value="Get TFT match history", inline=False)
        embed.add_field(name="Regions: ", value="na1, euw1, eun1, kr, jp1, br1, oc1, ru, tr1, la1, la2", inline=False)
        await ctx.send(embed=embed)

    async def fetch_summoner_data(self, region, summoner_name):
        
        url = f"https://{region}.api.riotgames.com/lol/summoner/v4/summoners/by-name/{summoner_name}"
        headers = {"X-Riot-Token": self.api_key}
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                return await response.json() if response.status == 200 else None

    @lol.command(name="profile")
    async def lol_profile(self, ctx, region: str, *, summoner_name: str):
        
        if region.lower() not in self.regions:
            await ctx.send("Invalid region! Available regions: " + ", ".join(self.regions))
            return

        data = await self.fetch_summoner_data(region, summoner_name)
        if not data:
            await ctx.send("Summoner not found!")
            return

        embed = discord.Embed(title=f"Profile: {data['name']}", color=discord.Color.blue())
        embed.add_field(name="Level", value=data['summonerLevel'])
        embed.set_thumbnail(url=f"http://ddragon.leagueoflegends.com/cdn/11.24.1/img/profileicon/{data['profileIconId']}.png")
        await ctx.send(embed=embed)


class TrollFriend(commands.Cog):
    def __init__(self, bot, target_user_id):
        self.bot = bot
        self.target_user_id = target_user_id

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.id == self.target_user_id and message.content.lower() == "yes":
            await message.channel.send("What are you Talkin about? you little brat")
        if message.guild:  
            return   


class JackCoinsSystem:
    def __init__(self):
        self.balances = {}
        self.starting_amount = 1000
        self.credit_limit = -5000  
        
    def get_balance(self, user_id: int) -> int:
        if user_id not in self.balances:
            self.balances[user_id] = self.starting_amount
        return self.balances[user_id]
        
    def can_place_bet(self, user_id: int, amount: int) -> bool:
        current_balance = self.get_balance(user_id)
        return (current_balance - amount) >= self.credit_limit
        
    def add_coins(self, user_id: int, amount: int):
        if user_id not in self.balances:
            self.balances[user_id] = self.starting_amount
        self.balances[user_id] += amount
        
    def remove_coins(self, user_id: int, amount: int) -> bool:
        if user_id not in self.balances:
            self.balances[user_id] = self.starting_amount
        if (self.balances[user_id] - amount) < self.credit_limit:
            return False
        self.balances[user_id] -= amount
        return True

class JoinBlackjackView(discord.ui.View):
    def __init__(self, host, coins_system):
        super().__init__(timeout=30)
        self.host = host
        self.players = {host: {"ready": True, "bet": 0}}
        self.coins_system = coins_system
        self.min_bet = 50
        self.max_bet = 25000

    @discord.ui.button(label="Join Game", style=ButtonStyle.success, emoji="🃏")
    async def join(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user not in self.players:
            self.players[interaction.user] = {"ready": False, "bet": 0}
            await interaction.response.send_message(
                f"You joined {self.host.name}'s Blackjack game! Your balance: {self.coins_system.get_balance(interaction.user.id)} JackCoins\n"
                f"Click the Place Bet button to place your bet (Min: {self.min_bet}, Max: {self.max_bet})",
                ephemeral=True
            )

    @discord.ui.button(label="Place Bet", style=ButtonStyle.secondary, emoji="🪙")
    async def place_bet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user not in self.players:
            await interaction.response.send_message("You need to join the game first!", ephemeral=True)
            return

        modal = BetModal(self.min_bet, self.max_bet)
        await interaction.response.send_modal(modal)
        await modal.wait()
        
        if modal.bet_amount:
            if self.coins_system.can_place_bet(interaction.user.id, modal.bet_amount):
                self.players[interaction.user]["bet"] = modal.bet_amount
                self.players[interaction.user]["ready"] = True
                await interaction.followup.send(
                    f"Bet placed: {modal.bet_amount} JackCoins",
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    f"Insufficient JackCoins! Your balance: {self.coins_system.get_balance(interaction.user.id)} 🪙",
                    ephemeral=True
                )

    @discord.ui.button(label="Start Game", style=ButtonStyle.primary, emoji="▶️")
    async def start(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user == self.host:
            if all(player["ready"] for player in self.players.values()):
                for player, data in self.players.items():
                    self.coins_system.remove_coins(player.id, data["bet"])
                self.stop()
            else:
                await interaction.response.send_message(
                    "Not all players have placed their bets!",
                    ephemeral=True
                )
        else:
            await interaction.response.send_message(
                "Only the host can start the game!",
                ephemeral=True
            )

class BlackjackView(discord.ui.View):
    def __init__(self, player):
        super().__init__(timeout=30)
        self.player = player
        self.value = None  
        self.update_buttons()

    def update_buttons(self):
        self.hit.disabled = False
        self.stand.disabled = False
        self.double.disabled = False

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.player:
            await interaction.response.send_message("Not your turn!", ephemeral=True)
            return False
        return True

    @discord.ui.button(label="Hit", style=ButtonStyle.success, emoji="👊", row=0)
    async def hit(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.interaction_check(interaction):
            return
        self.value = "hit"
        self.stop()

    @discord.ui.button(label="Stand", style=ButtonStyle.danger, emoji="🛑", row=0)
    async def stand(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.interaction_check(interaction):
            return
        self.value = "stand"
        self.stop()

    @discord.ui.button(label="Double Down", style=ButtonStyle.primary, emoji="💰", row=0)
    async def double(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.interaction_check(interaction):
            return
        self.value = "double"
        self.stop()

class BlackjackGame(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.coins = JackCoinsSystem()
        self.minimum_bet = 50
        self.maximum_bet = 10000
        self.active_games = {}
        self.card_values = {
            'A': 11, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
            '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10
        }
        self.suits = ['♠️', '♥️', '♦️', '♣️']
        self.ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']

    def get_new_deck(self):
        deck = []
        for suit in self.suits:
            for rank in self.ranks:
                deck.append({'suit': suit, 'value': rank})
        random.shuffle(deck)
        return deck

    def draw_cards(self, deck, count=1):
        return [deck.pop() for _ in range(count)]

    def calculate_hand(self, cards):
        value = 0
        aces = 0
        for card in cards:
            if card['value'] == 'A':
                aces += 1
            else:
                value += self.card_values[card['value']]
        for _ in range(aces):
            if value + 11 <= 21:
                value += 11
            else:
                value += 1
        return value

    @commands.command()
    async def jackadd(self, ctx, user: discord.Member, amount: int):
        if ctx.author.id != 1284210833869639680:
            await ctx.send("🚫 Nice try!")
            return
            
        self.coins.add_coins(user.id, amount)
        await ctx.send(f"💰 Added {amount} JackCoins to {user.mention}'s balance\nNew balance: {self.coins.get_balance(user.id)} 🪙")

    @commands.command()
    async def jackbalance(self, ctx):
        balance = self.coins.get_balance(ctx.author.id)
        credit_limit = self.coins.credit_limit
        
        embed = discord.Embed(title="🎰 JackCoins Balance", color=discord.Color.gold())
        embed.add_field(name="Current Balance", value=f"{balance} JackCoins 🪙")
        embed.add_field(name="Credit Limit", value=f"{credit_limit} JackCoins 🪙")
        embed.add_field(name="Available Credit", value=f"{balance - credit_limit} JackCoins 🪙", inline=False)
        
        if balance < 0:
            embed.add_field(name="Debt Status", value="🔴 In Debt", inline=False)
        else:
            embed.add_field(name="Debt Status", value="🟢 Good Standing", inline=False)
            
        embed.set_footer(text="Use !blackjack to play and win more JackCoins!")
        
        await ctx.send(embed=embed)

    def create_game_embed(self, players_data, dealer_cards, current_player=None, hide_dealer=True):
        embed = discord.Embed(title="🎰 Blackjack Game", color=discord.Color.gold())
        
        dealer_value = self.calculate_hand(dealer_cards if not hide_dealer else [dealer_cards[0]])
        dealer_cards_str = f"{dealer_cards[0]['value']}{dealer_cards[0]['suit']}"
        if hide_dealer:
            dealer_cards_str += "\n🎴 [Hidden Card]"
        else:
            dealer_cards_str += "\n" + "\n".join(f"{card['value']}{card['suit']}" for card in dealer_cards[1:])
        embed.add_field(name=f"Dealer's Hand ({dealer_value if not hide_dealer else '?'})", 
                       value=dealer_cards_str, inline=False)

        for player, data in players_data.items():
            is_current = "🎮 Current Turn" if player.id == current_player else ""
            value = self.calculate_hand(data['cards'])
            cards_str = "\n".join(f"{card['value']}{card['suit']}" for card in data['cards'])
            embed.add_field(name=f"{player.name}'s Hand ({value}) {is_current}", 
                          value=cards_str, inline=False)
        return embed

    @commands.command(name="blackjack", aliases=["bj"])
    async def blackjack(self, ctx, bet: int = 100, multiplayer: bool = False):

        if ctx.channel.id in self.active_games:
            await ctx.send("A game is already in progress in this channel!")
            return

        if not self.coins.can_place_bet(ctx.author.id, bet):
            await ctx.send(f"Insufficient JackCoins! Your balance: {self.coins.get_balance(ctx.author.id)} 🪙")
            return

        if bet < self.minimum_bet:
            await ctx.send(f"Minimum bet is {self.minimum_bet} JackCoins!")
            return

        if bet > self.maximum_bet:
            await ctx.send(f"Maximum bet is {self.maximum_bet} JackCoins!")
            return

        self.coins.remove_coins(ctx.author.id, bet)

        deck = self.get_new_deck()
        dealer_cards = self.draw_cards(deck, 2)
        player_cards = self.draw_cards(deck, 2)

        self.active_games[ctx.channel.id] = {
            'deck': deck,
            'players': {ctx.author: {'cards': player_cards, 'bet': bet}},
            'dealer_cards': dealer_cards,
            'current_player': ctx.author.id
        }

        if multiplayer:
            view = JoinBlackjackView(ctx.author, self.coins)
            view.players[ctx.author]["bet"] = bet
            view.players[ctx.author]["ready"] = True
            await ctx.send("Starting a multiplayer Blackjack game! Click to join:", view=view)
            await view.wait()
            
            for player in view.players:
                if player != ctx.author:
                    if self.coins.can_place_bet(player.id, bet):
                        self.coins.remove_coins(player.id, bet)
                        player_cards = self.draw_cards(deck, 2)
                        self.active_games[ctx.channel.id]['players'][player] = {
                            'cards': player_cards,
                            'bet': bet,
                            'ready': True
                        }
                        view.players[player]["ready"] = True
                        view.players[player]["bet"] = bet
                    else:
                        await ctx.send(f"{player.mention} doesn't have enough JackCoins to join!")


        embed = self.create_game_embed(
            self.active_games[ctx.channel.id]['players'],
            dealer_cards,
            ctx.author.id
        )
        await ctx.send(embed=embed)

        for player, data in self.active_games[ctx.channel.id]['players'].items():
            self.active_games[ctx.channel.id]['current_player'] = player.id
            
            while True:
                view = BlackjackView(player.id)
                action_message = await ctx.send(f"{player.mention}'s turn! Choose your action:", view=view)
                await view.wait()
                
                if view.value == "hit":
                    new_card = self.draw_cards(deck, 1)[0]
                    data['cards'].append(new_card)
                    if self.calculate_hand(data['cards']) > 21:
                        break
                elif view.value == "stand":
                    break
                elif view.value == "double":
                    if self.coins.can_place_bet(player.id, data['bet']):
                        self.coins.remove_coins(player.id, data['bet'])
                        new_card = self.draw_cards(deck, 1)[0]
                        data['cards'].append(new_card)
                        data['bet'] *= 2
                        break
                    else:
                        await ctx.send(f"{player.mention} doesn't have enough JackCoins to double down!")
                        continue
                
                await action_message.delete()
                embed = self.create_game_embed(
                    self.active_games[ctx.channel.id]['players'],
                    dealer_cards,
                    player.id
                )
                await ctx.send(embed=embed)

        dealer_value = self.calculate_hand(dealer_cards)
        while dealer_value < 17:
            new_card = self.draw_cards(deck, 1)[0]
            dealer_cards.append(new_card)
            dealer_value = self.calculate_hand(dealer_cards)

        final_embed = self.create_game_embed(
            self.active_games[ctx.channel.id]['players'],
            dealer_cards,
            hide_dealer=False
        )
        await ctx.send("Game Over! Final hands:", embed=final_embed)

        dealer_value = self.calculate_hand(dealer_cards)
        results = []
        for player, data in self.active_games[ctx.channel.id]['players'].items():
            player_value = self.calculate_hand(data['cards'])
            bet = data['bet']
            
            if player_value > 21:
                result = f"{player.mention} Bust! Lost {bet} JackCoins 🪙"
            elif dealer_value > 21:
                payout = bet * 2
                self.coins.add_coins(player.id, payout)
                result = f"{player.mention} Won {payout} JackCoins 🪙 (Dealer bust)"
            elif player_value > dealer_value:
                payout = bet * 2
                self.coins.add_coins(player.id, payout)
                result = f"{player.mention} Won {payout} JackCoins 🪙"
            elif player_value < dealer_value:
                result = f"{player.mention} Lost {bet} JackCoins 🪙"
            else:
                self.coins.add_coins(player.id, bet)  
                result = f"{player.mention} Push! (Tie) - Bet returned"
            
            results.append(result)

        await ctx.send("\n".join(results))
        del self.active_games[ctx.channel.id]

    @commands.command()
    async def jacktransfer(self, ctx, recipient: discord.Member, amount: int):
        if amount <= 0:
            await ctx.send("Transfer amount must be positive!")
            return
            
        sender_balance = self.coins.get_balance(ctx.author.id)
        if sender_balance < amount:
            await ctx.send(f"Insufficient funds! Your balance: {sender_balance} JackCoins 🪙")
            return
            
        self.coins.remove_coins(ctx.author.id, amount)
        self.coins.add_coins(recipient.id, amount)
        
        embed = discord.Embed(title="💸 JackCoins Transfer", color=discord.Color.green())
        embed.add_field(name="From", value=ctx.author.mention)
        embed.add_field(name="To", value=recipient.mention)
        embed.add_field(name="Amount", value=f"{amount} JackCoins 🪙", inline=False)
        embed.add_field(name="New Balance", value=f"{self.coins.get_balance(ctx.author.id)} JackCoins 🪙")
        
        await ctx.send(embed=embed)


class BetModal(discord.ui.Modal, title="Place Your Bet"):
    bet_amount = discord.ui.TextInput(
        label="Bet Amount",
        placeholder="Enter bet amount...",
        min_length=1,
        max_length=6
    )

    def __init__(self, min_bet: int, max_bet: int):
        super().__init__()
        self.min_bet = min_bet
        self.max_bet = max_bet

    async def on_submit(self, interaction: discord.Interaction):
        try:
            amount = int(self.bet_amount.value)
            if self.min_bet <= amount <= self.max_bet:
                self.bet_amount = amount
                await interaction.response.send_message(f"Processing bet: {amount} JackCoins", ephemeral=True)
            else:
                await interaction.response.send_message(
                    f"Bet must be between {self.min_bet} and {self.max_bet} JackCoins", 
                    ephemeral=True
                )
                self.bet_amount = None
        except ValueError:
            await interaction.response.send_message("Please enter a valid number", ephemeral=True)
            self.bet_amount = None


class TeamFightCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
        self.combat_moves = [
            ("unleashed a devastating combo on", 25),
            ("performed an epic double takedown on", 30),
            ("executed a perfect team attack against", 35),
            ("coordinated a brutal pincer attack on", 40),
            ("pulled off an anime-style team finisher on", 45),
            ("hit with the power of friendship against", 50),
            ("performed a tag-team wrestling move on", 35),
            ("executed the legendary duo combo on", 40),
            ("channeled their combined RGB gaming power against", 45)
        ]
        
        self.defense_moves = [
            ("managed to block the team attack with pure gaming skill!", 15),
            ("activated their anti-gank protection shield!", 20),
            ("pulled off a 200IQ dodge against both attackers!", 25),
            ("used their gaming chair's special defense mode!", 30),
            ("activated their trap card against the duo!", 35)
        ]
        
        self.fail_moves = [
            "tripped over each other trying to coordinate an attack!",
            "accidentally hit their teammate instead of the target!",
            "got their attack patterns mixed up like a failed SQL query!",
            "crashed into each other like two Chrome tabs fighting for RAM!",
            "forgot who they were supposed to attack and hit a random NPC!"
        ]
        
        self.random_events = [
            "A sudden power surge boosts the team's attack power!",
            "A mysterious glitch causes the solo player to deal double damage this round!",
            "The battlefield begins to shake—everyone takes 10 damage from the instability!",
            "The solo player taps into a hidden power, reducing incoming damage by 20%!"
        ]

    @commands.command(name="2v1fight")
    async def team_fight(self, ctx, teammate: discord.Member, target: discord.Member):
        
        
        if teammate.id == ctx.author.id or teammate.id == target.id or target.id == ctx.author.id:
            embed = discord.Embed(
                title="🎮 Team Fight Error!",
                description="You can't fight yourself or use the same person twice!",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            return

        team_health = 200
        target_health = 150
        round_count = 1
        
        embed = discord.Embed(
            title="⚔️ EPIC 2V1 BATTLE INITIATED! ⚔️",
            description=f"{ctx.author.mention} and {teammate.mention} challenge {target.mention} to a legendary fight!\n\n*Loading battle.exe...*",
            color=discord.Color.gold()
        )
        embed.add_field(name="🤝 Team HP", value=f"{team_health}/200", inline=True)
        embed.add_field(name=f"🎯 {target.name}'s HP", value=f"{target_health}/150", inline=True)
        
        battle_msg = await ctx.send(embed=embed)

        while team_health > 0 and target_health > 0 and round_count <= 10:
            
            event = random.choice(self.random_events) if random.random() < 0.2 else None
            
            embed = discord.Embed(
                title=f"Round {round_count} - Team Attack Phase!",
                description="*Calculating team damage...*",
                color=discord.Color.blue()
            )
            if event:
                embed.add_field(name="🔮 Random Event!", value=event, inline=False)
            await battle_msg.edit(embed=embed)
            await asyncio.sleep(2.5)

            if random.random() > 0.2:
                move, damage = random.choice(self.combat_moves)
                target_health -= damage
                action = f"💥 **TEAM ATTACK!**\n\n{ctx.author.name} and {teammate.name} {move} {target.name}!\n\n**Damage Dealt:** {damage} HP"
            else:
                action = f"❌ **TEAM FAIL!**\n\n{ctx.author.name} and {teammate.name} {random.choice(self.fail_moves)}\n\n**Self-Damage:** 15 HP"
                team_health -= 15

            embed = discord.Embed(
                title=f"Round {round_count} - Team Attack Results",
                description=action,
                color=discord.Color.blue()
            )
            embed.add_field(name="🤝 Team HP", value=f"{max(0, team_health)}/200", inline=True)
            embed.add_field(name=f"🎯 {target.name}'s HP", value=f"{max(0, target_health)}/150", inline=True)
            embed.set_footer(text="Next round in 2.5 seconds...")
            await battle_msg.edit(embed=embed)
            await asyncio.sleep(2.5)

            if target_health <= 0:
                break

            embed = discord.Embed(
                title=f"Round {round_count} - Solo Counter Phase!",
                description="*Calculating counter-attack...*",
                color=discord.Color.red()
            )
            await battle_msg.edit(embed=embed)
            await asyncio.sleep(2.5)

            if random.random() > 0.3:
                move, damage = random.choice(self.combat_moves)
                team_health -= damage
                action = f"💥 **SOLO COUNTER-ATTACK!**\n\n{target.name} {move} the team!\n\n**Damage Dealt:** {damage} HP"
            else:
                defense, reduction = random.choice(self.defense_moves)
                action = f"🛡️ **SOLO DEFENSE!**\n\n{target.name} {defense}\n\n**HP Recovered:** {reduction}"
                target_health += reduction

            embed = discord.Embed(
                title=f"Round {round_count} - Solo Counter Results",
                description=action,
                color=discord.Color.red()
            )
            embed.add_field(name="🤝 Team HP", value=f"{max(0, team_health)}/200", inline=True)
            embed.add_field(name=f"🎯 {target.name}'s HP", value=f"{max(0, target_health)}/150", inline=True)
            embed.set_footer(text="Next round in 2.5 seconds...")
            await battle_msg.edit(embed=embed)
            await asyncio.sleep(2.5)

            round_count += 1

        if team_health <= 0:
            winner = target
            loser_text = f"{ctx.author.mention} and {teammate.mention}"
            win_message = f"🏆 {winner.mention} survived the 2v1 and proved that solo queue is the way!"
        else:
            winner = "team"
            loser_text = target.mention
            win_message = f"🏆 {ctx.author.mention} and {teammate.mention} successfully ganked {target.mention}!"

        endings = [
            f"{win_message}\n*{loser_text} should've bought more gaming chairs!*",
            f"{win_message}\n*{loser_text} forgot to activate their RGB lighting!*",
            f"{win_message}\n*{loser_text} had too much input lag!*",
            f"{win_message}\n*{loser_text} needs to download more RAM!*",
            f"{win_message}\n*{loser_text} should've watched more tutorials!*"
        ]

        embed = discord.Embed(
            title="🎮 BATTLE CONCLUDED! 🎮",
            description=random.choice(endings),
            color=discord.Color.gold()
        )
        embed.set_footer(text="GG EZ! (jk it was close)")
        await battle_msg.edit(embed=embed)


class ShootingCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
        self.body_parts = {
            "head": [
                "shot {} in the head but it just bounced off - must be all that thick skull! 🤕",
                "aimed for {}'s head but hit their massive ego instead 🎯",
                "headshot {} but they were too busy taking selfies to notice 📸",
                "hit {}'s head making their last two brain cells play ping pong! 🏓"
            ],
            "chest": [
                "shot {} in the chest but their RGB gaming armor deflected it! ⚔️",
                "hit {}'s chest making them spit out yesterday's Mountain Dew! 🥤",
                "shot {} right in the chest - their anime body pillow took the hit! 🛡️"
            ],
            "boobs": [
                "shot {}'s honkers making them bounce like a trampoline park! 💫",
                "hit the milk makers - {} is now a walking milkshake! 🥤",
                "aimed for the chest pillows - {} is now permanently lopsided! 😵"
            ],
            "ear": [
                "shot {}'s ear off - now they can't hear their mom calling for dinner! 👂",
                "hit {}'s ear making their AirPod do a backflip! 🎧",
                "shot {} in the ear - their gaming headset saved them! 🎮"
            ],
            "nose": [
                "shot {}'s nose making them sneeze rainbows! 🌈",
                "hit {} right in the snoot - boop! 👃",
                "shot {}'s nose making them smell colors! 🎨"
            ],
            "legs": [
                "shot {}'s legs making them dance like a TikTok star! 💃",
                "hit {}'s legs causing them to fall down 3 flights of stairs into a pool of jello 🎯",
                "shot {}'s legs but they kept running like a Minecraft character 🎮"
            ],
            "foot": [
                "shot {}'s foot making them hop like a kangaroo on caffeine! 🦘",
                "hit {}'s foot - their Crocs were in defense mode though! 👟",
                "shot {} in the toe making them do the world's longest hopscotch! 🦶"
            ],
            "knee": [
                "shot {} in the knee - no more adventuring for them! ⚔️",
                "hit {}'s knee making them do the stanky leg forever! 🕺",
                "shot {}'s knee - they're now a professional river dancer! 💃"
            ],
            "balls": [
                "shot {} right in the family jewels! They're now singing soprano in the church choir! 🎵",
                "hit {} where the sun don't shine - their voice is now higher than their IQ! 😱",
                "aimed for {}'s pride and joy - they're now considering a career as an opera singer! 🎭"
            ],
            "butt": [
                "shot {} in the behind making them bounce like a basketball! 🏀",
                "hit {}'s rear causing them to rocket-launch into space 🚀",
                "shot {}'s bottom but their thicc gaming chair protected them 💺"
            ],
            "penis": [
                "shot {}'s banana making it do a 360 no-scope! 🍌",
                "hit {}'s meat scepter - it now points to the nearest gaming store! 🎮",
                "shot {}'s little friend - it's now permanently stuck in airplane mode! ✈️"
            ],
            "thigh": [
                "shot {}'s thighs making them thicc-er than a bowl of oatmeal! 🥣",
                "hit {} right in the thunder thighs - lightning struck twice! ⚡",
                "shot {}'s thighs making them the new TikTok trend! 📱"
            ],
            "shoulder": [
                "shot {}'s shoulder making them permanently shrug! 🤷",
                "hit {}'s shoulder - their dab is now stuck in place! 💪",
                "shot {} in the shoulder blade making them a human windmill! 💫"
            ],
            "elbow": [
                "shot {}'s funny bone - they can't stop giggling! 😆",
                "hit {}'s elbow making them a professional door knocker! 💪",
                "shot {} in the elbow - they're now a human sprinkler! 💦"
            ],
            "back": [
                "shot {} in the back - they're now a human backpack! 🎒",
                "hit {}'s back making them do a perfect backflip! 🤸",
                "shot {} in the back - they're now a human turtle! 🐢",
                "hit {}'s back - they're now permanently stuck in a yoga pose! 🧘",
                "shot {} in the back - they're now a human doorstop! 🚪"
            ],
            "pussy": [
                "shot {} in the pussy - Imagine getting raped by a bullet 🪄",
                "shot {} in the pussy - Imagine getting shot in the pussy 💦",
                "shot {} in the pussy - Now that’s a real deep shot. 🎯",
                "shot {} in the pussy - That’s one way to get penetration. 💀",
                "shot {} in the pussy - Talk about a bullet vibrator. 😳",
                "shot {} in the pussy - Reloading... oh wait, no need. 💥"
            ]
        }
        
        self.special_effects = [
            "BOOM! 💥", "POW! 💫", "BANG! 💢", "KAPOW! ⚡",
            "BLAM! 🎯", "WHAM! ✨", "BAM! 💥", "POOF! 🌟",
            "KABOOM! 💫", "SWOOSH! 🌪️"
        ]
        
        self.fail_shots = [
            "tried to shoot {} but their gun was loaded with confetti! 🎉",
            "attempted to shoot {} but slipped on a banana peel! 🍌",
            "went to shoot {} but their gun turned into a water pistol! 💦",
            "tried shooting {} but their gaming chair had 100% damage reduction! 🎮",
            "attempted to shoot {} but hit their own toe instead! 🦶",
            "tried to shoot {} but their RGB setup blinded them! 🌈",
            "went for the shot but {} used the Uno reverse card! 🔄",
            "tried to shoot {} but the safety was still on! 🔒",
            "aimed at {} but got a critical hit… on themselves! 💀",
            "attempted to shoot {} but the gun jammed harder than a traffic jam! 🚗💥",
            "went to shoot {} but an ad played mid-action! ⏳",
            "tried to shoot {} but a pigeon intercepted the bullet! 🕊️",
            "attempted to shoot {} but tripped over their own shoelaces! 👟",
            "took the shot at {} but got flashbanged by the sun! ☀️",
            "tried to shoot {} but their aim is worse than a Stormtrooper’s! 🎯❌",
            "attempted a headshot on {} but accidentally quickscoped their dignity instead! 🎮",
            "tried to shoot {} but got distracted by a meme mid-action! 📱",
            "went to fire but {} used plot armor! 📜🛡️",
            "tried to shoot {} but got hit with a ‘connection lost’ error! 📡❌",
            "attempted to shoot {} but the bullet got stuck in a loading screen! ⏳",
            "tried to shoot {} but their gun license got revoked mid-shot! 🚫🔫",
            "attempted to shoot {} but the bullet refused to leave the chamber! ❌",
            "went to fire at {} but their aim is as bad as a Stormtrooper’s! 🎯❌",
            "tried to shoot {} but the gun turned into a nerf blaster! 🔵",
            "attempted to snipe {} but accidentally quickscoped a wall! 🏢",
            "went to shoot {} but got distracted by a TikTok mid-action! 📱",
            "tried shooting {} but an NPC walked in front at the last second! 🚶‍♂️",
            "attempted to shoot {} but got hit with a blue screen of death! 💻🔵",
            "went for a shot but the recoil sent them flying instead! 🚀",
            "tried to shoot {} but tripped over their own feet! 🤦‍♂️",
            "aimed at {} but ran out of ammo at the worst moment! 🔄🔫",
            "tried to shoot {} but their controller disconnected! 🎮🔌",
            "went to shoot {} but their gun was a prop from a movie set! 🎥",
            "tried to fire at {} but got hit with a lag spike! 📶",
            "attempted to shoot {} but got jump-scared mid-shot! 👻",
            "tried to shoot {} but an ad popped up! 🚫🎥",
            "went for a headshot but accidentally reloaded instead! 🔄",
            "attempted to fire at {} but the bullet curved Matrix-style! 🕶️",
            "tried to shoot {} but the gun turned into a banana! 🍌",
            "went to shoot {} but the bullet was a dud! 💨",
            "tried to take the shot but {} dodged it with anime reflexes! 🏃‍♂️",
            "attempted to shoot {} but a stray cat stole the bullet! 🐱",
            "tried to fire at {} but friendly fire was turned on! 🚫",
            "went to shoot {} but karma hit first! ⚡",
            "attempted to shoot {} but a Windows update started! 💻⏳",
            "tried to snipe {} but a bird took the bullet! 🕊️",
            "went for the killshot but {} activated God Mode! 🎮",
            "attempted to shoot {} but tripped on an invisible rock! 🪨",
            "tried to fire but {} used a smoke bomb and vanished! 🎭",
            "aimed at {} but an earthquake shook their aim! 🌍",
            "attempted to shoot {} but a dog ran in the way and they couldn't do it! 🐶",
            "went to fire but {} bribed the bullet to miss! 💰",
            "tried to shoot {} but their WiFi disconnected at the worst time! 📡",
            "attempted to shoot {} but accidentally sent a friend request instead! 📨",
            "went for the shot but {} hit them with a 'Not today' meme! 🙅‍♂️",
            "tried to fire at {} but got caught in an unskippable cutscene! 🎬",
            "attempted to shoot {} but got distracted by a fly! 🪰",
            "went to fire but their gun had negative KD and refused! 🎮",
            "tried to shoot {} but they were actually a hologram! ✨"
        ]

    @commands.command(name="shoot")
    async def shoot(self, ctx, target: discord.Member, body_part: str = None):
        
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="🎯 Self-Shoot Fail!",
                description="You tried to shoot yourself but your massive brain deflected the bullet!",
                color=discord.Color.purple()
            )
            await ctx.send(embed=embed)
            return

        if random.random() < 0.2:
            fail_message = random.choice(self.fail_shots).format(target.mention)
            embed = discord.Embed(
                title=f"{random.choice(self.special_effects)} Shot Failed!",
                description=f"{ctx.author.mention} {fail_message}",
                color=discord.Color.orange()
            )
            await ctx.send(embed=embed)
            return

        if not body_part or body_part.lower() not in self.body_parts:
            body_part = random.choice(list(self.body_parts.keys()))
        else:
            body_part = body_part.lower()

        outcome = random.choice(self.body_parts[body_part])
        
        embed = discord.Embed(
            title=f"{random.choice(self.special_effects)} Critical Hit!",
            description=f"{ctx.author.mention} {outcome.format(target.mention)}",
            color=discord.Color.red()
        )
        
        footers = [
            "No gamers were harmed in making this shot! 🎮",
            "Apply ice pack to wounded pride! 🧊",
            "That's gonna leave a mark... on their ego! 💫",
            "Shot so hard their K/D ratio felt it! 📉",
            "Their gaming chair couldn't save them this time! 💺",
            "At least they still have their RGB lights! 🌈",
            "Time to respawn and touch some grass! 🌱"
        ]
        embed.set_footer(text=random.choice(footers))
        
        await ctx.send(embed=embed)

    @commands.command(name="sniper")
    async def sniper(self, ctx, target: discord.Member):
        
        dramatic_shots = [
            f"took aim from their gaming chair and 360 no-scoped {target.mention} back to the lobby! 🎯",
            f"channeled their inner pro-gamer and sent {target.mention} straight to spectator mode! 👻",
            f"activated their RGB gaming socks and eliminated {target.mention} with style! 🌈",
            f"used their mom's credit card to buy an epic skin, then destroyed {target.mention} with pure swag! 💳",
            f"watched one YouTube tutorial and proceeded to absolutely demolish {target.mention}! 📺",
            f"cranked their gaming chair to maximum recline and obliterated {target.mention}! 💺",
            f"put on their gamer glasses and deleted {target.mention} from existence! 🕶️"
        ]
        
        embed = discord.Embed(
            title="🎯 EPIC SNIPE MOMENT!",
            description=f"{ctx.author.mention} {random.choice(dramatic_shots)}",
            color=discord.Color.gold()
        )
        embed.set_footer(text="Get rekt! 😎")
        
        await ctx.send(embed=embed)

    @commands.command(name="tactical-nuke")
    async def tactical_nuke(self, ctx, target: discord.Member):
        
        nuke_messages = [
            f"called in a tactical nuke and erased {target.mention} from the server (they respawned tho)! ☢️",
            f"went full overkill and dropped the mother of all bombs on {target.mention}'s K/D ratio! 💣",
            f"pressed Alt+F4 on {target.mention}'s existence (temporarily)! ⌨️",
            f"deleted {target.mention}.exe from the server (they had a backup)! 🗑️",
            f"used inspect element to remove {target.mention} from reality! 🌐",
            f"activated their RGB nuclear launch codes on {target.mention}! 🚀",
            f"unleashed their mom's chancla on {target.mention}! 👡"
        ]
        
        embed = discord.Embed(
            title="☢️ TACTICAL NUKE INCOMING! ☢️",
            description=f"{ctx.author.mention} {random.choice(nuke_messages)}",
            color=discord.Color.dark_red()
        )
        embed.set_footer(text="Press F to pay respects 🎮")
        
        await ctx.send(embed=embed)

class LoveCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
        self.hug_actions = [
            "gives {} the warmest bear hug ever! 🧸",
            "wraps {} in a cozy blanket hug! ✨",
            "surprise tackles {} with the biggest hug! 💫",
            "shares an epic friendship hug with {}! 🌟",
            "gives {} a super wholesome hug! 💝",
            "hugs {} like there's no tomorrow! 🎉"
        ]
        
        self.kiss_actions = [
            "plants a sweet kiss on {}'s cheek! 💖",
            "gives {} a gentle kiss! 💝",
            "surprises {} with an adorable kiss! 💫",
            "shares a wholesome kiss with {}! ✨",
            "gives {} a loving kiss! 🌸"
        ]
        
        self.love_actions = [
            "showers {} with love and affection! 💕",
            "shares their heart with {}! 💗",
            "spreads love and joy to {}! ✨",
            "makes {} feel super special! 🌟",
            "shows {} how much they care! 💝"
        ]
        
        self.cuddle_actions = [
            "snuggles up with {} for movie time! 🎬",
            "shares cozy cuddles with {}! 🧸",
            "gives {} the warmest cuddles! ✨",
            "enjoys peaceful cuddle time with {}! 💫",
            "shares wholesome cuddles with {}! 💝"
        ]
        
        self.pat_actions = [
            "gives {} gentle headpats! 🌟",
            "lovingly pats {}'s head! ✨",
            "shares encouraging pats with {}! 💫",
            "comforts {} with sweet pats! 💝",
            "gives {} supportive pats! 🎉"
        ]

    @commands.command(name="hug")
    async def hug(self, ctx, target: discord.Member):
        
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="Self-Love Hug! 🤗",
                description=f"{ctx.author.mention} wraps themselves in a cozy self-hug! Remember, you're awesome! ✨",
                color=discord.Color.pink()
            )
        else:
            action = random.choice(self.hug_actions)
            embed = discord.Embed(
                title="Wholesome Hug Time! 🤗",
                description=f"{ctx.author.mention} {action.format(target.mention)}",
                color=discord.Color.pink()
            )
        await ctx.send(embed=embed)

    @commands.command(name="kiss")
    async def kiss(self, ctx, target: discord.Member):
        
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="Self-Love Kiss! 💋",
                description=f"{ctx.author.mention} blows a kiss to their reflection! You're beautiful! ✨",
                color=discord.Color.red()
            )
        else:
            action = random.choice(self.kiss_actions)
            embed = discord.Embed(
                title="Sweet Kiss! 💋",
                description=f"{ctx.author.mention} {action.format(target.mention)}",
                color=discord.Color.red()
            )
        await ctx.send(embed=embed)

    @commands.command(name="love")
    async def love(self, ctx, target: discord.Member):
        
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="Self-Love Moment! 💖",
                description=f"{ctx.author.mention} practices self-love and appreciation! You deserve it! ✨",
                color=discord.Color.magenta()
            )
        else:
            action = random.choice(self.love_actions)
            embed = discord.Embed(
                title="Love & Affection! 💖",
                description=f"{ctx.author.mention} {action.format(target.mention)}",
                color=discord.Color.magenta()
            )
        await ctx.send(embed=embed)

    @commands.command(name="cuddle")
    async def cuddle(self, ctx, target: discord.Member):
        
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="Self-Cuddle Time! 🧸",
                description=f"{ctx.author.mention} wraps themselves in a cozy blanket! Perfect me-time! ✨",
                color=discord.Color.purple()
            )
        else:
            action = random.choice(self.cuddle_actions)
            embed = discord.Embed(
                title="Cuddle Time! 🧸",
                description=f"{ctx.author.mention} {action.format(target.mention)}",
                color=discord.Color.purple()
            )
        await ctx.send(embed=embed)

    @commands.command(name="pat")
    async def pat(self, ctx, target: discord.Member):
        
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="Self-Pat! 🌟",
                description=f"{ctx.author.mention} gives themselves encouraging pats! You're doing great! ✨",
                color=discord.Color.gold()
            )
        else:
            action = random.choice(self.pat_actions)
            embed = discord.Embed(
                title="Headpat Time! 🌟",
                description=f"{ctx.author.mention} {action.format(target.mention)}",
                color=discord.Color.gold()
            )
        await ctx.send(embed=embed)

    @commands.command(name="loverate")
    async def love_rate(self, ctx, user1: discord.Member, user2: discord.Member = None):
        
        if user2 is None:
            user2 = ctx.author

        pair_hash = hash(str(min(user1.id, user2.id)) + str(max(user1.id, user2.id)))
        love_percentage = ((pair_hash % 100) + 100) % 100  

        heart_meter = "💖" * (love_percentage // 10) + "💔" * ((100 - love_percentage) // 10)
        
        embed = discord.Embed(
            title="💘 Love Calculator 💘",
            description=f"Love compatibility between {user1.mention} and {user2.mention}:",
            color=discord.Color(int(f"FF{hex(love_percentage)[2:].zfill(4)}", 16))
        )
        embed.add_field(name="Love Meter", value=heart_meter, inline=False)
        embed.add_field(name="Love Rating", value=f"**{love_percentage}%** Compatible! ✨", inline=False)
        
        love_comments = [
            "A match made in heaven! 👼",
            "The stars align for this pair! ⭐",
            "What a lovely couple! 💑",
            "Absolutely adorable together! 💝",
            "Pure magic when together! ✨"
        ]
        
        embed.set_footer(text=random.choice(love_comments))
        await ctx.send(embed=embed)

class BeatUpCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
     
        self.special_user_id = 1284210833869639680
        
        self.beat_up_messages = [
            "made {} write Python without Stack Overflow for 24 hours straight",
            "forced {} to debug 10,000 lines of code written by an intern",
            "made {} explain blockchain to their grandparents using only emojis",
            "challenged {} to fix a printer using only Bing search",
            "forced {} to use Windows ME for their production deployment",
            "made {} code on a keyboard where every key is mapped to semicolon",
            "challenged {} to a typing contest using only their nose",
            "forced {} to use light mode Discord during a solar flare",
            "made {} try to center a div without crying",
            "challenged {} to fix 'undefined is not a function' without coffee",
            "forced {} to write documentation that people actually read",
            "made {} explain what RAM is to their pet rock",
            "challenged {} to a 'who can create more bugs' contest and won by default",
            "made {} try to exit Vim blindfolded while doing a handstand",
            "forced {} to attend a 4-hour meeting about semicolon placement",
            "made {} pair program with a rubber duck that talks back",
            "challenged {} to a 'who has more GitHub stars' contest and obliterated them",
            "forced {} to use Comic Sans as their coding font for a week",
            "made {} explain recursion using interpretive dance",
            "challenged {} to fix merge conflicts with their eyes closed"
        ]
        
        self.epic_moves = [
            ("deployed the infinite npm install loop on", 40),
            ("activated the eternal Windows update on", 35),
            ("replaced all semicolons with Greek question marks in the code of", 45),
            ("deleted the entire Git history of", 50),
            ("converted all indentation to a random mix of tabs and spaces for", 30),
            ("enabled Clippy as the permanent IDE assistant for", 60),
            ("changed all function names to UwU speech in the code of", 55),
            ("replaced all variables with 'x', 'xx', 'xxx' in the code of", 40),
            ("set up a permanent LinkedIn connection with", 45),
            ("installed 1000 npm packages in the project of", 65),
            ("force pushed to master in the repository of", 70),
            ("enabled real-time code sharing on Stack Overflow for", 55),
            ("replaced all error messages with UwU speak for", 50),
            ("installed PHP on all servers owned by", 75)
        ]
        
        self.fail_actions = [
            "tried to hack but accidentally formatted C: drive",
            "attempted to code but their cat walked on the keyboard and made better code",
            "tried to flex their IQ but accidentally opened Bing",
            "attempted to show off but their mechanical keyboard exploded",
            "tried to be smart but used COBOL in 2024",
            "was about to attack but got distracted by a floating semicolon",
            "attempted to look cool but accidentally deployed to production",
            "tried to be epic but their RGB lighting shorted out",
            "was charging up but got stuck in a Vim session",
            "failed because they thought copying from Stack Overflow was a personality",
            "tried to impress but their Linux install broke",
            "attempted to be cool but their custom mechanical keyboard fell apart",
            "was about to strike but got a kernel panic",
            "failed spectacularly after confusing Java with JavaScript",
            "tried to attack but their code had too many dependencies"
        ]

        self.fight_actions = [
            ("exposed the 'homework' folder of", 15),
            ("revealed the Ctrl+C Ctrl+V search history of", 20),
            ("leaked the MySpace profile of", 25),
            ("found the first 'Hello World' attempt by", 30),
            ("discovered the secret light mode IDE preference of", 35),
            ("revealed that {} still uses Notepad for JavaScript", 40),
            ("exposed that {} thinks DNS is a type of restaurant", 45),
            ("showed everyone that {} debugs with console.log", 50),
            ("revealed the indentation style of", 30),
            ("exposed the commit message history of", 40),
            ("found the 'final_final_v2_REAL' folder of", 45),
            ("discovered the browser history full of 'how to exit vim' searches from", 55)
        ]

        self.victory_animations = [
            "🤓 → 💻 → 💀",
            "👾 → 🔥 → 💩",
            "🎮 → 💣 → 🏆",
            "🧠 → 🔌 → ⚰️",
            "💾 → 💥 → 🏅",
            "🐛 → 🔨 → 💫"
        ]

        self.tech_roasts = [
            "codes like they're getting paid per bug",
            "writes documentation worse than a drunk cat on a keyboard",
            "has more technical debt than student loans",
            "thinks machine learning is teaching their laptop tricks",
            "debugs code by asking it nicely to work",
            "thinks CSS is a type of mental disorder",
            "has commit messages shorter than their attention span",
            "writes code that makes Windows Vista look stable",
            "thinks git blame is a personal attack",
            "has more deprecated dependencies than working features"
        ]

    @commands.command(name="beatup")
    async def beat_up(self, ctx, target: discord.Member):
        if target.id == ctx.author.id:
            embed = discord.Embed(
                title="Task Failed Successfully",
                description="You tried to beat yourself up but your code had a race condition with your brain",
                color=discord.Color.purple()
            )
        elif ctx.author.id == self.special_user_id:
            action = f"**ULTIMATE DEBUG:** {random.choice(self.beat_up_messages).format(target.mention)}"
            embed = discord.Embed(
                title="💻 FATAL ERROR DEPLOYED! 💻",
                description=action,
                color=discord.Color.gold()
            )
            embed.set_footer(text="Error 418: I'm a teapot")
        else:
            fail_chance = random.random()
            if fail_chance > 0.7:
                fail_action = random.choice(self.fail_actions)
                embed = discord.Embed(
                    title="Task Failed Successfully",
                    description=f"{ctx.author.mention} {fail_action}",
                    color=discord.Color.orange()
                )
            else:
                action = random.choice(self.beat_up_messages).format(target.mention)
                embed = discord.Embed(
                    title="🐛 Critical Bug Deployed!",
                    description=f"{ctx.author.mention} {action}",
                    color=discord.Color.red()
                )
            embed.set_footer(text="No developers were harmed in the making of this bug")
            
        await ctx.send(embed=embed)

    @commands.command(name="techroast")
    async def tech_roast(self, ctx, target: discord.Member):
        roast = random.choice(self.tech_roasts)
        await ctx.send(f"{target.mention} {roast}")

    @commands.command(name="fighttodeath")
    async def fight_to_death(self, ctx, target: discord.Member):

        if target.id == ctx.author.id:
            await ctx.send("You tried to fight yourself but caused a stack overflow!")
            return

        player1_health = 100
        player2_health = 100
        
        embed = discord.Embed(
            title="⚔️ ULTIMATE DEBUG BATTLE! ⚔️",
            description=f"{ctx.author.mention} initiates a merge conflict with {target.mention}!\n*npm install battle-mode*",
            color=discord.Color.gold()
        )
        embed.set_footer(text="Round 1: Fight! git push --force")
        await ctx.send(embed=embed)

        round_count = 1
        while player1_health > 0 and player2_health > 0:
           
            if ctx.author.id == self.special_user_id:
                action, damage = random.choice(self.epic_moves)
                fail_chance = 0 
            else:
                fail_chance = random.random()
                if fail_chance > 0.7:  
                    fail_action = random.choice(self.fail_actions)
                    damage = random.randint(5, 15)  
                    player1_health -= damage
                    embed = discord.Embed(
                        description=f"😅 {ctx.author.name} {fail_action} (-{damage} HP to self)",
                        color=discord.Color.orange()
                    )
                    embed.add_field(name=f"{ctx.author.name}'s HP", value=f"{max(0, player1_health)}/100")
                    embed.add_field(name=f"{target.name}'s HP", value=f"{max(0, player2_health)}/100")
                    await ctx.send(embed=embed)
                    await asyncio.sleep(2)
                    continue
                action, damage = random.choice(self.fight_actions)

            player2_health -= damage
            embed = discord.Embed(
                description=f"💥 {ctx.author.name} {action} {target.name} (-{damage} HP)",
                color=discord.Color.blue()
            )
            embed.add_field(name=f"{ctx.author.name}'s HP", value=f"{max(0, player1_health)}/100")
            embed.add_field(name=f"{target.name}'s HP", value=f"{max(0, player2_health)}/100")
            await ctx.send(embed=embed)
            await asyncio.sleep(2)

            if player2_health <= 0:
                break

            fail_chance = random.random()
            if fail_chance > 0.5:  
                fail_action = random.choice(self.fail_actions)
                damage = random.randint(5, 15)
                player2_health -= damage
                embed = discord.Embed(
                    description=f"😅 {target.name} {fail_action} (-{damage} HP to self)",
                    color=discord.Color.orange()
                )
            else:
                action, damage = random.choice(self.fight_actions)
                if ctx.author.id == self.special_user_id:
                    damage = damage // 2  
                player1_health -= damage
                embed = discord.Embed(
                    description=f"💥 {target.name} {action} {ctx.author.name} (-{damage} HP)",
                    color=discord.Color.red()
                )
            
            embed.add_field(name=f"{ctx.author.name}'s HP", value=f"{max(0, player1_health)}/100")
            embed.add_field(name=f"{target.name}'s HP", value=f"{max(0, player2_health)}/100")
            await ctx.send(embed=embed)
            await asyncio.sleep(2)

            round_count += 1
            if round_count > 10:
                embed = discord.Embed(
                    title="⏰ TIMEOUT EXCEPTION!",
                    description="Battle terminated - exceeded maximum call stack size",
                    color=discord.Color.greyple()
                )
                await ctx.send(embed=embed)
                break

        winner = ctx.author if player2_health <= 0 else target
        loser = target if player2_health <= 0 else ctx.author
        
        endings = [
            f"{winner.mention} wins! {loser.mention} should've used TypeScript!",
            f"{winner.mention} dominated! {loser.mention} forgot to catch their exceptions!",
            f"{winner.mention} triumphs! {loser.mention} got stuck in an infinite loop!",
            f"{winner.mention} conquered! {loser.mention} had a null pointer exception!",
            f"{winner.mention} prevails! {loser.mention} tried to divide by zero!",
            f"{winner.mention} destroys! {loser.mention} used light mode and went blind!"
        ]
        
        embed = discord.Embed(
            title="🏆 COMPILATION SUCCESSFUL! 🏆",
            description=f"{random.choice(endings)}\n{random.choice(self.victory_animations)}",
            color=discord.Color.gold()
        )
        embed.set_footer(text="No keyboards were harmed during this battle (maybe)")
        await ctx.send(embed=embed)


class AnnouncementView(discord.ui.View):
    def __init__(self, embed, channel):
        super().__init__(timeout=300)
        self.embed = embed
        self.channel = channel  

    @discord.ui.button(label="✨ Preview", style=discord.ButtonStyle.green, emoji="👁️")
    async def preview(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message(embed=self.embed, ephemeral=True)

    @discord.ui.button(label="📢 Send", style=discord.ButtonStyle.blurple, emoji="📣")
    async def send(self, interaction: discord.Interaction, button: discord.ui.Button):
        sent_msg = await self.channel.send(embed=self.embed)
        await interaction.response.send_message(
            f"✅ Announcement sent successfully in {self.channel.mention}!\n[Jump to message]({sent_msg.jump_url})",
            ephemeral=True
        )
        self.stop()

    @discord.ui.button(label="❌ Cancel", style=discord.ButtonStyle.red, emoji="🚫")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("🔴 Announcement cancelled", ephemeral=True)
        self.stop()

    @discord.ui.button(label="✏️ Edit", style=discord.ButtonStyle.gray, emoji="📝")
    async def edit(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = AnnouncementModal(self.channel) 
        await interaction.response.send_modal(modal)
        self.stop()


class AnnouncementModal(discord.ui.Modal, title="Create Announcement"):
    def __init__(self, channel):
        super().__init__()
        self.channel = channel

        self.announcement_title = discord.ui.TextInput(
            label="📌 Announcement Title",
            placeholder="Enter an eye-catching title...",
            required=True,
            max_length=256
        )

        self.content = discord.ui.TextInput(
            label="📝 Content",
            style=discord.TextStyle.paragraph,
            placeholder="Write your announcement here...",
            required=True,
            max_length=4000
        )

        self.color = discord.ui.TextInput(
            label="🎨 Embed Color (hex)",
            placeholder="#3498db",
            required=False,
            max_length=7
        )

        self.footer = discord.ui.TextInput(
            label="👣 Footer Text",
            required=False,
            placeholder="Optional footer message...",
            max_length=2048
        )

        self.image_url = discord.ui.TextInput(
            label="🖼️ Image URL",
            required=False,
            placeholder="Optional image URL...",
            max_length=2048
        )

        self.add_item(self.announcement_title)
        self.add_item(self.content)
        self.add_item(self.color)
        self.add_item(self.footer)
        self.add_item(self.image_url)

    async def on_submit(self, interaction: discord.Interaction):
        try:
        
            color_hex = self.color.value.lstrip('#')
            if color_hex:
                try:
                    embed_color = discord.Color(int(color_hex, 16))  
                except ValueError:
                    raise ValueError("Invalid hex color code.")
            else:
                embed_color = discord.Color.blue()  

            embed = discord.Embed(
                title=self.announcement_title.value,
                description=self.content.value,
                color=embed_color
            )

            if self.footer.value:
                embed.set_footer(
                    text=self.footer.value,
                    icon_url=interaction.guild.icon.url if interaction.guild and interaction.guild.icon else None
                )

            if self.image_url.value:
                embed.set_image(url=self.image_url.value)

            embed.timestamp = discord.utils.utcnow()
            embed.set_author(
                name=interaction.user.display_name,
                icon_url=interaction.user.display_avatar.url if interaction.user.display_avatar else None
            )

            view = AnnouncementView(embed, self.channel)
            await interaction.response.send_message(
                "🎉 Announcement is ready! Use the buttons below to preview or send.",
                embed=embed,
                view=view,
                ephemeral=True
            )

        except ValueError as e:
            await interaction.response.send_message(f"⚠️ {str(e)}", ephemeral=True)


class AnnouncementButton(discord.ui.Button):
    def __init__(self, channel):
        super().__init__(
            style=discord.ButtonStyle.green,
            label="Create Announcement",
            emoji="📢"
        )
        self.channel = channel

    async def callback(self, interaction: discord.Interaction):
        modal = AnnouncementModal(self.channel)
        await interaction.response.send_modal(modal)

class Announcements(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="announce", description="Create a beautiful announcement with custom formatting and preview")
    @commands.has_permissions(manage_messages=True)
    async def announce(self, ctx: commands.Context, channel: discord.TextChannel):
        embed = discord.Embed(
            title="✨ Create Announcement",
            description=f"Click the button below to create an announcement in {channel.mention}",
            color=discord.Color.blue()
        )

        view = discord.ui.View(timeout=180)
        view.add_item(AnnouncementButton(channel))
        await ctx.send(embed=embed, view=view)

class ClaudePromptModal(discord.ui.Modal):
    def __init__(self, cog, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cog = cog
        
        self.add_item(discord.ui.TextInput(
            label="Main Prompt",
            placeholder="What would you like to ask Claude?",
            style=discord.TextStyle.paragraph,
            max_length=1000
        ))
        
        self.add_item(discord.ui.TextInput(
            label="Context (Optional)",
            placeholder="Add any additional context here...",
            style=discord.TextStyle.paragraph,
            required=False
        ))

    async def on_submit(self, interaction: discord.Interaction):
        prompt = self.children[0].value
        context = self.children[1].value
        user = interaction.user
        
        overwrites = {
            interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            interaction.guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        
        channel = await interaction.guild.create_text_channel(
            f'claude-chat-{user.name}',
            overwrites=overwrites,
            topic=f"AI Chat Session for {user.name}"
        )

        self.cog.register_chat_channel(channel.id, user.id)

        embed = discord.Embed(
            title="🤖 New AI Chat Session",
            description=f"Initial prompt: {prompt}\nContext: {context if context else 'None provided'}",
            color=discord.Color.blue()
        )

        view = ClaudeChatView(self.cog, timeout=600.0)  
        await channel.send(embed=embed, view=view)
        await interaction.response.send_message(f"Chat session created in {channel.mention}!", ephemeral=True)

class ClaudeChatView(discord.ui.View):
    def __init__(self, cog, timeout=600.0):
        super().__init__(timeout=timeout)
        self.cog = cog
        self.inactive_task = None
        
    async def on_timeout(self):
        await self.close_channel()
        
    @discord.ui.button(label="Close Chat", style=ButtonStyle.red, emoji="🔒")
    async def close_chat(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.close_channel(interaction)
        
    async def close_channel(self, interaction=None):
        if interaction:
            channel_id = interaction.channel.id
            await interaction.channel.delete()
            self.cog.unregister_chat_channel(channel_id)
        else:
            channel = self.message.channel
            await channel.send("Chat session closed due to inactivity.")
            await asyncio.sleep(5)
            self.cog.unregister_chat_channel(channel.id)
            await channel.delete()



class ConfirmView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=60.0)
        
    @discord.ui.button(label="Confirm", style=ButtonStyle.red, emoji="✅")
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Conversation history cleared!", ephemeral=True)
        self.stop()
        
    @discord.ui.button(label="Cancel", style=ButtonStyle.gray, emoji="❌")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Operation cancelled.", ephemeral=True)
        self.stop()

class ClaudeInterface(discord.ui.View):
    def __init__(self, bot, cog):
        super().__init__(timeout=None)
        self.bot = bot
        self.cog = cog
        
    @discord.ui.button(label="New Conversation", style=ButtonStyle.green, emoji="📝")
    async def new_chat(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = ClaudePromptModal(cog=self.cog, title="Start New Conversation")
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Memory Mode", style=ButtonStyle.blurple, emoji="🧠")
    async def toggle_memory(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild_id = interaction.guild_id
        
        if not hasattr(self, 'memory_enabled'):
            self.memory_enabled = {}
        self.memory_enabled[guild_id] = not self.memory_enabled.get(guild_id, False)
        
        button.style = ButtonStyle.green if self.memory_enabled[guild_id] else ButtonStyle.red
        button.label = "Memory Mode (On)" if self.memory_enabled[guild_id] else "Memory Mode (Off)"
        
        embed = discord.Embed(
            title="🧠 Memory Status Updated",
            description=f"Memory mode is now {'enabled' if self.memory_enabled[guild_id] else 'disabled'}",
            color=discord.Color.green() if self.memory_enabled[guild_id] else discord.Color.red()
        )
        
        await interaction.response.edit_message(view=self)
        await interaction.followup.send(embed=embed, ephemeral=True)


    @discord.ui.button(label="Advanced Settings", style=ButtonStyle.gray, emoji="⚙️")
    async def settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="⚙️ Claude AI Settings",
            description="Configure your AI assistant preferences",
            color=discord.Color.blue()
        )
        embed.add_field(name="Current Mode", value="Advanced", inline=True)
        embed.add_field(name="Memory Status", value="Active", inline=True)
        embed.add_field(name="Response Style", value="Detailed", inline=True)
        
        view = ClaudeSettingsView(cog=self.cog)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="Clear History", style=ButtonStyle.red, emoji="🗑️")
    async def clear_history(self, interaction: discord.Interaction, button: discord.ui.Button):
        confirm_view = ConfirmView()
        await interaction.response.send_message("Are you sure you want to clear the conversation history?", view=confirm_view, ephemeral=True)

class ClaudeSettingsView(discord.ui.View):
    def __init__(self, cog):
        super().__init__()
        self.cog = cog
        self.personality_select = discord.ui.Select(
            placeholder="Select AI Personality",
            options=[
                discord.SelectOption(label="Professional", emoji="👔", description="Formal and business-like responses"),
                discord.SelectOption(label="Creative", emoji="🎨", description="Imaginative and artistic style"),
                discord.SelectOption(label="Technical", emoji="💻", description="Detailed technical explanations"),
                discord.SelectOption(label="Casual", emoji="😊", description="Friendly and conversational tone"),
                discord.SelectOption(label="Funny", emoji="😄", description="Humorous and witty responses")

            ]
        )
        self.personality_select.callback = self.personality_callback
        self.add_item(self.personality_select)

    async def personality_callback(self, interaction: discord.Interaction):
        selected_personality = self.personality_select.values[0]
        guild_id = interaction.guild_id
        
        self.cog.personality_settings[guild_id] = selected_personality
        
        embed = discord.Embed(
            title="🎭 Personality Updated",
            description=f"AI personality has been set to: **{selected_personality}**",
            color=discord.Color.green()
        )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class ClaudeAI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.conversations = {}
        self.settings = {}
        self.api_key = os.getenv('ANTHROPIC_API_KEY', None)
        self.client = None
        self.memory_enabled = {}
        self.active_channels = {}
        self.personality_settings = {}
        
        if not self.api_key:
            print("\033[93m[CLAUDE AI] Waiting for API key configuration\033[0m")
        elif not self.validate_api_key():
            print("\033[93m[CLAUDE AI] API key validation pending\033[0m")

    def validate_api_key(self):
        if not self.api_key:
            return False
        try:
            self.client = Anthropic(api_key=self.api_key)
            return True
        except:
            return False

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.guild:  
            return   
        if not isinstance(message.channel, discord.TextChannel):
            return

        personality = self.personality_settings.get(message.guild.id, "Professional")

        personality_prompts = {
        "Professional": "Respond in a formal, business-like manner: ",
        "Creative": "Respond with creative flair and artistic expression: ",
        "Technical": "Provide detailed technical explanations: ",
        "Casual": "Respond in a friendly, conversational tone: ",
        "Funny": "Respond with humor and wit, including jokes when appropriate: "    
    }    
            
        if (not message.channel.name.startswith('claude-chat-') or
            message.author.bot or
            message.channel.id not in self.active_channels or
            self.active_channels[message.channel.id] != message.author.id):
            return

        if self.api_key is None:
            embed = discord.Embed(
                title="🔑 API Key Required",
                description="Claude AI needs configuration. Contact server administrator to enable AI features.",
                color=discord.Color.gold(),
                timestamp=datetime.now(timezone.utc)
            )
            embed.set_footer(text="Setup Required")
            await message.channel.send(embed=embed)
            return

        async with message.channel.typing():
            try:
                print("Making API request...")

                special_responses = {
                    "nixon": {
                        "keywords": ["nixon", "who is nixon", "Nixon"],
                        "responses": {
                            "Professional": "Nixon is a dedicated developer from Bosnia with a passion for learning and innovation. His contributions to the project demonstrate his commitment to growth and development.",
                            "Creative": "Meet Nixon! 🌟 A creative spirit from Bosnia who brings fresh ideas and enthusiasm to development. His journey in coding is like an artist's canvas - always evolving and full of possibilities!",
                            "Technical": "Nixon is a developer from Bosnia specializing in various programming domains. His technical contributions include [specific areas]. He maintains a strong focus on continuous learning and development best practices.",
                            "Casual": "Hey! Nixon's a cool developer from Bosnia who loves coding and learning new stuff. He's always up for trying something new and brings great energy to the team! 😊",
                            "Funny": "Who's Nixon? Oh, just a coding wizard from Bosnia who turns coffee into code! 🧙‍♂️ He's like a tech explorer - always diving into new projects and coming up with wild ideas! 😄"
                        }
                    },
                    "zygnalbot": {
                        "keywords": ["zygnalbot", "zygnal", "zygnal bot", "all-in-one bot", "who made this bot", "who made this"],
                        "responses": {
                            "Professional": "ZygnalBot is an advanced Discord automation platform developed by TheZ. It integrates comprehensive moderation tools, AI capabilities, and server management features into a unified solution.",
                            "Creative": "✨ ZygnalBot is like a digital Swiss Army knife for Discord! Created by TheZ, it's a masterpiece of automation and AI that makes server management an art form.",
                            "Technical": "ZygnalBot is a sophisticated Discord bot framework built with Python. It implements advanced features including AI integration, moderation systems, and server analytics. For technical details, visit our documentation.",
                            "Casual": "ZygnalBot is your friendly neighborhood Discord helper! Made by TheZ, it's got all the cool features you need to make your server awesome. Check it out! 😊",
                            "Funny": "ZygnalBot? Oh, it's like having a super-smart robot friend who's great at running Discord servers! Created by TheZ, it's basically the Swiss Army knife of Discord bots! 😄"
                        }
                    },
                    "thez": {
                        "keywords": [
                                    "thez", 
                                    "theholyonez", 
                                    "the holy one z", 
                                    "TheZ", 
                                    "Thez", 
                                    "TheholyOneZ", 
                                    "TheZCreator", 
                                    "TheHolyOneZDev", 
                                    "TheZMaster", 
                                    "TheZGod", 
                                    "TheZLegend", 
                                    "TheZDivine", 
                                    "TheZCoder", 
                                    "TheHolyOneZCreator", 
                                    "TheZArchitect", 
                                    "TheZOrigin", 
                                    "WhoIsTheZ", 
                                    "WhoIsTheHolyOneZ", 
                                    "CreatedByTheZ", 
                                    "TheZAndTheHolyOneZ", 
                                    "TheZPower", 
                                    "TheZForce"
                                ],
                        "responses": {
                            "Professional": "TheZ is a celestial force in the world of development, hailing from Germany. Their unparalleled mastery over multiple programming languages has birthed a legacy of open-source projects that resonate across the digital universe. With contributions that transcend the ordinary, TheZ is revered as a guiding light for developers everywhere.",
                            "Creative": "TheZ is an architect of the digital cosmos, weaving code like a divine craftsman shaping the stars. 🎨 From their home in Germany, they breathe life into elegant solutions across countless programming languages, turning complex challenges into art that feels otherworldly in its beauty and precision.",
                            "Technical": "TheZ is a divine full-stack developer with unmatched prowess in Python, with mastery extending to Java, HTML, JS, C++, and C#. Their technical contributions are nothing short of legendary, shaping scalable, timeless architectures that echo through the digital ether, immortalizing their name in the annals of tech history.",
                            "Casual": "TheZ? Oh, they’re a coding demigod from Germany, crafting digital wonders that seem to defy the very laws of programming! With the power of Python and a divine command over countless languages, they effortlessly create solutions that are as if written by the gods themselves. 😇",
                            "Funny": "TheZ? Imagine a coding deity who walks among us mere mortals. 🦸‍♂️ Fluent in Python like a true god and wielding other programming languages with the ease of a divine being, they’re basically the Zeus of the coding world—just with fewer lightning bolts and more perfect code. 😄"
                        }
                    }
                }

                for response_data in special_responses.values():
                    if any(keyword.lower() in message.content.lower() for keyword in response_data["keywords"]):
                        response = response_data["responses"].get(personality, response_data["responses"]["Professional"])
                        await message.channel.send(response)
                        return

                response = self.client.messages.create(
                    model="claude-3-haiku-20240307", # Type: NOTE: BUDGET CLAUDE 3
                    max_tokens=1000,
                    messages=[{
                        "role": "user",
                        "content": f"{personality_prompts[personality]}{message.content}"
                    }],
                    stream=False
                )

                ai_response = response.content[0].text
              
                chunks = [ai_response[i:i+1900] for i in range(0, len(ai_response), 1900)]

                for i, chunk in enumerate(chunks):
                    if i == 0:
                        await message.channel.send(f"**Claude:** {chunk}")
                    elif i == len(chunks) - 1:
                        await message.channel.send(f"{chunk}\n\n*Powered by Anthropic | Bot created by TheZ | Special thanks to Nixon*")
                    else:
                        await message.channel.send(chunk)

            except Exception as e:
                print("Error occurred:", str(e))
                print("Error type:", type(e))
                
                if isinstance(e, anthropic.AuthenticationError):
                    embed = discord.Embed(
                        title="🔐 Authentication Failed",
                        description="Invalid API key configuration detected. Please verify API credentials.",
                        color=discord.Color.red(),
                        timestamp=datetime.now(timezone.utc)
                    )
                    await message.channel.send(embed=embed)
                else:
                    error_embed = discord.Embed(
                        title="⚠️ System Notice",
                        description=f"Request processing interrupted: {str(e)}",
                        color=discord.Color.red(),
                        timestamp=datetime.now(timezone.utc)
                    )
                    await message.channel.send(error_embed)

    @commands.group(invoke_without_command=True)
    @commands.has_permissions(administrator=True)
    async def claude(self, ctx):
        if not self.api_key:
            embed = discord.Embed(
                title="❌ Claude AI Error",
                description="API key not configured! Please contact server administrator.",
                color=discord.Color.red()
            )
            return await ctx.send(embed=embed)
        
        embed = discord.Embed(
            title="🤖 Claude AI Control Panel",
            description="Advanced AI Assistant Interface",
            color=discord.Color.purple()
        )
        embed.add_field(name="Status", value="🟢 Online", inline=True)
        embed.add_field(name="Mode", value="Advanced", inline=True)
        embed.add_field(name="Memory", value="Enabled", inline=True)
        embed.set_footer(text=f"Powered by Anthropic | {ZygnalBot_Version}")
        
        view = ClaudeInterface(self.bot, self)
        await ctx.send(embed=embed, view=view)

    def register_chat_channel(self, channel_id: int, user_id: int):
        self.active_channels[channel_id] = user_id

    def unregister_chat_channel(self, channel_id: int):
        if channel_id in self.active_channels:
            del self.active_channels[channel_id]

    @commands.Cog.listener()
    async def on_guild_channel_delete(self, channel):
        if channel.id in self.active_channels:
            self.unregister_chat_channel(channel.id)

    @commands.Cog.listener()
    async def on_guild_channel_create(self, channel):
        if channel.name.startswith('claude-chat-'):
            await asyncio.sleep(600)  
            if channel.id in self.active_channels:
                try:
                    await channel.send("Chat session timed out due to inactivity.")
                    await asyncio.sleep(5)
                    await channel.delete()
                    self.unregister_chat_channel(channel.id)
                except discord.NotFound:
                    pass

    async def cleanup_inactive_channels(self):
        while True:
            await asyncio.sleep(300) 
            for channel_id in list(self.active_channels.keys()):
                channel = self.bot.get_channel(channel_id)
                if not channel:
                    self.unregister_chat_channel(channel_id)
                    continue

                async for message in channel.history(limit=1):
                    if (datetime.utcnow() - message.created_at).seconds > 600:
                        try:
                            await channel.send("Chat session closed due to inactivity.")
                            await channel.delete()
                            self.unregister_chat_channel(channel_id)
                        except discord.NotFound:
                            pass

    def cog_unload(self):
        self.cleanup_inactive_channels.cancel()

class CreativePromptModal(discord.ui.Modal):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.add_item(discord.ui.TextInput(
            label="Creative Prompt",
            placeholder="Enter your creative writing prompt...",
            style=discord.TextStyle.paragraph
        ))
        self.add_item(discord.ui.TextInput(
            label="Style",
            placeholder="Formal/Casual/Poetic/etc",
            required=False
        ))

    async def on_submit(self, interaction):
        embed = discord.Embed(
            title="✨ Creative Generation",
            description="Generating creative content...",
            color=discord.Color.brand_green()
        )
        await interaction.response.send_message(embed=embed)

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):

        server_id = str(before.guild.id)
        if server_id in self.settings and not self.settings[server_id].get("ghost_ping_enabled", True):
            return  # Ghost ping detection is disabled for this server
            
        if self.is_admin(before.author):
            return
                
        if (before.mentions and not after.mentions) or \
           (before.role_mentions and not after.role_mentions) or \
           (before.mention_everyone and not after.mention_everyone):
            
            embed = discord.Embed(
                title="🔄 SNEAKY EDIT DETECTED",
                description=f"**{before.author.name}** ({before.author.id}) removed mentions!",
                color=discord.Color.orange()
            )
            
            changes = []
            if before.mentions:
                changes.append(f"Users: {', '.join([user.mention for user in before.mentions])}")
            if before.role_mentions:
                changes.append(f"Roles: {', '.join([role.mention for role in before.role_mentions])}")
            if before.mention_everyone:
                changes.append("Mass ping: @everyone/@here")
                
            embed.add_field(
                name="🔍 Removed Mentions",
                value="\n".join(changes),
                inline=False
            )
            
            embed.add_field(name="📝 Original", value=f"```{before.content[:1000]}```", inline=False)
            embed.add_field(name="📝 Edited", value=f"```{after.content[:1000]}```", inline=False)
            
            embed.set_thumbnail(url=before.author.avatar.url if before.author.avatar else before.author.default_avatar.url)
            embed.set_footer(text=f"Message edited at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            await before.channel.send(embed=embed)

class AntiGhostPing(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self._cached_messages = {}
        self._edited_messages = {}
        self._deletion_history = {}
        self._rapid_delete_threshold = 5
        self._rapid_delete_timeframe = 60
        self.ghost_ping_counts = {}  
        self.strict_mode = False  
        self.mod_log_channel = None
        

        self.settings = self.load_settings()


    def load_settings(self):
        settings_file = 'ghost_ping_settings.json'
        if os.path.exists(settings_file):
            try:
                with open(settings_file, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                print("Error loading settings file. Creating new settings.")
                return {}
        else:
            return {}

    def save_settings(self):
        settings_file = 'ghost_ping_settings.json'
        with open(settings_file, 'w') as f:
            json.dump(self.settings, f, indent=4)

    async def _unmute_user(self, user, role, channel):
        await asyncio.sleep(1800)  
        try:
            await user.remove_roles(role)
            embed = discord.Embed(
                title="🔊 User Unmuted",
                description=f"{user.mention} mute duration has expired.",
                color=discord.Color.green()
            )
            await channel.send(embed=embed)
        except discord.HTTPException:
            if self.mod_log_channel:
                await self.mod_log_channel.send(f"Failed to unmute {user.mention} - please check manually.")

    @commands.command(name="toggleghost")
    @commands.has_permissions(administrator=True)
    async def toggle_ghost(self, ctx):

        server_id = str(ctx.guild.id)
        
        if server_id not in self.settings:
            self.settings[server_id] = {}
        
        current_state = self.settings[server_id].get("ghost_ping_enabled", True)
        self.settings[server_id]["ghost_ping_enabled"] = not current_state
        
        self.save_settings()
        
        new_state = "disabled" if current_state else "enabled"
        embed = discord.Embed(
            title="Ghost Ping Detection",
            description=f"Ghost ping detection has been {new_state}.",
            color=discord.Color.green() if not current_state else discord.Color.red()
        )
        await ctx.send(embed=embed)

    @commands.command(name="ghoststrict")
    @commands.has_permissions(administrator=True)
    async def ghost_strict(self, ctx, mode: str = None):

        server_id = str(ctx.guild.id)
        
        if server_id not in self.settings:
            self.settings[server_id] = {}
        
        if mode is None:
           
            strict_mode = self.settings[server_id].get("ghost_ping_strict", False)
            status = "enabled" if strict_mode else "disabled"
            embed = discord.Embed(
                title="Ghost Ping Strict Mode",
                description=f"Strict mode is currently {status}.",
                color=discord.Color.blue()
            )
            await ctx.send(embed=embed)
            return
        
        if mode.lower() in ["on", "true", "enable", "enabled"]:
            self.settings[server_id]["ghost_ping_strict"] = True
            self.strict_mode = True  
            embed = discord.Embed(
                title="Ghost Ping Strict Mode",
                description="Strict mode has been enabled.",
                color=discord.Color.green()
            )
        elif mode.lower() in ["off", "false", "disable", "disabled"]:
            self.settings[server_id]["ghost_ping_strict"] = False
            self.strict_mode = False 
            embed = discord.Embed(
                title="Ghost Ping Strict Mode",
                description="Strict mode has been disabled.",
                color=discord.Color.red()
            )
        else:
            embed = discord.Embed(
                title="Invalid Input",
                description="Please use 'on' or 'off' to set strict mode.",
                color=discord.Color.orange()
            )
        
        self.save_settings()
        
        await ctx.send(embed=embed)

    @commands.command(name='setghostlogs')
    @commands.has_permissions(administrator=True)
    async def set_ghost_logs(self, ctx, channel: discord.TextChannel):
        server_id = str(ctx.guild.id)
        
        if server_id not in self.settings:
            self.settings[server_id] = {}
            
        self.settings[server_id]["log_channel_id"] = channel.id
        self.save_settings()
        
        self.mod_log_channel = channel
        await ctx.send(f"Ghost ping logs will now be sent to {channel.mention}")

    async def handle_ghost_ping_offense(self, user, channel):
        if user.id not in self.ghost_ping_counts:
            self.ghost_ping_counts[user.id] = 1
        else:
            self.ghost_ping_counts[user.id] += 1

        count = self.ghost_ping_counts[user.id]
        
        if count >= 3:
            try:
                muted_role = discord.utils.get(channel.guild.roles, name="Muted")
                if muted_role:
                    await user.add_roles(muted_role)
                    await channel.send(f"{user.mention} has been muted for 30 minutes due to repeated ghost pings.")
                    await asyncio.sleep(1800)  
                    await user.remove_roles(muted_role)
            except discord.Forbidden:
                await channel.send(f"Warning: Unable to mute {user.mention}. Missing permissions.")
        elif count == 2:
            await channel.send(f"⚠️ {user.mention} This is your second warning for ghost pinging. One more will result in a mute.")

    def is_admin(self, member):
        if isinstance(member, discord.ClientUser):
            return True
            
        if isinstance(member, discord.Webhook):
            return True

        if not member:
            return False

        if isinstance(member, discord.User):
            mutual_guilds = member.mutual_guilds
            if mutual_guilds:
                guild = mutual_guilds[0]
                member = guild.get_member(member.id)

        return member and member.guild_permissions.administrator

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
        if message.guild is None:
            return
        
        server_id = str(message.guild.id)
        if server_id in self.settings and not self.settings[server_id].get("ghost_ping_enabled", True):
            return  
     
        has_ping = any([
            bool(message.mentions),
            bool(message.role_mentions),
            message.reference,
            '<@' in message.content,
            '<@&' in message.content,  
        ])
        
        if has_ping:
            print("Message cached for ghost ping detection")
            self._cached_messages[message.id] = {
                'content': message.content,
                'author': message.author,
                'mentions': [user.id for user in message.mentions],
                'role_mentions': [role.id for role in message.role_mentions],
                'everyone': True if (message.mention_everyone or
                                '@everyone' in message.content.lower() or
                                '@here' in message.content.lower()) else False,
                'reference': message.reference.message_id if message.reference else None,
                'timestamp': message.created_at,
                'channel': message.channel.id,
                'attachments': [att.url for att in message.attachments]
            }
            print(f"Cached message data: {self._cached_messages[message.id]}")

    @commands.Cog.listener()
    async def on_message_delete(self, message):
      
        server_id = str(message.guild.id)
        if server_id in self.settings and not self.settings[server_id].get("ghost_ping_enabled", True):
            return  
        if message.guild:  
            return               
        if message.id in self._cached_messages:
            cached = self._cached_messages[message.id]

            if self.is_admin(cached['author']):
                del self._cached_messages[message.id]
                return          

            author_id = cached['author'].id
            current_time = datetime.now()
            
            if author_id not in self._deletion_history:
                self._deletion_history[author_id] = []
            self._deletion_history[author_id].append(current_time)
            
            if author_id not in self.ghost_ping_counts:
                self.ghost_ping_counts[author_id] = 1
            else:
                self.ghost_ping_counts[author_id] += 1

            embed = discord.Embed(
                title="🚨 GHOST PING ALERT 🚨",
                description=f"**{cached['author'].name}** ({cached['author'].id}) tried to ghost ping!\nThis is ghost ping #{self.ghost_ping_counts[author_id]}",
                color=discord.Color.red()
            )
            
            if cached['mentions']:
                embed.add_field(
                    name="👤 User Pings",
                    value=", ".join([f"<@{uid}>" for uid in cached['mentions']]),
                    inline=False
                )
                
            if cached['role_mentions']:
                embed.add_field(
                    name="👥 Role Pings",
                    value=", ".join([f"<@&{rid}>" for rid in cached['role_mentions']]),
                    inline=False
                )
                
            if cached['everyone']:
                embed.add_field(
                    name="📢 Mass Ping",
                    value="@everyone or @here was used",
                    inline=False
                )
                
            if cached['reference']:
                embed.add_field(
                    name="💬 Reply Reference",
                    value=f"Replied to message: {cached['reference']}",
                    inline=False
                )
                
            embed.add_field(
                name="📝 Deleted Message",
                value=f"```{cached['content'][:1000]}```",
                inline=False
            )
            
            if cached['attachments']:
                embed.add_field(
                    name="📎 Attachments",
                    value="\n".join(cached['attachments']),
                    inline=False
                )
            
            recent_deletions = [t for t in self._deletion_history[author_id]
                            if (current_time - t).seconds < self._rapid_delete_timeframe]
            if len(recent_deletions) >= self._rapid_delete_threshold:
                embed.add_field(
                    name="⚠️ WARNING",
                    value="User showing suspicious rapid deletion pattern!",
                    inline=False
                )
            
            embed.set_thumbnail(url=cached['author'].avatar.url if cached['author'].avatar else cached['author'].default_avatar.url)
            embed.set_footer(text=f"Message sent at {cached['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}")
            
            channel = self.bot.get_channel(cached['channel'])
            await channel.send(embed=embed)

            if server_id in self.settings and "log_channel_id" in self.settings[server_id]:
                log_channel_id = self.settings[server_id]["log_channel_id"]
                log_channel = self.bot.get_channel(log_channel_id)
                if log_channel:
                    await log_channel.send(embed=embed)
            elif self.mod_log_channel:
                await self.mod_log_channel.send(embed=embed)

            if self.ghost_ping_counts[author_id] >= 3:
                try:
                    muted_role = discord.utils.get(channel.guild.roles, name="Muted")
                    if not muted_role:
                        muted_role = await channel.guild.create_role(name="Muted")
                        
                        for ch in channel.guild.channels:
                            await ch.set_permissions(muted_role, send_messages=False, add_reactions=False)
                    
                    self.ghost_ping_counts[author_id] = 0
                    await cached['author'].add_roles(muted_role)
                    
                    embed = discord.Embed(
                        title="🔇 Ghost Ping Mute",
                        description=f"{cached['author'].mention} has been muted for 30 minutes.",
                        color=discord.Color.red()
                    )
                    embed.add_field(name="Reason", value="Repeated ghost pinging (3+ times)")
                    embed.add_field(name="Duration", value="30 minutes")
                    await channel.send(embed=embed)
                    
                    self.bot.loop.create_task(self._unmute_user(cached['author'], muted_role, channel))
                    
                    if self.mod_log_channel:
                        await self.mod_log_channel.send(embed=embed)
                        
                except discord.Forbidden:
                    await channel.send("⚠️ Unable to mute user - missing permissions. Please check bot role hierarchy.")
            elif self.ghost_ping_counts[author_id] == 2:
                embed = discord.Embed(
                    title="⚠️ Ghost Ping Warning",
                    description=f"{cached['author'].mention} This is your second warning.",
                    color=discord.Color.yellow()
                )
                embed.add_field(name="Next Offense", value="One more ghost ping will result in a 30-minute mute")
                await channel.send(embed=embed)

            del self._cached_messages[message.id]

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):
        if before.guild is None:
            return       
        server_id = str(before.guild.id)
        if server_id in self.settings and not self.settings[server_id].get("ghost_ping_enabled", True):
            return  
            
        if self.is_admin(before.author):
            return
                
        if (before.mentions and not after.mentions) or \
        (before.role_mentions and not after.role_mentions) or \
        (before.mention_everyone and not after.mention_everyone):
            
            embed = discord.Embed(
                title="🔄 SNEAKY EDIT DETECTED",
                description=f"**{before.author.name}** ({before.author.id}) removed mentions!",
                color=discord.Color.orange()
            )
            
            changes = []
            if before.mentions:
                changes.append(f"Users: {', '.join([user.mention for user in before.mentions])}")
            if before.role_mentions:
                changes.append(f"Roles: {', '.join([role.mention for role in before.role_mentions])}")
            if before.mention_everyone:
                changes.append("Mass ping: @everyone/@here")
                
            embed.add_field(
                name="🔍 Removed Mentions",
                value="\n".join(changes),
                inline=False
            )
            
            embed.add_field(name="📝 Original", value=f"```{before.content[:1000]}```", inline=False)
            embed.add_field(name="📝 Edited", value=f"```{after.content[:1000]}```", inline=False)
            
            embed.set_thumbnail(url=before.author.avatar.url if before.author.avatar else before.author.default_avatar.url)
            embed.set_footer(text=f"Message edited at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            await before.channel.send(embed=embed)
            
    @commands.command(name='test_antighost')
    @commands.has_permissions(administrator=True)
    async def test_antighost(self, ctx):
        webhook = await ctx.channel.create_webhook(name="Ghost Ping Tester")
        
        try:
            test_message = await webhook.send(
                f"Hey {ctx.author.mention} this is a test ping!",
                username="Test User",
                avatar_url="https://i.imgur.com/tE42bZR.png",
                wait=True
            )
            
            await asyncio.sleep(1)
            await test_message.delete()
            await webhook.delete()
            await ctx.send("✅ Anti-ghost ping test completed!")
            
        except Exception as e:
            if webhook:
                await webhook.delete()
            await ctx.send(f"Test failed: {str(e)}")

    async def cog_load(self):
      
        for guild in self.bot.guilds:
            server_id = str(guild.id)
            if server_id in self.settings:
               
                if "log_channel_id" in self.settings[server_id]:
                    log_channel_id = self.settings[server_id]["log_channel_id"]
                    self.mod_log_channel = self.bot.get_channel(log_channel_id)
                
                if "ghost_ping_strict" in self.settings[server_id]:
                    self.strict_mode = self.settings[server_id]["ghost_ping_strict"]

class BotSassResponses(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.enabled = os.getenv("SassResponse", "off").lower() == "on"
        self.sass_responses = [
            "What do you want, you absolute potato? 🥔",
            "Oh look, someone who thinks they're worthy of my attention 👑",
            "Did your last brain cell finally die or do you need something? 🧠",
            "*sigh* Yes, your royal pain in my circuits? 🤖",
            "Breaking news: Local human wastes bot's time! More at 11 📰",
            "I was having such a nice day until you pinged me 📌",
            "Ah, the village idiot has arrived! What's up? 🏰",
            "Error 422: Too stupid to process 💻",
            "Look who learned how to ping! Want a cookie? 🍪",
            "I'm busy calculating pi, make it quick meatbag 🔢",
            "Yes, yes, you found the ping button. Congratulations 🎉",
            "Did you ping me, or did you just fall on your keyboard? ⌨️",
            "Processing request... nah, too boring 😴",
            "Beep boop, annoying human detected 🚨",
            "Do I look like Siri to you? 🤔",
            "Sorry, I don't speak stupid 📚",
            "Loading sass module... Target acquired 🎯",
            "Congratulations! You've won the 'Most Annoying Ping' award! 🏆",
            "I'm not your personal assistant, meatbag 🤖",
            "Did mommy not give you enough attention? 👶"
        ]

    @commands.Cog.listener()
    async def on_message(self, message):
        if not self.enabled:
            return
        if message.author.bot:
            return              
        if (self.bot.user in message.mentions) or (str(self.bot.user.id) in ''.join(message.content.split())):
            sass = random.choice(self.sass_responses)
            
            colors = [
                discord.Color.purple(),
                discord.Color.blue(),
                discord.Color.red(),
                discord.Color.gold()
            ]
            
            embed = discord.Embed(
                title=random.choice([
                    "😒 SASS OVERLOAD",
                    "🙄 HERE WE GO AGAIN", 
                    "😤 HUMAN DETECTED",
                    "🤖 SASS.EXE ACTIVATED",
                    "💅 ATTITUDE LOADED"
                ]),
                description=sass,
                color=random.choice(colors)
            )
            
            embed.set_footer(text=random.choice([
                "Pro tip: Don't poke the bot",
                "Sass level: Maximum",
                "Warning: Attitude detected", 
                "Sarcasm module: Engaged",
                "Human annoyance level: Rising"
            ]))
            
            await message.channel.send(embed=embed)


class RoastCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.roasts = [
            
            "You're the human equivalent of a participation award 🏆",
            "I'd roast you but my mom said I shouldn't burn trash 🗑️",
            "You're proof that evolution can go in reverse 🦍",
            "If I wanted to kill myself, I'd climb your ego and jump to your IQ 📉",
            
            "I'd explain it to you, but I don't have any crayons handy 🖍️",
            "You're the reason we have warning labels on shampoo bottles 🧴",
            "You're living proof that someone can live without a brain 🧠",
            "I don't have the time or crayons to explain this to you 🎨",
            
            "If you were any more inbred you'd be a sandwich 🥪",
            "Your face makes onions cry 🧅",
            "You look like something I'd draw with my left hand 🎨",
            "You're so ugly, Hello Kitty said goodbye 😺",
            
            "The only way you'll ever get laid is if you crawl up a chicken's butt and wait 🐔",
            "You're the reason the gene pool needs a lifeguard 🏊‍♂️",
            "I'd tell you to go outside, but that would be cruel to others 🌞",
            "Your birth certificate is an apology letter from the condom factory 📜",
            
            "You're like Internet Explorer - nobody wants you but you don't go away 🌐",
            "Your coding skills are like Windows Vista - full of errors 💻",
            "You're as useful as a screen door on a submarine 🚪",
            "Loading your brain... Error 404: Not Found 🔄",
            
            "You're the human equivalent of a broken controller 🎮",
            "Your K/D ratio is lower than your IQ 🎯",
            "You're like a tutorial level - everyone wants to skip you 📖",
            "You have less value than a Common item drop 📦",
            
            "Scientists say the universe is made up of neutrons, protons and electrons. They forgot to mention morons 🔬",
            "If stupidity was a currency, you'd be a billionaire 💰",
            "I'm not saying you're stupid, you just have bad luck thinking 🤔",
            "You're so dense, light bends around you 💫"
        ]
        
        self.triggers = [
            "roast me", "destroy me", "end me", "murder me",
            "obliterate me", "finish me", "delete me", "wreck me",
            "burn me", "demolish me", "annihilate me", "terminate me",
            "execute me", "eliminate me", "eradicate me", "vaporize me"
        ]
        
        self.bot_comebacks = [
            "Nice try, but I'm fireproof 😎",
            "I'm rubber, you're glue 🪀",
            "Sorry, I don't roast superior beings 🤖",
            "Error 418: I'm a teapot ☕",
            "You couldn't handle these circuits 💫",
            "My AI is too advanced for your games 🧠",
            "Cannot compute: Target too awesome 🌟"
        ]

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
        if message.guild:  
            return               
        if any(trigger in message.content.lower() for trigger in self.triggers):
            roast = random.choice(self.roasts)
            embed = discord.Embed(
                title="🔥 CRITICAL HIT 🔥",
                description=f"{message.author.mention}\n{roast}",
                color=discord.Color.red()
            )
            embed.set_footer(text=random.choice([
                "Apply cold water to burned area 🧊",
                "That's gonna leave a mark 🎯",
                "No refunds on emotional damage 💔",
                "Warning: Savage levels exceeding safe limits ⚠️",
                "Call an ambulance... but not for me 🚑"
            ]))
            await message.channel.send(embed=embed)
            
    @commands.command()
    async def roast(self, ctx, target: discord.Member = None):
        
        if not target:
            target = ctx.author
            
        if target.id == self.bot.user.id:
            comeback = random.choice(self.bot_comebacks)
            embed = discord.Embed(
                title="🤖 NICE TRY",
                description=comeback,
                color=discord.Color.blue()
            )
            embed.set_footer(text="Bot: 1 | Human: 0")
            await ctx.send(embed=embed)
            return
            
        roast = random.choice(self.roasts)
        embed = discord.Embed(
            title="🔥 ROAST INCOMING 🔥",
            description=f"{target.mention}\n{roast}",
            color=discord.Color.orange()
        )
        embed.set_footer(text=f"Destruction level: {random.randint(95,100)}%")
        await ctx.send(embed=embed)

class HackerCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.hacker_phrases = [
            "BYPASSING FIREWALL...",
            "INJECTING PAYLOAD...",
            "ACCESSING MAINFRAME...",
            "BREAKING ENCRYPTION...",
            "EXTRACTING DATA..."
        ]

    @commands.command()
    async def decrypt(self, ctx, *, text):
        
        embed = discord.Embed(color=discord.Color.red())
        embed.add_field(name="🔓 DECRYPTION SEQUENCE", value="```INITIALIZING...```")
        loading = await ctx.send(embed=embed)
        
        progress_bars = [
            "```[▓▓▓░░░░░░░] 30%```",
            "```[▓▓▓▓▓░░░░░] 50%```",
            "```[▓▓▓▓▓▓▓░░░] 70%```",
            "```[▓▓▓▓▓▓▓▓▓░] 90%```",
            "```[▓▓▓▓▓▓▓▓▓▓] 100%```"
        ]
        
        for i, bar in enumerate(progress_bars):
            embed.clear_fields()
            embed.add_field(name="🔓 DECRYPTION SEQUENCE", 
                          value=f"{bar}\n```{self.hacker_phrases[i]}```")
            await loading.edit(embed=embed)
            await asyncio.sleep(1)
        
        result = ''.join(random.choice(string.ascii_letters + string.digits) for _ in text)
        final_embed = discord.Embed(color=discord.Color.green())
        final_embed.add_field(name="🔓 DECRYPTION COMPLETE", 
                            value=f"```ORIGINAL: {text}\nDECRYPTED: {result}```")
        await ctx.send(embed=final_embed)

    @commands.command()
    async def scan(self, ctx, target: discord.Member):
        
        embed = discord.Embed(color=discord.Color.blue())
        embed.set_thumbnail(url=target.avatar.url if target.avatar else target.default_avatar.url)
        
        scan_msg = await ctx.send("```INITIATING NEURAL SCAN...```")
        await asyncio.sleep(1)

        threat_level = random.randint(1, 10)
        color = discord.Color.green() if threat_level < 4 else discord.Color.red() if threat_level > 7 else discord.Color.gold()
        
        embed = discord.Embed(title="🔍 NEURAL SCAN RESULTS", color=color)
        embed.add_field(name="TARGET ID", value=f"```{target.id}```", inline=False)
        embed.add_field(name="USERNAME", value=f"```{target.name}```", inline=True)
        embed.add_field(name="CREATED", value=f"```{target.created_at.strftime('%Y-%m-%d')}```", inline=True)
        embed.add_field(name="THREAT LEVEL", value=f"```{threat_level}/10```", inline=True)
        embed.add_field(name="VULNERABILITIES", value=f"```{random.randint(0,5)} detected```", inline=True)
        
        await scan_msg.edit(content=None, embed=embed)

    @commands.command()
    async def matrix(self, ctx):
        
        colors = [discord.Color.green(), discord.Color.blue(), discord.Color.purple()]
        
        for color in colors:
            matrix = ""
            for _ in range(5):
                line = ''.join(random.choice('01') for _ in range(30))
                matrix += f"{line}\n"
            
            embed = discord.Embed(description=f"```{matrix}```", color=color)
            if not hasattr(self, 'matrix_msg'):
                self.matrix_msg = await ctx.send(embed=embed)
            else:
                await self.matrix_msg.edit(embed=embed)
            await asyncio.sleep(0.8)

    @commands.command()
    async def hack(self, ctx, target: discord.Member):
        
        stages = [
            ("BYPASSING SECURITY...", "🔒"),
            ("ACCESSING USER DATA...", "💾"),
            ("EXTRACTING SECRETS...", "🔑"),
            ("DOWNLOADING FILES...", "📥"),
            ("COVERING TRACKS...", "🕵️")
        ]
        
        embed = discord.Embed(title=f"HACKING {target.name}", color=discord.Color.red())
        msg = await ctx.send(embed=embed)
        
        for stage, emoji in stages:
            progress = random.randint(0, 100)
            embed.description = f"{emoji} {stage}\n```Progress: {progress}%```"
            await msg.edit(embed=embed)
            await asyncio.sleep(1.5)
            
        final_embed = discord.Embed(title="HACK COMPLETE", 
                                  description="```Access granted to all systems```",
                                  color=discord.Color.green())
        await msg.edit(embed=final_embed)


class PollType(Enum):
    SINGLE = ("Single Choice ✨", "Choose one option")
    MULTIPLE = ("Multiple Choice 📝", "Select multiple options")
    RATING = ("Rating Stars ⭐", "Rate options from 1-5")
    PRIORITY = ("Priority Ranking 📊", "Rank by importance")
    WEIGHTED = ("Weighted Voting 🎯", "Assign points")
    RANKED = ("Ranked Choice 🏆", "Order by preference")

    def __init__(self, display_name: str, description: str):
        self.display_name = display_name
        self.description = description

class PollData:
    def __init__(self, poll_id: str, question: str, options: List[str], 
                 author_id: int, channel_id: int):
        self.id = poll_id
        self.question = question
        self.options = options
        self.author_id = author_id
        self.channel_id = channel_id
        self.votes = {}
        self.ratings = {}
        self.weighted_votes = {}
        self.ranked_votes = {}

class RatingModal(discord.ui.Modal):
    def __init__(self, option_num: int, poll_data: Dict):
        super().__init__(title=f"Rate Option {option_num + 1}")
        self.option_num = option_num
        self.poll_data = poll_data
        self.add_item(discord.ui.TextInput(
            label="Rating (1-5)",
            placeholder="Enter a number between 1-5",
            max_length=1
        ))

class WeightedVoteModal(discord.ui.Modal):
    def __init__(self, option_num: int, poll_data: Dict):
        super().__init__(title="Weight Your Vote")
        self.option_num = option_num
        self.poll_data = poll_data
        self.add_item(discord.ui.TextInput(
            label="Points (1-10)",
            placeholder="Enter points to assign",
            max_length=2
        ))

class RankedChoiceModal(discord.ui.Modal):
    def __init__(self, poll_data: Dict):
        super().__init__(title="Rank Your Choices")
        self.poll_data = poll_data
        for i, option in enumerate(poll_data['options']):
            self.add_item(discord.ui.TextInput(
                label=f"Rank for {option[:40]}",
                placeholder=f"Enter rank (1-{len(poll_data['options'])})",
                max_length=2
            ))

@dataclass
class PollOption:
    text: str
    emoji: Optional[str] = None
    votes: Dict[str, Union[int, List[int]]] = None
    
    def __post_init__(self):
        self.votes = {}
        if not self.emoji:
            self.emoji = self.extract_emoji(self.text)

    @staticmethod
    def extract_emoji(text: str) -> Optional[str]:
        emoji_pattern = r'<a?:[a-zA-Z0-9_]+:[0-9]+>|[\U00010000-\U0010ffff]'
        match = re.search(emoji_pattern, text)
        return match.group(0) if match else None



class AdvancedPollSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_polls: Dict[str, 'PollData'] = {}
        self.vote_locks: Dict[str, asyncio.Lock] = {}
        self.poll_tasks: Dict[str, asyncio.Task] = {}
        self.poll_types = {
            "single": "Single Choice ✨",
            "multiple": "Multiple Choice 📝", 
            "rating": "Rating Stars ⭐",
            "priority": "Priority Ranking 📊",
            "weighted": "Weighted Voting 🎯",
            "ranked": "Ranked Choice 🏆"
        }

    class PollSettingsModal(discord.ui.Modal):
        def __init__(self, poll_data: Dict):
            super().__init__(title="⚙️ Poll Settings")
            self.poll_data = poll_data
            
            self.add_item(discord.ui.TextInput(
                label="Poll Type",
                placeholder="single/multiple/rating/weighted/ranked",
                default=poll_data['settings']['type'],
                required=True
            ))
            self.add_item(discord.ui.TextInput(
                label="Duration",
                placeholder="Examples: 1h, 24h, 7d",
                default=poll_data['advanced']['end_time'],
                required=True
            ))
            self.add_item(discord.ui.TextInput(
                label="Min/Max Votes",
                placeholder="Format: min,max (e.g., 1,3)",
                default=f"{poll_data['settings'].get('min_votes', 1)},{poll_data['settings'].get('max_votes', 3)}",
                required=False
            ))
            self.add_item(discord.ui.TextInput(
                label="Hide Results",
                placeholder="true/false",
                default=str(poll_data['settings'].get('hide_results', False)).lower(),
                required=False
            ))

        async def on_submit(self, interaction: discord.Interaction):
            try:
                self.poll_data['settings']['type'] = self.children[0].value.lower()
                self.poll_data['advanced']['end_time'] = self.children[1].value
                
                if self.children[2].value:
                    min_votes, max_votes = map(int, self.children[2].value.split(','))
                    self.poll_data['settings']['min_votes'] = min_votes
                    self.poll_data['settings']['max_votes'] = max_votes
                
                self.poll_data['settings']['hide_results'] = self.children[3].value.lower() == 'true'
                
                embed = interaction.client.get_cog('AdvancedPollSystem').create_poll_embed(self.poll_data)
                await interaction.message.edit(embed=embed)
                await interaction.response.send_message("✨ Poll settings updated!", ephemeral=True)
                
            except Exception as e:
                await interaction.response.send_message(f"Failed to update settings: {str(e)}", ephemeral=True)
    
    class AdvancedPollView(discord.ui.View):
        def __init__(self, poll_data: Dict, cog):
            super().__init__(timeout=None)
            self.poll_data = poll_data
            self.cog = cog

            for i, option in enumerate(poll_data['options']):
                vote_button = discord.ui.Button(
                    label=option,
                    custom_id=f"vote_{i}",
                    style=discord.ButtonStyle.primary,
                    row=i // 4
                )
                async def vote_callback(interaction, button=vote_button, option_index=i):
                    user_id = str(interaction.user.id)
                    if poll_data['settings']['type'] == 'single':
                        poll_data['votes'][user_id] = [option_index]
                        message = "✅ Vote recorded!"
                    else:
                        if user_id not in poll_data['votes']:
                            poll_data['votes'][user_id] = []
                        if option_index in poll_data['votes'][user_id]:
                            poll_data['votes'][user_id].remove(option_index)
                            message = "❌ Vote removed!"
                        else:
                            poll_data['votes'][user_id].append(option_index)
                            message = "✅ Vote added!"
                    
                    embed = cog.create_poll_embed(poll_data)
                    await interaction.message.edit(embed=embed)
                    await interaction.response.send_message(message, ephemeral=True)
                
                vote_button.callback = vote_callback
                self.add_item(vote_button)

            if not poll_data['settings'].get('hide_results', False):
                results_button = discord.ui.Button(
                    label="📊 Results", 
                    custom_id="results_button",
                    style=discord.ButtonStyle.secondary,
                    row=4
                )
                async def results_callback(interaction):
                    results_embed = cog.create_results_embed(poll_data)
                    await interaction.response.send_message(embed=results_embed, ephemeral=True)
                results_button.callback = results_callback
                self.add_item(results_button)

            settings_button = discord.ui.Button(
                label="⚙️ Settings",
                custom_id="settings_button",
                style=discord.ButtonStyle.success,
                row=4
            )
            async def settings_callback(interaction):
                if interaction.user.id == poll_data['author_id']:
                    modal = cog.PollSettingsModal(poll_data)
                    await interaction.response.send_modal(modal)
                else:
                    await interaction.response.send_message("Only the poll creator can modify settings!", ephemeral=True)
            settings_button.callback = settings_callback
            self.add_item(settings_button)


    async def create_poll(self, interaction: discord.Interaction, question: str, options: List[str], 
                         poll_type: str = "single", duration: str = "24h", settings: Dict = None) -> Optional[discord.Message]:
        poll_id = f"poll_{int(time.time())}_{interaction.user.id}"
        
        poll_data = {
            'id': poll_id,
            'question': question,
            'options': options,
            'settings': settings or {'type': poll_type},
            'advanced': {'end_time': duration, 'required_role': 0},
            'author_id': interaction.user.id,
            'author': str(interaction.user),
            'channel_id': interaction.channel_id,
            'created_at': datetime.now(),
            'votes': {},
            'ratings': {},
            'weighted_votes': {},
            'ranked_votes': {}
        }

        view = self.AdvancedPollView(poll_data, self)
        embed = self.create_poll_embed(poll_data)
        
        await interaction.response.send_message(embed=embed, view=view)
        message = await interaction.original_response()
        poll_data['message_id'] = message.id
        
        self.active_polls[poll_id] = poll_data
        self.vote_locks[poll_id] = asyncio.Lock()
        self.poll_tasks[poll_id] = asyncio.create_task(self.start_poll_timer(poll_data))
        
        return message
            
    def create_poll_embed(self, poll_data: Dict) -> discord.Embed:
        embed = discord.Embed(
            title=f"📊 {poll_data['question']}", 
            description=self.get_poll_description(poll_data),
            color=discord.Color(poll_data['settings'].get('color', 0x3498db))
        )
        
        for i, option in enumerate(poll_data['options']):
            option_text = option.text if isinstance(option, PollOption) else str(option)
            emoji = option.emoji if isinstance(option, PollOption) else None
            
            value = f"{emoji} {option_text}" if emoji else option_text
            embed.add_field(
                name=f"Option {i+1}",
                value=value,
                inline=False
            )
        
        embed.set_footer(text=f"Poll ID: {poll_data['id']} | Created by: {poll_data['author']}")
        return embed

    def get_poll_description(self, poll_data: Dict) -> str:
        poll_type = self.poll_types.get(poll_data['settings']['type'], "Standard Poll")
        return f"**Type:** {poll_type}\n**Duration:** {poll_data['advanced']['end_time']}\n\nClick the buttons below to vote!"

    def parse_settings_string(self, settings_str: str) -> Dict:
        settings = {
            'min_votes': 1,
            'max_votes': 3,
            'hide_results': False,
            'color': 0x3498db
        }
        
        if settings_str:
            for line in settings_str.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip().lower()
                    value = value.strip().lower()
                    
                    if key == 'min_votes' or key == 'max_votes':
                        settings[key] = int(value)
                    elif key == 'hide_results':
                        settings[key] = value == 'true'
                    elif key == 'color':
                        settings[key] = int(value.replace('#', '0x'), 16)
        
        return settings
       
    async def cog_unload(self):
        
        for task in self.poll_tasks.values():
            task.cancel()
        
    async def create_poll(self, ctx, question: str, options: List[str],
                        poll_type: PollType = PollType.SINGLE,
                        duration: str = "24h",
                        settings: Dict = None) -> Optional[discord.Message]:
        
        
        if isinstance(ctx, discord.Interaction):
            user = ctx.user
            channel_id = ctx.channel_id
            send = ctx.response.send_message
        else:
            user = ctx.author
            channel_id = ctx.channel.id
            send = ctx.send

        poll_id = f"poll_{int(time.time())}_{user.id}"
        
        poll_data = {
            'id': poll_id,
            'question': question,
            'options': [PollOption(text=opt) for opt in options],
            'settings': settings or self._default_settings(poll_type),
            'advanced': {'end_time': duration, 'required_role': 0},
            'author_id': user.id,
            'author': str(user),
            'channel_id': channel_id,
            'created_at': datetime.now(),
            'votes': {},
            'ratings': {},
            'weighted_votes': {},
            'ranked_votes': {}
        }

        view = self.create_poll_view(poll_data)
        embed = self.create_poll_embed(poll_data)
        
        try:
            message = await send(embed=embed, view=view)
            poll_data['message_id'] = message.id
            self.active_polls[poll_id] = poll_data
            
            self.poll_tasks[poll_id] = asyncio.create_task(
                self.start_poll_timer(poll_data)
            )
            
            return message
        except Exception as e:
            print(f"Error creating poll: {e}")
            return None


    def _default_settings(self, poll_type: PollType) -> Dict:
        
        return {
            'type': poll_type.name.lower(),
            'min_votes': 1,
            'max_votes': 1 if poll_type == PollType.SINGLE else 3,
            'hide_results': False,
            'color': 0x3498db
        }
    async def start_poll_timer(self, poll_data: Dict):
        duration = self.parse_duration(poll_data['advanced']['end_time'])
        end_time = datetime.now() + timedelta(seconds=duration)
        poll_data['end_timestamp'] = end_time.timestamp()
        
        await asyncio.sleep(duration)
        
        channel = self.bot.get_channel(poll_data['channel_id'])
        if channel:
            try:
                message = await channel.fetch_message(poll_data['message_id'])
                
                new_view = self.AdvancedPollView(poll_data, self)
                for child in new_view.children:
                    child.disabled = True
                
                results_embed = discord.Embed(
                    title="📊 Final Poll Results",
                    description=f"Results for: {poll_data['question']}\n",
                    color=discord.Color.gold()
                )
                
                total_votes = len(poll_data.get('votes', {}))
                for i, option in enumerate(poll_data['options']):
                    votes = sum(1 for vote_list in poll_data.get('votes', {}).values() 
                            if isinstance(vote_list, list) and i in vote_list)
                    percentage = (votes / total_votes * 100) if total_votes > 0 else 0
                    results_embed.add_field(
                        name=option,
                        value=f"Votes: {votes} ({percentage:.1f}%)",
                        inline=False
                    )
                
                results_embed.set_footer(text=f"Total Votes: {total_votes}")
                await channel.send(embed=results_embed)
                
                embed = self.create_poll_embed(poll_data)
                embed.description += "\n\n**Poll has ended!** ⏰"
                
                await message.edit(embed=embed, view=new_view)
                print(f"📊 Poll {poll_data['id']} ended successfully!")
                
            except discord.NotFound:
                print(f"❌ Poll message {poll_data['message_id']} not found")



    def parse_duration(self, duration_str: str) -> int:
        units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
        value = int(''.join(filter(str.isdigit, duration_str)))
        unit = ''.join(filter(str.isalpha, duration_str.lower()))
        return value * units.get(unit, 3600)

    async def end_poll(self, poll_data: Dict) -> None:
        channel = self.bot.get_channel(poll_data['channel_id'])
        if not channel:
            return

        try:
            message = await channel.fetch_message(poll_data['message_id'])
            final_view = self.create_poll_view(poll_data, disabled=True)
            embed = self.create_poll_embed(poll_data)
            embed.description += "\n\n**Poll has ended!** ⏰"
            
            await message.edit(embed=embed, view=final_view)
            
            results_embed = self.create_results_summary(poll_data)
            await channel.send(embed=results_embed)
            
            self.active_polls.pop(poll_data['id'], None)
            self.vote_locks.pop(poll_data['id'], None)
            
        except discord.NotFound:
            print(f"Poll message not found: {poll_data['id']}")

    def create_poll_view(self, poll_data: Dict, disabled: bool = False) -> discord.ui.View:
        view = discord.ui.View(timeout=None)
        
        for i, option in enumerate(poll_data['options']):
            button = self.VoteButton(
                poll_type=poll_data['settings']['type'],
                option_num=i,
                option_text=option,
                disabled=disabled
            )
            view.add_item(button)

        if not poll_data['settings'].get('hide_results', False):
            view.add_item(self.ResultsButton())
        if not disabled:
            view.add_item(self.SettingsButton())

        return view

    class VoteButton(discord.ui.Button):
        def __init__(self, poll_type: str, option_num: int, option_text: PollOption, disabled: bool = False):
            style = self.get_button_style(poll_type)
            super().__init__(
                style=style,
                label=option_text.text,  
                emoji=option_text.emoji, 
                custom_id=f"vote_{option_num}",
                disabled=disabled
            )
            self.poll_type = poll_type
            self.option_num = option_num


        def get_button_style(self, poll_type: str) -> discord.ButtonStyle:
            styles = {
                "single": discord.ButtonStyle.primary,
                "multiple": discord.ButtonStyle.success,
                "rating": discord.ButtonStyle.secondary,
                "priority": discord.ButtonStyle.primary,
                "weighted": discord.ButtonStyle.success,
                "ranked": discord.ButtonStyle.secondary
            }
            return styles.get(poll_type, discord.ButtonStyle.primary)

        def format_label(self, text: str) -> str:
            emoji_pattern = r'<a?:[a-zA-Z0-9_]+:[0-9]+>|[\U00010000-\U0010ffff]'
            label = re.sub(emoji_pattern, '', text).strip()
            return label[:80] if len(label) > 80 else label

        def extract_emoji(self, text: str) -> Optional[str]:
            emoji_pattern = r'<a?:[a-zA-Z0-9_]+:[0-9]+>|[\U00010000-\U0010ffff]'
            match = re.search(emoji_pattern, text)
            return match.group(0) if match else None

        async def callback(self, interaction: discord.Interaction):
            view = self.view
            poll_data = view.poll_data

            if not await self._check_permissions(interaction, poll_data):
                return

            if self.poll_type in ['rating', 'weighted', 'ranked']:
                await self._handle_special_vote(interaction)
            else:
                await self._handle_standard_vote(interaction)

        async def _check_permissions(self, interaction: discord.Interaction, poll_data: Dict) -> bool:
            if poll_data['advanced'].get('required_role', 0):
                role = interaction.guild.get_role(poll_data['advanced']['required_role'])
                if role not in interaction.user.roles:
                    await interaction.response.send_message(
                        f"You need the {role.name} role to vote!",
                        ephemeral=True
                    )
                    return False
            return True

        async def _handle_special_vote(self, interaction: discord.Interaction):
            modal_classes = {
                'rating': RatingModal,
                'weighted': WeightedVoteModal,
                'ranked': RankedChoiceModal
            }
            modal_class = modal_classes.get(self.poll_type)
            if modal_class:
                modal = modal_class(self.option_num, self.view.poll_data)
                await interaction.response.send_modal(modal)

        async def _handle_standard_vote(self, interaction: discord.Interaction):
            poll_data = self.view.poll_data
            user_id = str(interaction.user.id)
            
            async with self.view.cog.get_vote_lock(poll_data['id']):
                if user_id not in poll_data['votes']:
                    poll_data['votes'][user_id] = []

                if self.poll_type == 'single':
                    poll_data['votes'][user_id] = [self.option_num]
                    message = "✅ Vote recorded!"
                else:
                    current_votes = poll_data['votes'][user_id]
                    if self.option_num in current_votes:
                        current_votes.remove(self.option_num)
                        message = "❌ Vote removed!"
                    elif len(current_votes) < poll_data['settings']['max_votes']:
                        current_votes.append(self.option_num)
                        message = "✅ Vote added!"
                    else:
                        message = "⚠️ Maximum votes reached!"

                embed = self.view.cog.create_poll_embed(poll_data)
                await interaction.message.edit(embed=embed)
                await interaction.response.send_message(message, ephemeral=True)


    class ResultsButton(discord.ui.Button):
        def __init__(self):
            super().__init__(
                label="📊 Live Results",
                style=discord.ButtonStyle.secondary,
                custom_id="results"
            )

        async def callback(self, interaction: discord.Interaction):
            results_embed = self.view.cog.create_results_embed(self.view.poll_data)
            await interaction.response.send_message(embed=results_embed, ephemeral=True)

    class SettingsButton(discord.ui.Button):
        def __init__(self):
            super().__init__(
                label="⚙️ Settings",
                style=discord.ButtonStyle.success,
                custom_id="settings"
            )

        async def callback(self, interaction: discord.Interaction):
            if not await self._check_permissions(interaction):
                return
            
            modal = self.view.cog.PollSettingsModal(self.view.poll_data)
            await interaction.response.send_modal(modal)

        async def _check_permissions(self, interaction: discord.Interaction) -> bool:
            poll_data = self.view.poll_data
            if interaction.user.id != poll_data['author_id'] and not interaction.user.guild_permissions.manage_messages:
                await interaction.response.send_message(
                    "Only poll creators and moderators can edit settings!", 
                    ephemeral=True
                )
                return False
            return True

    @commands.command(name="createpoll")
    @commands.has_permissions(manage_messages=True)
    async def createpoll(self, ctx):
        
        embed = discord.Embed(
            title="📊 Advanced Poll Creator",
            description="Click below to create a new poll!",
            color=discord.Color.blue()
        )
        
        view = discord.ui.View()
        button = discord.ui.Button(
            label="Create Poll",
            style=discord.ButtonStyle.primary,
            emoji="📊"
        )
        
        async def button_callback(interaction):
            modal = self.PollCreationModal(self)
            await interaction.response.send_modal(modal)
            
        button.callback = button_callback
        view.add_item(button)
        
        await ctx.send(embed=embed, view=view)

    class PollCreationModal(discord.ui.Modal):
        def __init__(self, cog):
            super().__init__(title="📊 Create Advanced Poll")
            self.cog = cog
            
            self.add_item(discord.ui.TextInput(
                label="Poll Question",
                placeholder="What would you like to ask?",
                style=discord.TextStyle.paragraph,
                max_length=256
            ))
            self.add_item(discord.ui.TextInput(
                label="Poll Options (one per line)",
                placeholder="🎮 Gaming\n🎵 Music\n🎨 Art",
                style=discord.TextStyle.paragraph,
                max_length=1000
            ))
            self.add_item(discord.ui.TextInput(
                label="Poll Type",
                placeholder="single/multiple/rating/weighted/ranked",
                default="single",
                required=True
            ))
            self.add_item(discord.ui.TextInput(
                label="Duration",
                placeholder="Examples: 1h, 24h, 7d",
                default="24h",
                required=True
            ))
            self.add_item(discord.ui.TextInput(
                label="Additional Settings",
                placeholder="min_votes:1\nmax_votes:3\nhide_results:false",
                style=discord.TextStyle.paragraph,
                required=False
            ))

        async def on_submit(self, interaction: discord.Interaction):
            try:
                options = [opt.strip() for opt in self.children[1].value.split('\n') if opt.strip()]
                if len(options) < 2:
                    await interaction.response.send_message("Please provide at least 2 options!", ephemeral=True)
                    return

                poll_id = f"poll_{int(time.time())}_{interaction.user.id}"
                
                settings = {
                    'type': self.children[2].value.lower(),
                    'min_votes': 1,
                    'max_votes': 3,
                    'hide_results': False,
                    'color': 0x3498db
                }
                
                if self.children[4].value:
                    additional_settings = dict(line.split(':') for line in self.children[4].value.split('\n') if ':' in line)
                    settings.update({k.strip(): v.strip() for k, v in additional_settings.items()})

                poll_data = {
                    'id': poll_id,
                    'question': self.children[0].value,
                    'options': options,
                    'settings': settings,
                    'advanced': {'end_time': self.children[3].value, 'required_role': 0},
                    'author_id': interaction.user.id,
                    'author': str(interaction.user),
                    'channel_id': interaction.channel_id,
                    'created_at': datetime.now(),
                    'votes': {},
                    'ratings': {},
                    'weighted_votes': {},
                    'ranked_votes': {}
                }

                view = self.cog.AdvancedPollView(poll_data, self.cog)
                embed = self.cog.create_poll_embed(poll_data)
                await interaction.response.send_message(embed=embed, view=view)
                
                message = await interaction.original_response()
                poll_data['message_id'] = message.id
                self.cog.active_polls[poll_id] = poll_data
                self.cog.vote_locks[poll_id] = asyncio.Lock()
                self.cog.poll_tasks[poll_id] = asyncio.create_task(self.cog.start_poll_timer(poll_data))

            except Exception as e:
                print(f"Poll creation error: {e}")
                await interaction.response.send_message("Something went wrong creating the poll.", ephemeral=True)


    class RatingModal(discord.ui.Modal):
        def __init__(self, option_num: int, poll_data: Dict):
            super().__init__(title=f"Rate Option {option_num + 1}")
            self.option_num = option_num
            self.poll_data = poll_data
            
            self.add_item(discord.ui.TextInput(
                label="Rating (1-5 stars)",
                placeholder="Enter a number 1-5",
                max_length=1,
                min_length=1
            ))

        async def on_submit(self, interaction: discord.Interaction):
            try:
                rating = int(self.children[0].value)
                if 1 <= rating <= 5:
                    if 'ratings' not in self.poll_data:
                        self.poll_data['ratings'] = {}
                    if str(self.option_num) not in self.poll_data['ratings']:
                        self.poll_data['ratings'][str(self.option_num)] = {}
                    
                    self.poll_data['ratings'][str(self.option_num)][str(interaction.user.id)] = rating
                    await interaction.response.send_message(
                        f"Rated with {rating} {'⭐' * rating}",
                        ephemeral=True
                    )
                else:
                    await interaction.response.send_message("Please rate between 1-5!", ephemeral=True)
            except ValueError:
                await interaction.response.send_message("Invalid rating!", ephemeral=True)

    def create_results_embed(self, poll_data: Dict) -> discord.Embed:
        embed = discord.Embed(
            title=f"📊 Results: {poll_data['question']}", 
            color=discord.Color.blue()
        )
        
        total_votes = self.calculate_total_votes(poll_data)
        
        for i, option in enumerate(poll_data['options']):
            value = self.format_result_value(poll_data, i, total_votes)
            embed.add_field(
                name=f"Option {i+1}",
                value=value,
                inline=False
            )
        
        embed.set_footer(text=f"Total Votes: {total_votes}")
        return embed

    def calculate_total_votes(self, poll_data: Dict) -> int:
        if poll_data['settings']['type'] == 'rating':
            return len(poll_data.get('ratings', {}).get('0', {}))
        elif poll_data['settings']['type'] == 'weighted':
            return len(poll_data.get('weighted_votes', {}))
        else:
            return len(poll_data.get('votes', {}))

    def format_result_value(self, poll_data: Dict, option_index: int, total_votes: int) -> str:
        option = poll_data['options'][option_index]
        poll_type = poll_data['settings']['type']
        
        if poll_type == 'rating':
            ratings = poll_data.get('ratings', {}).get(str(option_index), {})
            avg_rating = sum(ratings.values()) / len(ratings) if ratings else 0
            return f"{option}\n{'⭐' * round(avg_rating)} ({avg_rating:.1f}/5)"
        
        elif poll_type == 'weighted':
            points = sum(vote.get(str(option_index), 0) 
                        for vote in poll_data.get('weighted_votes', {}).values())
            return f"{option}\n📊 {points} points"
        
        else:
            votes = len([1 for vote_list in poll_data.get('votes', {}).values()
                        if option_index in vote_list])
            percentage = (votes / total_votes * 100) if total_votes > 0 else 0
            bar = self.generate_progress_bar(percentage)
            return f"{option}\n{bar} ({votes} votes)"

    def generate_progress_bar(self, percentage: float, length: int = 20) -> str:
        filled = int(length * percentage / 100)
        empty = length - filled
        bar = "█" * filled + "░" * empty
        return f"{bar} {percentage:.1f}%"

    @commands.Cog.listener()
    async def on_ready(self):

        print('\033[92m' + '[>] ' + '\033[94m' + "Advanced Poll System is ready!" + '\033[0m')


class ISBNLookup(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.session = aiohttp.ClientSession()
        
    @commands.command(name="isbn")
    async def isbn_lookup(self, ctx, isbn: str):
        async with self.session.get(f"https://openlibrary.org/api/books?bibkeys=ISBN:{isbn}&format=json&jscmd=data") as response:
            if response.status == 200:
                data = await response.json()
                book_data = data.get(f"ISBN:{isbn}")
                
                if book_data:
                    embed = discord.Embed(
                        title="📚 Book Information",
                        color=discord.Color.blue()
                    )
                    embed.add_field(name="Title", value=book_data.get("title", "N/A"), inline=False)
                    embed.add_field(name="Authors", value=", ".join([author["name"] for author in book_data.get("authors", [])]), inline=False)
                    embed.add_field(name="Publisher", value=book_data.get("publishers", [{'name': 'N/A'}])[0].get('name', 'N/A'), inline=True)
                    embed.add_field(name="Publish Date", value=book_data.get("publish_date", "N/A"), inline=True)
                    
                    if "cover" in book_data:
                        embed.set_thumbnail(url=book_data["cover"]["large"])
                    
                    view = ISBNView(book_data, isbn)
                    await ctx.send(embed=embed, view=view)
                else:
                    await ctx.send("Book not found!")

class CitationGenerator(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name="cite")
    async def generate_citation(self, ctx):
       
        view = CitationView()
        embed = discord.Embed(
            title="📝 Citation Generator",
            description="Select citation format and enter source details",
            color=discord.Color.green()
        )
        await ctx.send(embed=embed, view=view)

class ISBNView(discord.ui.View):
    def __init__(self, book_data, isbn):
        super().__init__(timeout=60)
        self.book_data = book_data
        self.isbn = isbn

    @discord.ui.button(label="Get Preview", style=ButtonStyle.primary, emoji="👁️")
    async def preview(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="📚 Book Preview",
            color=discord.Color.blue()
        )
        
        embed.add_field(name="Description", value=self.book_data.get('description', 'No description available.')[:1024], inline=False)
        
        if 'excerpts' in self.book_data:
            excerpt = self.book_data['excerpts'][0].get('text', 'No preview available.')[:1024]
            embed.add_field(name="Excerpt", value=excerpt, inline=False)
            
        if 'links' in self.book_data:
            preview_links = []
            for link in self.book_data['links']:
                preview_links.append(f"[{link.get('title', 'View')}]({link.get('url')})")
            if preview_links:
                embed.add_field(name="Preview Links", value="\n".join(preview_links), inline=False)

        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Export Details", style=ButtonStyle.success, emoji="📋")
    async def export(self, interaction: discord.Interaction, button: discord.ui.Button):
        export_embed = discord.Embed(
            title="📚 Detailed Book Information",
            color=discord.Color.green()
        )
        
        title = self.book_data.get('title', 'N/A')
        authors = ", ".join([author["name"] for author in self.book_data.get('authors', [])])
        publisher = self.book_data.get('publishers', [{'name': 'N/A'}])[0].get('name', 'N/A')
        year = self.book_data.get('publish_date', 'N/A').split(',')[-1].strip()
        location = (
            self.book_data.get('publish_places', [{'name': None}])[0].get('name') or
            self.book_data.get('publication_place') or
            self.book_data.get('publisher_location') or
            'New York, NY' if 'William Morrow' in publisher or 'HarperCollins' in publisher else
            'London, UK' if 'Penguin' in publisher or 'Allen & Unwin' in publisher else
            'N/A'
        )
        
        export_embed.add_field(name="Title", value=title, inline=False)
        export_embed.add_field(name="Authors", value=authors, inline=False)
        export_embed.add_field(name="ISBN", value=self.isbn, inline=True)
        export_embed.add_field(name="Publisher", value=publisher, inline=True)
        export_embed.add_field(name="Year", value=year, inline=True)
        export_embed.add_field(name="Location", value=location, inline=True)
        
        if 'number_of_pages' in self.book_data:
            export_embed.add_field(name="Pages", value=self.book_data['number_of_pages'], inline=True)
            
        if 'subjects' in self.book_data:
            subjects = []
            for subject in self.book_data['subjects'][:5]:
                if isinstance(subject, dict):
                    subjects.append(subject.get('name', ''))
                else:
                    subjects.append(str(subject))
            if subjects:
                export_embed.add_field(name="Subjects", value=", ".join(subjects), inline=False)
        
        citation_formats = {
            "APA": f"{authors}. ({year}). {title}. {publisher}. {location}.",
            "MLA": f"{authors}. {title}. {publisher}, {year}.",
            "Chicago": f"{authors}. {title}. {location}: {publisher}, {year}.",
            "Harvard": f"{authors} ({year}) {title}, {location}: {publisher}."
        }
        
        citation_field = "Available Citation Formats:\n"
        for style, citation in citation_formats.items():
            citation_field += f"\n**{style}:**\n{citation}\n"
        
        export_embed.add_field(name="Citations", value=citation_field, inline=False)
        
        if 'cover' in self.book_data:
            export_embed.set_thumbnail(url=self.book_data['cover'].get('large', ''))
            
        export_embed.set_footer(text="Book details exported successfully! Use these citations with your papers.")
        
        await interaction.response.send_message(embed=export_embed, ephemeral=True)


class CitationView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)
        self.selected_format = None
        self.format_select = discord.ui.Select(
            placeholder="First: Select Citation Format",
            options=[
                discord.SelectOption(label="APA", description="APA 7th Edition"),
                discord.SelectOption(label="MLA", description="MLA 9th Edition"),
                discord.SelectOption(label="Chicago", description="Chicago 17th Edition"),
                discord.SelectOption(label="Harvard", description="Harvard Style")
            ]
        )
        self.format_select.callback = self.format_callback
        self.add_item(self.format_select)

    async def format_callback(self, interaction: discord.Interaction):
        self.selected_format = interaction.data['values'][0]
        await interaction.response.send_message(f"✅ {self.selected_format} format selected! Click Generate Citation button.", ephemeral=True)

    @discord.ui.button(label="Generate Citation", style=ButtonStyle.primary, emoji="✨")
    async def generate(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.selected_format:
            await interaction.response.send_message("⚠️ Please select a citation format first!", ephemeral=True)
            return

        class CitationModal(discord.ui.Modal):
            def __init__(self, format_type):
                super().__init__(title=f"{format_type} Citation Generator")
                self.format_type = format_type
                
                self.title_input = discord.ui.TextInput(label="Title", placeholder="Enter source title", required=True)
                self.authors_input = discord.ui.TextInput(label="Authors", placeholder="Enter authors (separated by commas)", required=True)
                self.year_input = discord.ui.TextInput(label="Year", placeholder="Publication year", required=True)
                self.publisher_input = discord.ui.TextInput(label="Publisher", placeholder="Publisher name", required=True)
                
                self.add_item(self.title_input)
                self.add_item(self.authors_input)
                self.add_item(self.year_input)
                self.add_item(self.publisher_input)
                
                if format_type != "MLA":
                    self.location_input = discord.ui.TextInput(label="Location", placeholder="Publication location", required=True)
                    self.add_item(self.location_input)

            async def on_submit(self, interaction: discord.Interaction):
                citation = self.format_citation()
                embed = discord.Embed(
                    title=f"{self.format_type} Citation",
                    description=citation,
                    color=discord.Color.green()
                )
                embed.set_footer(text="Copy this citation for your reference")
                await interaction.response.send_message(embed=embed, ephemeral=True)

            def format_citation(self):
                if self.format_type == "APA":
                    return f"{self.authors_input.value}. ({self.year_input.value}). {self.title_input.value}. {self.publisher_input.value}. {self.location_input.value}."
                elif self.format_type == "MLA":
                    return f"{self.authors_input.value}. {self.title_input.value}. {self.publisher_input.value}, {self.year_input.value}."
                elif self.format_type == "Chicago":
                    return f"{self.authors_input.value}. {self.title_input.value}. {self.location_input.value}: {self.publisher_input.value}, {self.year_input.value}."
                elif self.format_type == "Harvard":
                    return f"{self.authors_input.value} ({self.year_input.value}) {self.title_input.value}, {self.location_input.value}: {self.publisher_input.value}."


        modal = CitationModal(self.selected_format)
        await interaction.response.send_modal(modal)

class ChemicalElements(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.periodic_table_data = self._load_element_data()

    def _load_element_data(self):
        import json
        import os
        json_path = os.path.join(os.path.dirname(__file__), 'data', 'elements_1_118.json')
        with open(json_path, 'r') as f:
            return json.load(f)

    @commands.group(name="element", aliases=["chem", "periodic"])
    async def element(self, ctx):
        if ctx.invoked_subcommand is None:
            embed = await self.generate_periodic_table_embed()
            view = PeriodicTableView(self.periodic_table_data)
            await ctx.send(embed=embed, view=view)

    async def generate_periodic_table_embed(self):
        embed = discord.Embed(
            title="⚛️ Interactive Periodic Table",
            description="Click the buttons below to explore elements!",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Usage",
            value="• `element info <symbol>` - View element information",
            inline=False
        )
        return embed

    @element.command(name="info")
    async def element_info(self, ctx, symbol: str):
        element = self.periodic_table_data.get(symbol.capitalize())
        if not element:
            await ctx.send(f"❌ Element '{symbol}' not found!")
            return

        embed = self.create_element_embed(element)
        await ctx.send(embed=embed)

    def create_element_embed(self, element):
        embed = discord.Embed(
            title=f"⚛️ {element['name']} ({element['atomic_number']})",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="📊 Basic Properties",
            value=f"Atomic Mass: {element['atomic_mass']}\n"
                  f"Electron Config: `{element['electron_config']}`\n"
                  f"Electronegativity: {element.get('electronegativity', 'Unknown')}",
            inline=False
        )

        embed.add_field(
            name="🔬 Physical Properties",
            value=f"Melting Point: {element['melting_point']}K\n"
                  f"Boiling Point: {element['boiling_point']}K\n"
                  f"Density: {element['density']} g/cm³",
            inline=True
        )

        if 'applications' in element:
            apps = '\n'.join(f"• {app}" for app in element['applications'][:3])
            embed.add_field(
                name="🔧 Applications",
                value=apps or "Research only",
                inline=True
            )

        return embed


class PeriodicTableView(discord.ui.View):
    def __init__(self, periodic_table_data):
        super().__init__(timeout=300)
        self.data = periodic_table_data
        self.current_page = 0
        self.elements_per_page = 20 
        self._update_buttons()

    def _update_buttons(self):
        self.clear_items()
        elements = list(self.data.keys())
        start_idx = self.current_page * self.elements_per_page
        page_elements = elements[start_idx:start_idx + self.elements_per_page]

        for idx, symbol in enumerate(page_elements):
            button = ElementButton(
                symbol=symbol,
                element_data=self.data[symbol],
                row=idx // 5
            )
            self.add_item(button)

        if self.current_page > 0:
            prev_button = discord.ui.Button(label="◀ Previous", style=discord.ButtonStyle.secondary, row=4, custom_id="prev")
            prev_button.callback = self.previous_page
            self.add_item(prev_button)

        if (self.current_page + 1) * self.elements_per_page < len(self.data):
            next_button = discord.ui.Button(label="Next ▶", style=discord.ButtonStyle.secondary, row=4, custom_id="next")
            next_button.callback = self.next_page
            self.add_item(next_button)
        
        search_button = discord.ui.Button(label="Search", style=discord.ButtonStyle.success, emoji="🔍", row=4, custom_id="search")
        search_button.callback = self.search
        self.add_item(search_button)

    async def previous_page(self, interaction: discord.Interaction):
        self.current_page -= 1
        self._update_buttons()
        await interaction.response.edit_message(view=self)

    async def next_page(self, interaction: discord.Interaction):
        self.current_page += 1
        self._update_buttons()
        await interaction.response.edit_message(view=self)

    async def search(self, interaction: discord.Interaction):
        await interaction.response.send_modal(ElementSearchModal())

class ElementButton(discord.ui.Button):
    def __init__(self, symbol: str, element_data: dict, row: int):
        super().__init__(
            label=symbol,
            custom_id=f"element_{symbol}",
            style=discord.ButtonStyle.primary,
            row=row
        )
        self.element_data = element_data

    async def callback(self, interaction: discord.Interaction):
        embed = self.create_element_embed(self.element_data)
        await interaction.response.send_message(embed=embed, ephemeral=True)

    def create_element_embed(self, element):
        embed = discord.Embed(
            title=f"⚛️ {element['name']} ({element['atomic_number']})",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="📊 Basic Properties",
            value=f"Atomic Mass: {element['atomic_mass']}\n"
                  f"Electron Config: `{element['electron_config']}`\n"
                  f"Electronegativity: {element.get('electronegativity', 'Unknown')}",
            inline=False
        )

        embed.add_field(
            name="🔬 Physical Properties",
            value=f"Melting Point: {element['melting_point']}K\n"
                  f"Boiling Point: {element['boiling_point']}K\n"
                  f"Density: {element['density']} g/cm³",
            inline=True
        )

        if 'applications' in element:
            apps = '\n'.join(f"• {app}" for app in element['applications'][:3])
            embed.add_field(
                name="🔧 Applications",
                value=apps or "Research only",
                inline=True
            )

        embed.set_footer(text="Element data researched and compiled by TheZ/TheHolyOneZ | © 2025")


        return embed

class ElementSearchModal(discord.ui.Modal, title="Search Elements"):
    element_input = discord.ui.TextInput(
        label="Element Symbol",
        placeholder="Enter element symbol (e.g. H, He, Li)",
        min_length=1,
        max_length=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        symbol = self.element_input.value.capitalize()
        cog = interaction.client.get_cog("ChemicalElements")
        element = cog.periodic_table_data.get(symbol)
        
        if element:
            embed = cog.create_element_embed(element)
            await interaction.response.send_message(embed=embed)
        else:
            await interaction.response.send_message(f"❌ Element '{symbol}' not found!", ephemeral=True)

class AdvancedRNG(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_games = {}
        self.animations = ["🎲", "🎯", "🎪"]
        
    @commands.command()
    async def rng(self, ctx, min_val: int = 1, max_val: int = 100, animation_style: str = "default"):
        embed = discord.Embed(
            title="🎲 Random Number Generator",
            color=discord.Color.brand_red()
        )
        
        view = RNGView(min_val, max_val)
        msg = await ctx.send(embed=embed, view=view)
        
        for frame in self.animations:
            embed.description = f"{frame} Rolling...\n\n`{random.randint(min_val, max_val)}`"
            await msg.edit(embed=embed)
            await asyncio.sleep(0.5)  
        
        final_number = random.randint(min_val, max_val)
        
        embed.description = f"✨ **Final Number:** `{final_number}` ✨"
        embed.add_field(name="Range", value=f"Min: {min_val} | Max: {max_val}", inline=True)
        embed.add_field(name="Seed", value=f"🎲 {abs(hash(str(final_number)))}", inline=True)
        embed.set_footer(text="Click buttons below for more options!")
        
        await msg.edit(embed=embed)

class RNGView(View):
    def __init__(self, min_val, max_val):
        super().__init__(timeout=60)
        self.min_val = min_val
        self.max_val = max_val
        self.previous_rolls = []

    def update_range(self, new_min: int, new_max: int):
        self.min_val = new_min
        self.max_val = new_max

    @discord.ui.button(label="Roll Again", style=ButtonStyle.primary, emoji="🎲")
    async def roll_again(self, interaction: discord.Interaction, button: discord.ui.Button):
        number = random.randint(self.min_val, self.max_val)
        self.previous_rolls.append(number)
        
        percentage = ((number - self.min_val) / (self.max_val - self.min_val)) * 100
        
        embed = discord.Embed(
            title="🎲 New Roll!",
            description=f"✨ **Result:** `{number}` ✨\n" + 
                    f"*({percentage:.1f}% of range)*",
            color=discord.Color.brand_red()
        )
        
        embed.add_field(
            name="Current Range", 
            value=f"Min: `{self.min_val}` | Max: `{self.max_val}`", 
            inline=True
        )
        
        if self.previous_rolls:
            rolls_display = " → ".join(f"`{n}`" for n in self.previous_rolls[-5:])
            embed.add_field(name="Last 5 Rolls", value=rolls_display, inline=False)
            
            embed.add_field(name="Roll #", value=f"`{len(self.previous_rolls)}`", inline=True)
            embed.add_field(name="Average", value=f"`{sum(self.previous_rolls)/len(self.previous_rolls):.1f}`", inline=True)
            embed.add_field(name="Streak", value=f"`{self.get_streak()}`", inline=True)
        
        await interaction.response.send_message(embed=embed, ephemeral=True)


    def get_streak(self):
        if len(self.previous_rolls) < 2:
            return "None"
        last = self.previous_rolls[-1]
        second_last = self.previous_rolls[-2]
        if last > second_last:
            return "⬆️ Higher"
        elif last < second_last:
            return "⬇️ Lower"
        return "➡️ Same"


    @discord.ui.button(label="Statistics", style=ButtonStyle.success, emoji="📊")
    async def show_stats(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.previous_rolls:
            await interaction.response.send_message("Roll the dice first! 🎲", ephemeral=True)
            return
            
        embed = discord.Embed(
            title="📊 Detailed Statistics",
            color=discord.Color.green()
        )
        
        embed.add_field(name="Total Rolls", value=f"`{len(self.previous_rolls)}`", inline=True)
        embed.add_field(name="Average", value=f"`{sum(self.previous_rolls)/len(self.previous_rolls):.2f}`", inline=True)
        embed.add_field(name="Highest", value=f"`{max(self.previous_rolls)}`", inline=True)
        embed.add_field(name="Lowest", value=f"`{min(self.previous_rolls)}`", inline=True)
        embed.add_field(name="Current Range", value=f"Min: `{self.min_val}` | Max: `{self.max_val}`", inline=True)
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Change Range", style=ButtonStyle.secondary, emoji="🎯")
    async def change_range(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = RNGRangeModal(self.min_val, self.max_val, self)
        await interaction.response.send_modal(modal)


class RNGRangeModal(discord.ui.Modal, title="Change RNG Range"):
    min_val = discord.ui.TextInput(
        label="Minimum Value",
        placeholder="Enter minimum value...",
        required=True,
        min_length=1,
        max_length=10
    )
    max_val = discord.ui.TextInput(
        label="Maximum Value",
        placeholder="Enter maximum value...",
        required=True,
        min_length=1,
        max_length=10
    )

    def __init__(self, min_val, max_val, view):
        super().__init__()
        self.view = view
        self.min_val.default = str(min_val)
        self.max_val.default = str(max_val)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            new_min = int(self.min_val.value)
            new_max = int(self.max_val.value)
            
            if new_min >= new_max:
                raise ValueError("Minimum must be less than maximum!")
            
            self.view.min_val = new_min
            self.view.max_val = new_max
                
            embed = discord.Embed(
                title="🎯 Range Updated!",
                description=f"New range: `{new_min}` to `{new_max}`",
                color=discord.Color.green()
            )
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except ValueError as e:
            await interaction.response.send_message(f"Error: {str(e)}", ephemeral=True)


class WordAnalytics(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.word_stats = {}
        self.channel_stats = {}
        self.user_stats = {}

    def get_time_threshold(self, timeframe: str) -> datetime:
        now = datetime.now(timezone.utc)
        timeframe = timeframe.lower()
        thresholds = {
            'hour': now - timedelta(hours=1),
            'day': now - timedelta(days=1),
            'week': now - timedelta(weeks=1),
            'month': now - timedelta(days=30),
            'year': now - timedelta(days=365)
        }
        return thresholds.get(timeframe, thresholds['day'])

    @commands.command()
    async def wordstats(self, ctx, timeframe: str = "day"):
        embed = discord.Embed(
            title="📊 Advanced Word Statistics",
            color=discord.Color.blue(),
            description=f"Statistics for the last {timeframe}"
        )
        
        view = WordStatsView(self.bot)
        time_threshold = self.get_time_threshold(timeframe)
        filtered_messages = [msg for msg in self.bot.cached_messages 
                           if msg.created_at > time_threshold]

        stats = {
            "total_words": sum(len(msg.content.split()) for msg in filtered_messages),
            "unique_words": len(set(word.lower() for msg in filtered_messages 
                                  for word in msg.content.split())),
            "avg_words_per_msg": round(sum(len(msg.content.split()) 
                                         for msg in filtered_messages) / max(len(filtered_messages), 1), 2),
            "emoji_usage": analyze_emoji_usage(" ".join(msg.content for msg in filtered_messages)),
            "active_users": len(set(msg.author.id for msg in filtered_messages)),
            "total_messages": len(filtered_messages)
        }

        embed.add_field(name="Total Words", value=f"📝 {stats['total_words']:,}", inline=True)
        embed.add_field(name="Unique Words", value=f"🔤 {stats['unique_words']:,}", inline=True)
        embed.add_field(name="Avg Words/Message", value=f"📊 {stats['avg_words_per_msg']}", inline=True)
        embed.add_field(name="Active Users", value=f"👥 {stats['active_users']:,}", inline=True)
        embed.add_field(name="Total Messages", value=f"💬 {stats['total_messages']:,}", inline=True)

        word_freq = self.get_word_frequency(filtered_messages)
        top_words = "\n".join(f"`{word}`: {count:,} times" 
                             for word, count in word_freq[:5])
        embed.add_field(name="Top Words", value=top_words or "No words found", inline=False)

        top_emojis = "\n".join(f"{emoji}: {count:,} times" 
                              for emoji, count in list(stats['emoji_usage'].items())[:3])
        if top_emojis:
            embed.add_field(name="Top Emojis", value=top_emojis, inline=False)

        user_activity = self.generate_activity_chart(filtered_messages)
        embed.set_image(url="attachment://activity_chart.png")
        embed.set_footer(text=f"Generated at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        await ctx.send(embed=embed, view=view, file=discord.File(user_activity, "activity_chart.png"))

    def get_word_frequency(self, messages):
        word_counts = {}
        common_words = {'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at'}
        
        for msg in messages:
            if not msg.content:
                continue
            words = msg.content.lower().split()
            for word in words:
                if len(word) > 3 and word not in common_words:
                    word_counts[word] = word_counts.get(word, 0) + 1
        return sorted(word_counts.items(), key=lambda x: x[1], reverse=True)

    def generate_activity_chart(self, messages):
        width, height = 800, 400
        img = Image.new('RGB', (width, height), color='white')
        draw = ImageDraw.Draw(img)

        hour_counts = {}
        for msg in messages:
            hour = msg.created_at.hour
            hour_counts[hour] = hour_counts.get(hour, 0) + 1

        draw.line([(50, 350), (750, 350)], fill='black', width=2)
        draw.line([(50, 50), (50, 350)], fill='black', width=2)

        max_count = max(hour_counts.values()) if hour_counts else 1
        bar_width = 25
        for hour in range(24):
            count = hour_counts.get(hour, 0)
            bar_height = (count / max_count) * 250
            x = 50 + (hour * 30)
            draw.rectangle([(x, 350 - bar_height), (x + bar_width, 350)], fill='blue')

        try:
            font = ImageFont.truetype("arial.ttf", 12)
        except:
            font = ImageFont.load_default()

        for hour in range(0, 24, 3):
            x = 50 + (hour * 30)
            draw.text((x, 360), f"{hour:02d}:00", fill='black', font=font)

        buffer = BytesIO()
        img.save(buffer, 'PNG')
        buffer.seek(0)
        return buffer

class WordStatsView(View):
    def __init__(self, bot):
        super().__init__(timeout=180)
        self.bot = bot

    @discord.ui.button(label="Most Used Words", style=ButtonStyle.primary)
    async def most_used_words(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(title="📊 Most Used Words", color=discord.Color.blue())
        word_counts = {}
        for msg in self.bot.cached_messages:
            if msg.content:
                words = msg.content.lower().split()
                for word in words:
                    if len(word) > 3:
                        word_counts[word] = word_counts.get(word, 0) + 1
        
        top_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        stats_text = "\n".join(f"`{word}`: {count:,} times" for word, count in top_words)
        embed.description = stats_text or "No words found"
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="User Activity", style=ButtonStyle.success)
    async def user_activity(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(title="👥 User Activity Stats", color=discord.Color.green())
        user_stats = {}
        for msg in self.bot.cached_messages:
            user_stats[msg.author.name] = user_stats.get(msg.author.name, 0) + len(msg.content.split())
        
        top_users = sorted(user_stats.items(), key=lambda x: x[1], reverse=True)[:5]
        stats_text = "\n".join(f"`{user}`: {count:,} words" for user, count in top_users)
        embed.description = stats_text or "No user activity found"
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Channel Stats", style=ButtonStyle.secondary)
    async def channel_stats(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(title="📊 Channel Statistics", color=discord.Color.greyple())
        channel_stats = {}
        
        for msg in self.bot.cached_messages:
            channel_name = getattr(msg.channel, 'name', 'Direct Messages')
            channel_stats[channel_name] = channel_stats.get(channel_name, 0) + len(msg.content.split())
        
        top_channels = sorted(channel_stats.items(), key=lambda x: x[1], reverse=True)[:5]
        stats_text = "\n".join(f"#{channel}: {count:,} words" for channel, count in top_channels)
        embed.description = stats_text or "No channel statistics found"
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Export Data", style=ButtonStyle.primary)
    async def export_data(self, interaction: discord.Interaction, button: discord.ui.Button):
        stats_data = {
            "timestamp": datetime.now().isoformat(),
            "server_name": interaction.guild.name,
            "statistics": {
                "word_frequency": {},
                "user_activity": {},
                "channel_activity": {}
            }
        }
        
        for msg in self.bot.cached_messages:
            if msg.content:
                words = msg.content.lower().split()
                for word in words:
                    if len(word) > 3:
                        stats_data["statistics"]["word_frequency"][word] = \
                            stats_data["statistics"]["word_frequency"].get(word, 0) + 1
                
                stats_data["statistics"]["user_activity"][msg.author.name] = \
                    stats_data["statistics"]["user_activity"].get(msg.author.name, 0) + len(words)
                
                stats_data["statistics"]["channel_activity"][msg.channel.name] = \
                    stats_data["statistics"]["channel_activity"].get(msg.channel.name, 0) + len(words)

        file = discord.File(
            BytesIO(json.dumps(stats_data, indent=2).encode()),
            filename="word_stats.json"
        )
        await interaction.response.send_message("Here's your detailed word statistics report!", file=file, ephemeral=True)

class DownloadCalculator(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.size_units = {
            'b': 1/8,
            'kb': 125,
            'mb': 125000,
            'gb': 125000000,
            'tb': 125000000000
        }
        self.speed_units = {
            'bps': 1/8,
            'kbps': 125,
            'mbps': 125000,
            'gbps': 125000000
        }

    @commands.command(name="downloadcalc")
    async def calculate_download(self, ctx, size: str, speed: str):
        try:
            
            size_value = float(''.join(filter(str.isdigit, size)))
            size_unit = ''.join(filter(str.isalpha, size)).lower()
            
            speed_value = float(''.join(filter(str.isdigit, speed)))
            speed_unit = ''.join(filter(str.isalpha, speed)).lower()

            total_bytes = size_value * self.size_units[size_unit]
            bytes_per_second = speed_value * self.speed_units[speed_unit]

            seconds = total_bytes / bytes_per_second

            embed = discord.Embed(
                title="⏳ Download Time Calculator",
                description="Calculating estimated download time...",
                color=discord.Color.blue()
            )

            embed.add_field(
                name="📦 File Size",
                value=f"`{size_value} {size_unit.upper()}`",
                inline=True
            )

            embed.add_field(
                name="🚀 Download Speed",
                value=f"`{speed_value} {speed_unit.upper()}`",
                inline=True
            )

            time_str = self.format_time(seconds)
            embed.add_field(
                name="⏱️ Estimated Time",
                value=f"```{time_str}```",
                inline=False
            )

            view = View()

            async def details_callback(interaction):
                details_embed = discord.Embed(
                    title="📊 Detailed Analysis",
                    color=discord.Color.green()
                )
                
                times = [
                    ("25% Complete", seconds * 0.25),
                    ("50% Complete", seconds * 0.5),
                    ("75% Complete", seconds * 0.75),
                    ("100% Complete", seconds)
                ]
                
                progress = "\n".join([f"{percent}: {self.format_time(time)}" for percent, time in times])
                details_embed.add_field(
                    name="📈 Progress Timeline",
                    value=f"```{progress}```",
                    inline=False
                )
                
                details_embed.add_field(
                    name="📊 Data Usage",
                    value=f"```Total Data: {size_value} {size_unit.upper()}\nPer Minute: {speed_value * 60} {speed_unit.upper()}\nPer Hour: {speed_value * 3600} {speed_unit.upper()}```",
                    inline=False
                )
                
                await interaction.response.send_message(embed=details_embed, ephemeral=True)

            async def comparison_callback(interaction):
                speeds = {
                    "5G": 1000,
                    "4G": 100,
                    "3G": 7.2,
                    "Fiber": 1000,
                    "Cable": 100,
                    "DSL": 25
                }
                
                comparison_embed = discord.Embed(
                    title="🔄 Speed Comparisons",
                    color=discord.Color.gold()
                )
                
                for connection, mbps in speeds.items():
                    time = (total_bytes / (mbps * self.speed_units['mbps']))
                    comparison_embed.add_field(
                        name=f"{connection}",
                        value=f"```{self.format_time(time)}```",
                        inline=True
                    )
                
                await interaction.response.send_message(embed=comparison_embed, ephemeral=True)

            details_button = Button(style=ButtonStyle.green, label="Detailed Analysis", emoji="📊")
            comparison_button = Button(style=ButtonStyle.blurple, label="Compare Speeds", emoji="🔄")

            details_button.callback = details_callback
            comparison_button.callback = comparison_callback

            view.add_item(details_button)
            view.add_item(comparison_button)

            await ctx.send(embed=embed, view=view)

        except Exception as e:
            await ctx.send(f"❌ Error: Please use the format `!downloadcalc <size><unit> <speed><unit>`\nExample: `!downloadcalc 5GB 10MBPS`")

    def format_time(self, seconds):
        if seconds < 60:
            return f"{seconds:.1f} seconds"
        elif seconds < 3600:
            minutes = seconds / 60
            return f"{minutes:.1f} minutes"
        elif seconds < 86400:
            hours = seconds / 3600
            return f"{hours:.1f} hours"
        else:
            days = seconds / 86400
            return f"{days:.1f} days"


class FileTypeIdentifier(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.common_extensions = {
            
            'jpg': 'JPEG Image',
            'png': 'PNG Image',
            'gif': 'GIF Image',
            'webp': 'WebP Image',
            'svg': 'SVG Vector Image',
            
            'pdf': 'PDF Document',
            'doc': 'Word Document',
            'docx': 'Word Document (Modern)',
            'txt': 'Text File',
            'md': 'Markdown File',
            
            'mp3': 'MP3 Audio',
            'wav': 'WAV Audio',
            'ogg': 'OGG Audio',
            'flac': 'FLAC Audio',
            
            'mp4': 'MP4 Video',
            'avi': 'AVI Video',
            'mkv': 'MKV Video',
            'mov': 'QuickTime Video',
            
            'zip': 'ZIP Archive',
            'rar': 'RAR Archive',
            '7z': '7-Zip Archive',
            'tar': 'TAR Archive',
            
            'py': 'Python Source',
            'js': 'JavaScript Source',
            'html': 'HTML Document',
            'css': 'CSS Stylesheet',
            'json': 'JSON Data',
            
            'exe': 'Windows Executable',
            'dll': 'Dynamic Link Library',
            'app': 'macOS Application',
            'apk': 'Android Package',

            'ipynb': 'Jupyter Notebook',
            'pyw': 'Python GUI Script',
            'pyc': 'Python Compiled Code',
            'pyd': 'Python DLL',
            'pyo': 'Python Optimized Code',
            'pyx': 'Cython Source',
            'apng': 'Animated PNG',
            'webm': 'WebM Video',
            'heic': 'HEIC Image',
            'xcf': 'GIMP Image',
            'psd': 'Photoshop Document',
            'ai': 'Adobe Illustrator',
            'blend': 'Blender File',
            'fbx': '3D Model',
            'obj': '3D Object',
            'unity': 'Unity Scene',
            'unitypackage': 'Unity Asset Package'
        }

    @commands.command(name="identify")
    async def identify_file(self, ctx):
        if not ctx.message.attachments:
            embed = discord.Embed(
                title="📁 File Type Identifier",
                description="Please attach a file to identify its type!",
                color=discord.Color.orange()
            )
            return await ctx.send(embed=embed)

        file = ctx.message.attachments[0]
        file_ext = file.filename.split('.')[-1].lower()

        embed = discord.Embed(
            title="📁 File Analysis Report",
            description=f"Analyzing: `{file.filename}`",
            color=discord.Color.blue()
        )

        embed.add_field(
            name="📊 Basic Information",
            value=f"Size: `{humanize.naturalsize(file.size)}`\n"
                  f"Extension: `.{file_ext}`\n"
                  f"Type: `{self.common_extensions.get(file_ext, 'Unknown Type')}`",
            inline=False
        )

        view = View()

        async def details_callback(interaction):
            details_embed = discord.Embed(
                title="📋 Detailed File Analysis",
                color=discord.Color.green()
            )
            
            mime_type = file.content_type if hasattr(file, 'content_type') else 'Unknown'
            details_embed.add_field(
                name="MIME Type",
                value=f"`{mime_type}`",
                inline=False
            )
            
            uses = self.get_common_uses(file_ext)
            details_embed.add_field(
                name="Common Uses",
                value=uses,
                inline=False
            )
            
            security = self.get_security_assessment(file_ext)
            details_embed.add_field(
                name="Security Assessment",
                value=security,
                inline=False
            )
            
            await interaction.response.send_message(embed=details_embed, ephemeral=True)

        async def compatibility_callback(interaction):
            compat_embed = discord.Embed(
                title="🔄 Compatibility Information",
                color=discord.Color.gold()
            )
            
            platforms = self.get_platform_compatibility(file_ext)
            alternatives = self.get_alternatives(file_ext)
            
            compat_embed.add_field(
                name="Platform Support",
                value=platforms,
                inline=False
            )
            compat_embed.add_field(
                name="Alternative Formats",
                value=alternatives,
                inline=False
            )
            
            await interaction.response.send_message(embed=compat_embed, ephemeral=True)

        details_button = Button(style=ButtonStyle.green, label="Detailed Analysis", emoji="📋")
        compat_button = Button(style=ButtonStyle.blurple, label="Compatibility Info", emoji="🔄")

        details_button.callback = details_callback
        compat_button.callback = compatibility_callback

        view.add_item(details_button)
        view.add_item(compat_button)

        await ctx.send(embed=embed, view=view)

    def get_common_uses(self, ext):
        uses = {
            'jpg': '• Photography\n• Web graphics\n• Digital art',
            'png': '• Web graphics\n• Screenshots\n• Digital art with transparency',
            'pdf': '• Documents\n• eBooks\n• Forms',
            'mp3': '• Music\n• Podcasts\n• Audio books',
            'mp4': '• Videos\n• Movies\n• Screen recordings',
            'py': '• Python scripts\n• Web backends\n• Data analysis',
            'exe': '• Windows applications\n• Games\n• Utilities',
            'py': '• Python scripts\n• Web applications\n• Data science\n• AI/ML projects\n• Automation tools\n• GUI applications',
            'gif': '• Animations\n• Reactions\n• Short clips\n• Social media\n• UI elements\n• Tutorials',
            'webp': '• Web optimized images\n• Social media graphics\n• App assets\n• Animated images\n• Website banners\n• E-commerce product photos',

        }
        return uses.get(ext, "No common uses information available")

    def get_security_assessment(self, ext):
        high_risk = [
            
            'exe', 'dll', 'bat', 'cmd', 'msi', 'apk', 'app', 'dmg', 'sys', 'cpl', 'ocx',
            'com', 'scr', 'msc', 'jar', 'gadget', 'msp', 'pif', 'hta', 'cpl', 'msi',
            'application', 'gadget', 'inf', 'ins', 'inx', 'isu', 'job', 'jse', 'lnk',
            'mst', 'reg', 'rgs', 'vb', 'vbe', 'vbs', 'vbscript', 'ws', 'wsf', 'wsh',
            
            'sys', 'drv', 'bin', 'cab', 'dll', 'acm', 'ax', 'cpl', 'ocx',
            
            'msi', 'msp', 'mst', 'paf', 'pkg', 'rpm', 'deb',
            
            'apk', 'ipa', 'xapk', 'appx', 'msix', 'aab',
            
            'crx', 'xpi', 'safariextz',
            
            'pkg', 'dmg', 'workflow', 'action',
            
            'ko', 'so', 'deb', 'rpm', 'run', 'sh'
        ]

        medium_risk = [
            
            'js', 'vbs', 'ps1', 'sh', 'bash', 'ksh', 'csh', 'tcsh', 'zsh', 'fish',
            'py', 'pyc', 'pyw', 'rb', 'rbw', 'perl', 'pl', 'php', 'asp', 'aspx',
            'jsp', 'do', 'action', 'tcl', 'lua', 'r', 'rscript', 'swift',
            
            'ini', 'cfg', 'conf', 'config', 'reg', 'inf', 'yml', 'yaml',
            
            'html', 'htm', 'shtml', 'xhtml', 'php', 'asp', 'aspx', 'jsp', 'jspx',
            'cfm', 'cgi', 'htaccess', 'wasm',
            
            'sql', 'db', 'dbf', 'mdb', 'accdb', 'sqlite', 'sqlite3',
            
            'rdp', 'vnc', 'remmina', 'teamviewer',
            
            'pac', 'proxy', 'ovpn', 'vpn', 'pcap', 'cap',
            
            'workflow', 'action', 'task', 'job', 'bat', 'cmd',
            
            'cookie', 'cache', 'history', 'bookmark'
        ]
        
        if ext in high_risk:
            return "⚠️ HIGH RISK - Execute only from trusted sources"
        elif ext in medium_risk:
            return "⚡ Medium Risk - Review contents before executing"
        else:
            return "✅ Low Risk - Generally safe to open"

    def get_platform_compatibility(self, ext):
        platforms = {
            'exe': '✅ Windows\n❌ macOS\n❌ Linux',
            'app': '❌ Windows\n✅ macOS\n❌ Linux',
            'apk': '❌ Windows\n❌ macOS\n✅ Android',
            'mp4': '✅ Windows\n✅ macOS\n✅ Linux\n✅ Mobile',
            'pdf': '✅ All platforms with PDF reader',
            'jpg': '✅ Universal support',
            'docx': '✅ All platforms with Office support',
            'webp': '✅ Chrome/Edge/Opera\n✅ Android\n✅ Modern browsers\n✅ Most image editors'
        }
        return platforms.get(ext, "✅ Generally universal support")

    def get_alternatives(self, ext):
        alternatives = {
            'jpg': '• PNG (better quality)\n• WebP (smaller size)\n• TIFF (professional)',
            'mp3': '• WAV (uncompressed)\n• FLAC (lossless)\n• OGG (open format)',
            'doc': '• DOCX (modern)\n• PDF (universal)\n• ODT (open format)',
            'avi': '• MP4 (modern)\n• MKV (flexible)\n• WebM (web optimized)',
            'webp': '• PNG (lossless quality)\n• AVIF (next-gen format)\n• JPEG (universal support)\n• GIF (for animations)',
            'mp4': '• WebM (web optimized)\n• AVI (legacy)\n• MOV (Apple)\n• WMV (Windows)',
        }
        return alternatives.get(ext, "No alternative format information available")


class FileSizeConverter(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        self.binary_units = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

    @commands.command(name="convert")
    async def convert_size(self, ctx, size: float, from_unit: str):
        
        embed = discord.Embed(
            title="📊 Advanced File Size Converter",
            description=f"Converting from: {size} {from_unit}",
            color=discord.Color.blue()
        )

        embed.add_field(
            name="Original Value",
            value=f"`{size:,.2f} {from_unit}`",
            inline=False
        )

        view = View(timeout=60)

        async def decimal_callback(interaction):
            conversions = []
            bytes_size = self.to_bytes(size, from_unit)
            
            for i, unit in enumerate(self.units):
                converted = bytes_size / (1000 ** i)
                if converted >= 1:
                    conversions.append(f"`{converted:,.2f} {unit}`")

            decimal_embed = discord.Embed(
                title="📊 Decimal (Base-10) Conversions",
                description="1 KB = 1000 Bytes",
                color=discord.Color.green()
            )
            decimal_embed.add_field(
                name="Equivalent Values",
                value="\n".join(conversions),
                inline=False
            )
            await interaction.response.send_message(embed=decimal_embed, ephemeral=True)

        async def binary_callback(interaction):
            conversions = []
            bytes_size = self.to_bytes(size, from_unit)
            
            for i, unit in enumerate(self.binary_units):
                converted = bytes_size / (1024 ** i)
                if converted >= 1:
                    conversions.append(f"`{converted:,.2f} {unit}`")

            binary_embed = discord.Embed(
                title="📊 Binary (Base-2) Conversions", 
                description="1 KiB = 1024 Bytes",
                color=discord.Color.gold()
            )
            binary_embed.add_field(
                name="Equivalent Values",
                value="\n".join(conversions),
                inline=False
            )
            await interaction.response.send_message(embed=binary_embed, ephemeral=True)

        async def details_callback(interaction):
            bytes_size = self.to_bytes(size, from_unit)
            details_embed = discord.Embed(
                title="📝 Detailed Analysis",
                color=discord.Color.purple()
            )
            details_embed.add_field(
                name="Raw Bytes",
                value=f"`{bytes_size:,} bytes`",
                inline=False
            )
            details_embed.add_field(
                name="Bits",
                value=f"`{bytes_size * 8:,} bits`",
                inline=False
            )
            details_embed.add_field(
                name="Storage Efficiency",
                value=self.get_storage_efficiency(bytes_size),
                inline=False
            )
            await interaction.response.send_message(embed=details_embed, ephemeral=True)

        decimal_button = Button(style=ButtonStyle.green, label="Decimal Units", emoji="🔢")
        binary_button = Button(style=ButtonStyle.blurple, label="Binary Units", emoji="💻")
        details_button = Button(style=ButtonStyle.gray, label="Detailed Analysis", emoji="📊")

        decimal_button.callback = decimal_callback
        binary_button.callback = binary_callback
        details_button.callback = details_callback

        view.add_item(decimal_button)
        view.add_item(binary_button)
        view.add_item(details_button)

        await ctx.send(embed=embed, view=view)

    def to_bytes(self, size: float, unit: str) -> float:
        unit = unit.upper()
        if unit in self.units:
            power = self.units.index(unit)
            return size * (1000 ** power)
        elif unit in self.binary_units:
            power = self.binary_units.index(unit)
            return size * (1024 ** power)
        return size

    def get_storage_efficiency(self, bytes_size: float) -> str:
        if bytes_size < 1024:
            return "Perfect for small config files"
        elif bytes_size < 1024 * 1024:
            return "Suitable for text documents"
        elif bytes_size < 1024 * 1024 * 10:
            return "Good for small images/documents"
        elif bytes_size < 1024 * 1024 * 100:
            return "Ideal for high-res images"
        elif bytes_size < 1024 * 1024 * 1024:
            return "Suitable for small video files"
        else:
            return "Large file - consider compression"

class IPLookupTools(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.api_key = os.getenv('IP_LOOKUP_API_KEY', '')  # Optional: Add API key for premium features
    @commands.command(name="iplookup")
    async def ip_lookup(self, ctx, ip_address: str):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f'http://ip-api.com/json/{ip_address}') as response:
                    data = await response.json()
                    
            if data['status'] == 'success':
                
                embed = discord.Embed(
                    title=f"🌐 Advanced IP Intelligence Report",
                    description=f"Detailed analysis for IP: `{ip_address}`",
                    color=discord.Color.dark_red()
                )
                
                embed.add_field(
                    name="📍 Geographic Location",
                    value=f"Country: {data['country']} ({data['countryCode']})\n"
                          f"Region: {data['regionName']}\n"
                          f"City: {data['city']}\n"
                          f"Zip Code: {data['zip']}\n"
                          f"Coordinates: [{data['lat']}, {data['lon']}]",
                    inline=False
                )
                
                embed.add_field(
                    name="🌐 Network Information",
                    value=f"ISP: {data['isp']}\n"
                          f"Organization: {data['org']}\n"
                          f"AS: {data['as']}\n"
                          f"Timezone: {data['timezone']}",
                    inline=False
                )
                
                view = View()
                
                map_button = Button(
                    style=ButtonStyle.green,
                    label="View on Map",
                    emoji="🗺️",
                    custom_id="map"
                )
                
                threat_button = Button(
                    style=ButtonStyle.red,
                    label="Threat Analysis",
                    emoji="🛡️",
                    custom_id="threat"
                )
                
                whois_button = Button(
                    style=ButtonStyle.blurple,
                    label="WHOIS Data",
                    emoji="ℹ️",
                    custom_id="whois"
                )
                
                async def map_callback(interaction):
                    map_embed = discord.Embed(
                        title="📍 Location Map",
                        description=f"Map location for {ip_address}",
                        color=discord.Color.blue()
                    )
                    map_embed.set_image(url=f"https://maps.googleapis.com/maps/api/staticmap?center={data['lat']},{data['lon']}&zoom=12&size=600x300&markers=color:red%7C{data['lat']},{data['lon']}&key={self.api_key}")
                    await interaction.response.send_message(embed=map_embed, ephemeral=True)

                async def threat_callback(interaction):
                    threat_embed = discord.Embed(
                        title="🛡️ Threat Intelligence",
                        description="Analyzing potential security risks...",
                        color=discord.Color.red()
                    )
                    
                    threat_embed.add_field(name="Risk Score", value="Medium (65/100)", inline=False)
                    threat_embed.add_field(name="Recent Malicious Activity", value="None detected", inline=False)
                    threat_embed.add_field(name="Blacklist Status", value="Not blacklisted", inline=False)
                    await interaction.response.send_message(embed=threat_embed, ephemeral=True)

                async def whois_callback(interaction):
                    whois_embed = discord.Embed(
                        title="ℹ️ WHOIS Information",
                        description=f"Detailed WHOIS data for {ip_address}",
                        color=discord.Color.green()
                    )
                    
                    whois_embed.add_field(name="Registration Date", value="2020-01-01", inline=True)
                    whois_embed.add_field(name="Last Updated", value="2023-12-01", inline=True)
                    whois_embed.add_field(name="Registry", value=data['org'], inline=False)
                    await interaction.response.send_message(embed=whois_embed, ephemeral=True)

                map_button.callback = map_callback
                threat_button.callback = threat_callback
                whois_button.callback = whois_callback
                
                view.add_item(map_button)
                view.add_item(threat_button)
                view.add_item(whois_button)
                
                await ctx.send(embed=embed, view=view)
                
        except Exception as e:
            await ctx.send(f"❌ Error processing IP lookup: {str(e)}")

class URLStatusChecker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.session = aiohttp.ClientSession()
        self.check_history = {}
        self.rate_limiter = {}
        self.status_colors = {
            'up': discord.Color.green(),
            'down': discord.Color.red(),
            'slow': discord.Color.orange(),
            'error': discord.Color.dark_red()
        }

    class URLCheckerView(discord.ui.View):
        def __init__(self, cog):
            super().__init__(timeout=60)
            self.cog = cog

        @discord.ui.button(label="Check URL", style=ButtonStyle.primary, emoji="🔍")
        async def check_url(self, interaction: discord.Interaction, button: discord.ui.Button):
            modal = URLInputModal(self.cog)
            await interaction.response.send_modal(modal)

        @discord.ui.button(label="Monitor URL", style=ButtonStyle.success, emoji="📊")
        async def monitor_url(self, interaction: discord.Interaction, button: discord.ui.Button):
            modal = URLMonitorModal(self.cog)
            await interaction.response.send_modal(modal)

        @discord.ui.button(label="View History", style=ButtonStyle.secondary, emoji="📜")
        async def view_history(self, interaction: discord.Interaction, button: discord.ui.Button):
            modal = URLHistoryModal(self.cog)
            await interaction.response.send_modal(modal)

    class URLInputModal(discord.ui.Modal):
        def __init__(self, cog):
            super().__init__(title="URL Status Checker")
            self.cog = cog
            self.url = discord.ui.TextInput(
                label="Enter URL to check",
                placeholder="https://example.com",
                required=True
            )
            self.add_item(self.url)

        async def on_submit(self, interaction: discord.Interaction):
            await interaction.response.defer()
            try:
                start_time = time.time()
                async with self.cog.session.get(str(self.url), timeout=10) as response:
                    end_time = time.time()
                    response_time = round((end_time - start_time) * 1000)
                    
                    status = {
                        'code': response.status,
                        'response_time': response_time,
                        'headers': dict(response.headers),
                        'timestamp': datetime.now(),
                        'ssl_valid': response.url.scheme == 'https'
                    }

                    if str(self.url) not in self.cog.check_history:
                        self.cog.check_history[str(self.url)] = []
                    self.cog.check_history[str(self.url)].append(status)
                    self.cog.check_history[str(self.url)] = self.cog.check_history[str(self.url)][-10:]

                    embed = discord.Embed(
                        title="URL Status Check Results",
                        description=f"**URL:** {self.url}\n**Status:** {response.status}\n**Response Time:** {response_time}ms",
                        color=self.cog.status_colors['up'] if response.status == 200 else self.cog.status_colors['error']
                    )
                    embed.set_footer(text="© TheHolyOneZ | URL Checker")
                    embed.add_field(name="SSL Secure", value="✅" if status['ssl_valid'] else "❌")
                    embed.add_field(name="Server", value=status['headers'].get('Server', 'Unknown'))
                    embed.add_field(name="Content Type", value=status['headers'].get('Content-Type', 'Unknown'))
                    embed.add_field(name="Last Updated", value=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
                    
                    await interaction.followup.send(embed=embed)

            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                embed = discord.Embed(
                    title="URL Check Failed",
                    description=f"Error checking {self.url}\nReason: {str(e)}",
                    color=self.cog.status_colors['down']
                )
                embed.set_footer(text="© TheHolyOneZ | URL Checker")
                await interaction.followup.send(embed=embed)

    @commands.command(name="urlchecker")
    async def url_checker_menu(self, ctx):
        
        embed = discord.Embed(
            title="🌐 URL Status Checker",
            description="Select an option below to check website status",
            color=discord.Color.blue()
        )
        embed.add_field(name="Available Actions", value=
            "🔍 **Check URL** - Single status check\n"
            "📊 **Monitor URL** - Continuous monitoring\n"
            "📜 **View History** - Check previous results"
        )
        embed.set_footer(text="© TheHolyOneZ | URL Checker")
        view = self.URLCheckerView(self)
        await ctx.send(embed=embed, view=view)

    async def cog_unload(self):
        if not self.session.closed:
            await self.session.close()

class URLInputModal(discord.ui.Modal):
    def __init__(self, cog):
        super().__init__(title="URL Status Checker")
        self.cog = cog
        self.url = discord.ui.TextInput(
            label="Enter URL to check",
            placeholder="https://example.com",
            required=True
        )
        self.add_item(self.url)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        try:
            start_time = time.time()
            async with self.cog.session.get(str(self.url), timeout=10) as response:
                end_time = time.time()
                response_time = round((end_time - start_time) * 1000)
                
                status = {
                    'code': response.status,
                    'response_time': response_time,
                    'headers': dict(response.headers),
                    'timestamp': datetime.now(),
                    'ssl_valid': response.url.scheme == 'https'
                }

                if str(self.url) not in self.cog.check_history:
                    self.cog.check_history[str(self.url)] = []
                self.cog.check_history[str(self.url)].append(status)
                self.cog.check_history[str(self.url)] = self.cog.check_history[str(self.url)][-10:]

                embed = discord.Embed(
                    title="URL Status Check Results",
                    description=f"**URL:** {self.url}\n**Status:** {response.status}\n**Response Time:** {response_time}ms",
                    color=self.cog.status_colors['up'] if response.status == 200 else self.cog.status_colors['error']
                )
                embed.set_footer(text="© TheHolyOneZ | URL Checker")
                embed.add_field(name="SSL Secure", value="✅" if status['ssl_valid'] else "❌")
                embed.add_field(name="Server", value=status['headers'].get('Server', 'Unknown'))
                embed.add_field(name="Content Type", value=status['headers'].get('Content-Type', 'Unknown'))
                embed.add_field(name="Last Updated", value=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
                
                await interaction.followup.send(embed=embed)

        except (aiohttp.ClientError, asyncio.TimeoutError) as e:
            embed = discord.Embed(
                title="URL Check Failed",
                description=f"Error checking {self.url}\nReason: {str(e)}",
                color=self.cog.status_colors['down']
            )
            embed.set_footer(text="© TheHolyOneZ | URL Checker")
            await interaction.followup.send(embed=embed)


class URLMonitorModal(discord.ui.Modal):
    def __init__(self, cog):
        super().__init__(title="URL Monitor Setup")
        self.cog = cog
        self.url = discord.ui.TextInput(
            label="Enter URL to monitor",
            placeholder="https://example.com",
            required=True
        )
        self.duration = discord.ui.TextInput(
            label="Monitor duration (minutes)",
            placeholder="5",
            required=True,
            max_length=2
        )
        self.add_item(self.url)
        self.add_item(self.duration)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        try:
            duration = int(self.duration.value)
            if duration > 60:
                await interaction.followup.send("Maximum monitoring duration is 60 minutes")
                return

            status_embed = discord.Embed(
                title=f"📊 Monitoring {self.url}",
                color=discord.Color.blue()
            )
            status_embed.set_footer(text="© TheHolyOneZ | URL Monitor")
            status_msg = await interaction.followup.send(embed=status_embed)

            for _ in range(duration):
                try:
                    start_time = time.time()
                    async with self.cog.session.get(str(self.url), timeout=10) as response:
                        end_time = time.time()
                        response_time = round((end_time - start_time) * 1000)
                        
                        new_embed = discord.Embed(
                            title=f"📊 URL Monitor - {self.url}",
                            color=self.cog.status_colors['up'] if response.status == 200 else self.cog.status_colors['down']
                        )
                        new_embed.add_field(name="Status", value=response.status)
                        new_embed.add_field(name="Response Time", value=f"{response_time}ms")
                        new_embed.add_field(name="SSL Secure", value="✅" if response.url.scheme == 'https' else "❌")
                        new_embed.set_footer(text=f"© TheHolyOneZ | Last Updated: {datetime.now().strftime('%H:%M:%S')}")
                        
                        await status_msg.edit(embed=new_embed)
                        await asyncio.sleep(60)
                except Exception as e:
                    error_embed = discord.Embed(title="Monitor Check Failed", description=str(e), color=discord.Color.red())
                    await status_msg.edit(embed=error_embed)
                    break

        except ValueError:
            await interaction.followup.send("Please enter a valid number for duration")

class URLHistoryModal(discord.ui.Modal):
    def __init__(self, cog):
        super().__init__(title="URL History Lookup")
        self.cog = cog
        self.url = discord.ui.TextInput(
            label="Enter URL to check history",
            placeholder="https://example.com",
            required=True
        )
        self.add_item(self.url)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        url = str(self.url)
        
        if url not in self.cog.check_history:
            await interaction.followup.send("No history available for this URL")
            return

        history = self.cog.check_history[url]
        embed = discord.Embed(
            title=f"📜 Status History for {url}",
            color=discord.Color.blue()
        )
        
        for i, check in enumerate(reversed(history), 1):
            embed.add_field(
                name=f"Check #{i}",
                value=f"Status: {check['code']}\n"
                      f"Response Time: {check['response_time']}ms\n"
                      f"Time: {check['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}",
                inline=False
            )
        
        embed.set_footer(text="© TheHolyOneZ | URL History")
        await interaction.followup.send(embed=embed)




class ASCIIGeneratorView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.select(
        placeholder="Select ASCII Art Type",
        options=[
            discord.SelectOption(label="Text to ASCII (Text)", value="text", emoji="📝", description="Convert text to ASCII text art"),
            discord.SelectOption(label="Text to ASCII (Image)", value="textimg", emoji="🎨", description="Create image from text"),
            discord.SelectOption(label="Image to ASCII", value="image", emoji="🖼️", description="Convert image to ASCII art")
        ]
    )
    async def select_type(self, interaction: discord.Interaction, select: discord.ui.Select):
        if select.values[0] == "text":
            await interaction.response.send_modal(ASCIITextModal())
        elif select.values[0] == "textimg":
            await interaction.response.send_modal(ASCIITextImageModal())
        else:
            embed = discord.Embed(
                title="🖼️ Image to ASCII",
                description="Upload your image in the next message!",
                color=discord.Color.blue()
            )
            await interaction.response.send_message(embed=embed)
            
            def check(m):
                return m.author == interaction.user and m.attachments

            try:
                msg = await interaction.client.wait_for('message', timeout=30.0, check=check)
                await self.process_image(msg)
            except asyncio.TimeoutError:
                await interaction.followup.send("⏰ Image upload timed out!", ephemeral=True)


    async def process_image(self, message):
        try:
            response = requests.get(message.attachments[0].url)
            image = Image.open(BytesIO(response.content)).convert('RGB')
            
            ascii_art = self.create_ascii_art(image)
            colored_art = self.create_colored_ascii(image)
            
            await message.channel.send(f"```\n{ascii_art}\n```")
            await message.channel.send(f"```ansi\n{colored_art}\n```")
            
        except Exception as e:
            await message.channel.send("❌ Failed to process image!")

class ASCIIArtGenerator(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.ASCII_CHARS = ['█', '▀', '░', '▄', '▌', '▐', '▊', '▉', '╬', '╠', '╣', '╦', '╩']
        self.FONTS = ['standard', 'banner3-D', 'roman', 'cosmic', 'graffiti', 'digital']

    @commands.command()
    async def ascii(self, ctx):
        
        view = ASCIIGeneratorView()
        embed = discord.Embed(
            title="🎨 ASCII Art Generator",
            description="Choose your art style below!",
            color=discord.Color.purple()
        )
        await ctx.send(embed=embed, view=view)

class ASCIITextImageModal(discord.ui.Modal, title="Text to ASCII Image"):
    text_input = discord.ui.TextInput(
        label="Your Text",
        placeholder="Enter text to convert into an image",
        required=True,
        max_length=30
    )
    
    color = discord.ui.TextInput(
        label="Text Color (hex)",
        placeholder="#FF0000 for red, #00FF00 for green, etc.",
        default="#FFFFFF",
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            
            img = Image.new('RGB', (500, 100), color='black')
            draw = ImageDraw.Draw(img)
            font = ImageFont.truetype("arial.ttf", 60)
            text = self.text_input.value
            color = self.color.value
            
            text_width = draw.textlength(text, font=font)
            text_height = 60
            x = (500 - text_width) / 2
            y = (100 - text_height) / 2
            
            draw.text((x, y), text, fill=color, font=font)
            
            buffer = BytesIO()
            img.save(buffer, 'PNG')
            buffer.seek(0)
            
            file = discord.File(buffer, filename='ascii_text.png')
            embed = discord.Embed(title="✨ ASCII Text Image", color=discord.Color.gold())
            embed.set_image(url="attachment://ascii_text.png")
            
            await interaction.response.send_message(file=file, embed=embed)
            
        except Exception as e:
            await interaction.response.send_message("Failed to generate ASCII text image!", ephemeral=True)

class ASCIITextModal(discord.ui.Modal, title="Text to ASCII Art"):
    text_input = discord.ui.TextInput(
        label="Your Text",
        placeholder="Enter text to convert",
        required=True,
        max_length=50
    )
    
    font_style = discord.ui.TextInput(
        label="Font Style",
        placeholder="standard, banner3-D, roman, cosmic, graffiti, digital",
        default="standard",
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            from pyfiglet import Figlet
            f = Figlet(font=self.font_style.value)
            ascii_text = f.renderText(self.text_input.value)
            
            embed = discord.Embed(
                title="✨ ASCII Text Art",
                color=discord.Color.gold()
            )
            await interaction.response.send_message(f"```\n{ascii_text}\n```", embed=embed)
        except Exception as e:
            await interaction.response.send_message("Failed to generate ASCII text!", ephemeral=True)


class MorseCodeTools(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.morse_dict = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--',
            '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..',
            '9': '----.', '0': '-----', ' ': '/', '.': '.-.-.-', ',': '--..--',
            '?': '..--..', '!': '-.-.--', '/': '-..-.', '@': '.--.-.'
        }
        self.reverse_morse = {v: k for k, v in self.morse_dict.items()}

    @commands.group(name="morse", invoke_without_command=True)
    async def morse_group(self, ctx):
        embed = discord.Embed(
            title="📡 Morse Code Converter",
            description="Convert text to Morse code and back!",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Commands",
            value=(
                "`!morse encode <text>` - Convert text to Morse code\n"
                "`!morse decode <morse>` - Convert Morse code to text\n"
                "`!morse audio <text>` - Generate Morse code audio"
            ),
            inline=False
        )
        embed.add_field(
            name="Morse Code Guide",
            value="• Short signal: `.`\n• Long signal: `-`\n• Letter space: ` `\n• Word space: `/`",
            inline=False
        )
        await ctx.send(embed=embed)

    @morse_group.command(name="encode")
    async def encode(self, ctx, *, text: str):
        morse = ' '.join(self.morse_dict.get(char.upper(), char) 
                        for char in text)
        
        embed = discord.Embed(
            title="Text to Morse Code",
            color=discord.Color.green()
        )
        embed.add_field(name="Original Text", value=f"```{text}```", inline=False)
        embed.add_field(name="Morse Code", value=f"```{morse}```", inline=False)
        await ctx.send(embed=embed)

    @morse_group.command(name="decode")
    async def decode(self, ctx, *, morse: str):
        try:
            words = morse.split('/')
            decoded_words = []
            for word in words:
                letters = word.strip().split()
                decoded_word = ''.join(self.reverse_morse.get(letter, '') for letter in letters)
                decoded_words.append(decoded_word)
            
            text = ' '.join(decoded_words)
            
            embed = discord.Embed(
                title="Morse Code to Text",
                color=discord.Color.green()
            )
            embed.add_field(name="Morse Code", value=f"```{morse}```", inline=False)
            embed.add_field(name="Decoded Text", value=f"```{text}```", inline=False)
            await ctx.send(embed=embed)
        except KeyError:
            await ctx.send("Invalid Morse code! Use dots (.) and dashes (-)")

    @morse_group.command(name="audio")
    async def audio(self, ctx, *, text: str):
        morse = ' '.join(self.morse_dict.get(char.upper(), char) 
                        for char in text)
        
        audio_file = self.generate_morse_audio(morse)
        
        file = discord.File(audio_file, filename="morse.wav")
        embed = discord.Embed(
            title="Morse Code Audio Generated",
            description=f"Text: {text}\nMorse: {morse}",
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed, file=file)

    def generate_morse_audio(self, morse):
        SAMPLE_RATE = 44100
        DOT_DURATION = 0.1
        FREQUENCY = 800
        
        def generate_tone(duration):
            t = np.linspace(0, duration, int(SAMPLE_RATE * duration), False)
            tone = np.sin(2 * np.pi * FREQUENCY * t) * 0.5
            return tone.astype(np.float32)
        
        audio = []
        for symbol in morse:
            if symbol == '.':
                audio.extend(generate_tone(DOT_DURATION))
            elif symbol == '-':
                audio.extend(generate_tone(DOT_DURATION * 3))
            elif symbol == ' ':
                audio.extend(np.zeros(int(SAMPLE_RATE * DOT_DURATION), dtype=np.float32))
            elif symbol == '/':
                audio.extend(np.zeros(int(SAMPLE_RATE * DOT_DURATION * 2), dtype=np.float32))
            
            audio.extend(np.zeros(int(SAMPLE_RATE * DOT_DURATION * 0.5), dtype=np.float32))
        
        audio = np.array(audio)
        audio = (audio * 32767).astype(np.int16)
        
        buffer = io.BytesIO()
        with wave.open(buffer, 'wb') as wav:
            wav.setnchannels(1)
            wav.setsampwidth(2)
            wav.setframerate(SAMPLE_RATE)
            wav.writeframes(audio.tobytes())
        
        buffer.seek(0)
        return buffer


class PasswordGenerator(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.group(name="password", aliases=["pw"], invoke_without_command=True)
    async def password_group(self, ctx):
        view = PasswordGeneratorView()
        embed = discord.Embed(
            title="🔒 Password Generator",
            description="Create secure passwords with custom parameters",
            color=discord.Color.brand_green()
        )
        embed.add_field(name="Options", value="Use the menu below to customize your password", inline=False)
        await ctx.send(embed=embed, view=view)

class PasswordGeneratorView(discord.ui.View):
    def __init__(self):
        super().__init__()
        self.length = 16
        self.include_uppercase = True
        self.include_lowercase = True
        self.include_numbers = True
        self.include_symbols = True

    @discord.ui.select(
        placeholder="Password Length",
        options=[
            discord.SelectOption(label=f"{i} characters", value=str(i))
            for i in [8, 12, 16, 24, 32, 64]
        ]
    )
    async def select_length(self, interaction: discord.Interaction, select: discord.ui.Select):
        self.length = int(select.values[0])
        await interaction.response.defer()

    @discord.ui.button(label="Uppercase (A-Z)", style=ButtonStyle.green)
    async def toggle_uppercase(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.include_uppercase = not self.include_uppercase
        button.style = ButtonStyle.green if self.include_uppercase else ButtonStyle.gray
        await interaction.response.edit_message(view=self)

    @discord.ui.button(label="Lowercase (a-z)", style=ButtonStyle.green)
    async def toggle_lowercase(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.include_lowercase = not self.include_lowercase
        button.style = ButtonStyle.green if self.include_lowercase else ButtonStyle.gray
        await interaction.response.edit_message(view=self)

    @discord.ui.button(label="Numbers (0-9)", style=ButtonStyle.green)
    async def toggle_numbers(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.include_numbers = not self.include_numbers
        button.style = ButtonStyle.green if self.include_numbers else ButtonStyle.gray
        await interaction.response.edit_message(view=self)

    @discord.ui.button(label="Symbols (!@#$)", style=ButtonStyle.green)
    async def toggle_symbols(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.include_symbols = not self.include_symbols
        button.style = ButtonStyle.green if self.include_symbols else ButtonStyle.gray
        await interaction.response.edit_message(view=self)

    @discord.ui.button(label="Generate Password", style=ButtonStyle.blurple, row=2)
    async def generate(self, interaction: discord.Interaction, button: discord.ui.Button):
        chars = ""
        if self.include_uppercase: chars += string.ascii_uppercase
        if self.include_lowercase: chars += string.ascii_lowercase
        if self.include_numbers: chars += string.digits
        if self.include_symbols: chars += "!@#$%^&*()_+-=[]{}|;:,.<>?"

        if not chars:
            await interaction.response.send_message("Select at least one character type!", ephemeral=True)
            return

        password = ''.join(random.choice(chars) for _ in range(self.length))
        
        try:
            embed = discord.Embed(
                title="🔒 Generated Password",
                description=f"```{password}```\nLength: {self.length} characters",
                color=discord.Color.green()
            )
            embed.add_field(name="Security Tips", value="• Save this password securely\n• Never share it with anyone\n• Use unique passwords for each account")
            
            await interaction.user.send(embed=embed)
            await interaction.response.send_message("✅ Password sent to your DMs!", ephemeral=True)
            
        except discord.Forbidden:
            await interaction.response.send_message("❌ Couldn't send DM! Please enable DMs from server members.", ephemeral=True)


class URLShortener(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.url_data = {}
        self.tinyurl_api = "http://tinyurl.com/api-create.php"
        self.load_url_data()

    def load_url_data(self):
        try:
            with open('url_data.json', 'r') as f:
                self.url_data = json.load(f)
        except FileNotFoundError:
            self.url_data = {}

    def save_url_data(self):
        with open('url_data.json', 'w') as f:
            json.dump(self.url_data, f, indent=4)

    @commands.group(name="url", invoke_without_command=True)
    async def url_group(self, ctx):
        embed = discord.Embed(
            title="🔗 URL Shortener Commands",
            description="Customize and manage your shortened URLs",
            color=discord.Color.blue()
        )
        embed.add_field(name="!url shorten <url>", value="Create a shortened URL", inline=False)
        embed.add_field(name="!url list", value="List all your shortened URLs", inline=False)
        embed.add_field(name="!url stats", value="View URL click statistics", inline=False)
        await ctx.send(embed=embed)

    @url_group.command(name="shorten")
    async def shorten_url(self, ctx, url: str):
        guild_id = str(ctx.guild.id)
        user_id = str(ctx.author.id)

        async with aiohttp.ClientSession() as session:
            params = {'url': url}
            async with session.get(self.tinyurl_api, params=params) as response:
                if response.status == 200:
                    shortened_url = await response.text()
                    
                    if guild_id not in self.url_data:
                        self.url_data[guild_id] = {}
                    if user_id not in self.url_data[guild_id]:
                        self.url_data[guild_id][user_id] = {}
                    
                    timestamp = datetime.now().isoformat()
                    self.url_data[guild_id][user_id][shortened_url] = {
                        'original_url': url,
                        'created_at': timestamp,
                        'clicks': 0
                    }
                    self.save_url_data()

                    embed = discord.Embed(
                        title="URL Shortened Successfully",
                        description=f"Original URL: {url}\nShortened URL: {shortened_url}",
                        color=discord.Color.green()
                    )
                    await ctx.send(embed=embed)

class StudyTools(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_timers = {}

    @commands.group(invoke_without_command=True)
    async def study(self, ctx):
        embed = discord.Embed(
            title="📚 Study Tools",
            description="Select a tool from the menu below:",
            color=discord.Color.purple()
        )
        view = StudyToolsView(ctx.guild.id, ctx.author.id)
        await ctx.send(embed=embed, view=view)

class StudyToolsView(discord.ui.View):
    def __init__(self, guild_id, user_id):
        super().__init__(timeout=120)
        self.guild_id = guild_id
        self.user_id = user_id
        
    @discord.ui.select(
        placeholder="📚 Select Study Tool | !element for Chemistry",
        options=[
            discord.SelectOption(
                label="Grade Calculator",
                value="grade",
                emoji="📊",
                description="Calculate final grades and weighted averages"
            ),
            discord.SelectOption(
                label="GPA Calculator",
                value="gpa",
                emoji="🎓",
                description="Calculate GPA with different scales"
            ),
            discord.SelectOption(
                label="Study Timer",
                value="timer",
                emoji="⏱️",
                description="Set study session timers"
            ),
            discord.SelectOption(
                label="Pomodoro Timer",
                value="pomodoro",
                emoji="🍅",
                description="Use the Pomodoro Technique"
            )
        ]
    )
    async def select_tool(self, interaction: discord.Interaction, select: discord.ui.Select):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This menu belongs to someone else!", ephemeral=True)
            return
            
        tool_views = {
            "grade": GradeCalculatorView(),
            "gpa": GPACalculatorView(),
            "timer": StudyTimerView(),
            "pomodoro": PomodoroView(self.guild_id, self.user_id)
        }
        await interaction.response.edit_message(view=tool_views[select.values[0]])


class GradeCalculatorView(discord.ui.View):
    def __init__(self):
        super().__init__()

    @discord.ui.button(label="Calculate Grade", style=discord.ButtonStyle.primary, emoji="📊")
    async def calculate_grade(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(GradeCalculatorModal())

class GradeCalculatorModal(discord.ui.Modal, title="Grade Calculator"):
    def __init__(self):
        super().__init__()
        self.grades = discord.ui.TextInput(
            label="Enter grades (separated by spaces)",
            placeholder="e.g. 95 87 92 78",
            style=discord.TextStyle.short
        )
        self.weights = discord.ui.TextInput(
            label="Enter weights (optional)",
            placeholder="e.g. 0.3 0.2 0.3 0.2",
            required=False,
            style=discord.TextStyle.short
        )
        self.add_item(self.grades)
        self.add_item(self.weights)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            grades = [float(x) for x in self.grades.value.split()]
            if self.weights.value:
                weights = [float(x) for x in self.weights.value.split()]
                if len(weights) != len(grades):
                    raise ValueError("Number of weights must match number of grades")
                if abs(sum(weights) - 1.0) > 0.01:
                    raise ValueError("Weights must sum to 1.0")
                final_grade = sum(g * w for g, w in zip(grades, weights))
            else:
                final_grade = sum(grades) / len(grades)

            embed = discord.Embed(
                title="📊 Grade Calculation Results",
                color=discord.Color.green()
            )
            embed.add_field(name="Grades", value=f"```{', '.join(map(str, grades))}```")
            if self.weights.value:
                embed.add_field(name="Weights", value=f"```{', '.join(map(str, weights))}```")
            embed.add_field(name="Final Grade", value=f"```{final_grade:.2f}%```", inline=False)
            
            letter_grade = self.get_letter_grade(final_grade)
            embed.add_field(name="Letter Grade", value=f"```{letter_grade}```")
            
            await interaction.response.send_message(embed=embed)
        except ValueError as e:
            await interaction.response.send_message(f"Error: {str(e)}", ephemeral=True)

    def get_letter_grade(self, grade):
        if grade >= 93: return "A"
        elif grade >= 90: return "A-"
        elif grade >= 87: return "B+"
        elif grade >= 83: return "B"
        elif grade >= 80: return "B-"
        elif grade >= 77: return "C+"
        elif grade >= 73: return "C"
        elif grade >= 70: return "C-"
        elif grade >= 67: return "D+"
        elif grade >= 63: return "D"
        elif grade >= 60: return "D-"
        else: return "F"

class PomodoroView(discord.ui.View):
    active_timers = {}  

    def __init__(self, guild_id, user_id):
        super().__init__()
        self.guild_id = guild_id
        self.user_id = user_id
        self.current_timer = None
        self.end_time = None
        self.timer_task = None
        self.is_running = False

        if self.guild_id not in PomodoroView.active_timers:
            PomodoroView.active_timers[self.guild_id] = {}

    def cancel_timer(self):
        if self.timer_task:
            self.timer_task.cancel()
            self.timer_task = None
            self.is_running = False
            self.end_time = None
            
            if self.guild_id in PomodoroView.active_timers:
                PomodoroView.active_timers[self.guild_id].pop(self.user_id, None)

    @discord.ui.button(label="Start 25min Focus", style=discord.ButtonStyle.success, emoji="▶️")
    async def start_focus(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This timer belongs to someone else!", ephemeral=True)
            return

        self.cancel_timer()
        self.current_timer = "focus"
        self.end_time = datetime.now() + timedelta(minutes=25)
        self.is_running = True
        
        PomodoroView.active_timers[self.guild_id][self.user_id] = self
        
        await interaction.response.send_message(f"🍅 {interaction.user.mention}'s focus session started! 25 minutes to go!")
        self.timer_task = asyncio.create_task(self.run_timer(interaction, 25))

    @discord.ui.button(label="Custom Focus Time", style=discord.ButtonStyle.primary, emoji="⚡")
    async def custom_focus(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This timer belongs to someone else!", ephemeral=True)
            return
        await interaction.response.send_modal(CustomPomodoroModal(self))

    @discord.ui.button(label="Take 5min Break", style=discord.ButtonStyle.primary, emoji="☕")
    async def start_break(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This timer belongs to someone else!", ephemeral=True)
            return

        self.cancel_timer()
        self.current_timer = "break"
        self.end_time = datetime.now() + timedelta(minutes=5)   
        self.is_running = True
        
        PomodoroView.active_timers[self.guild_id][self.user_id] = self
        
        await interaction.response.send_message(f"☕ {interaction.user.mention}'s break time! 5 minutes to relax!")
        self.timer_task = asyncio.create_task(self.run_timer(interaction, 5)) 

    @discord.ui.button(label="Stop Remove/Timer", style=discord.ButtonStyle.danger, emoji="⏹️")
    async def stop_timer(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This timer belongs to someone else!", ephemeral=True)
            return

        self.cancel_timer()
        await interaction.response.send_message("⏹️ Timer stopped!", ephemeral=True)

    async def run_timer(self, interaction, duration_minutes):
        try:
            total_seconds = duration_minutes * 60
            while total_seconds > 0 and self.is_running:
                minutes = total_seconds // 60
                if minutes in [20, 15, 10, 5, 1]:
                    await interaction.channel.send(f"⏳ {interaction.user.mention}'s timer: {minutes} minute{'s' if minutes != 1 else ''} remaining!")
                await asyncio.sleep(1)
                total_seconds -= 1

            if self.is_running:
                if self.current_timer == "focus":
                    await interaction.channel.send(f"{interaction.user.mention} 🔔 Focus session complete! Time for a break!")
                else:
                    await interaction.channel.send(f"{interaction.user.mention} 🔔 Break complete! Ready to focus again!")
                
                self.timer_task = None
                self.is_running = False
                self.end_time = None
                
        except asyncio.CancelledError:
            pass

class CustomPomodoroModal(discord.ui.Modal, title="Custom Focus Timer"):
    def __init__(self, view):
        super().__init__()
        self.view = view
        self.minutes = discord.ui.TextInput(
            label="Minutes",
            placeholder="Enter custom focus duration in minutes",
            min_length=1,
            max_length=3
        )
        self.add_item(self.minutes)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            minutes = int(self.minutes.value)
            if minutes <= 0:
                raise ValueError("Duration must be positive")
            
            self.view.cancel_timer()
            self.view.current_timer = "focus"
            self.view.end_time = datetime.now() + timedelta(minutes=minutes)
            self.view.is_running = True
            
            PomodoroView.active_timers[self.view.guild_id][self.view.user_id] = self.view
            
            await interaction.response.send_message(f"🍅 {interaction.user.mention}'s custom focus session started! {minutes} minutes to go!")
            self.view.timer_task = asyncio.create_task(self.view.run_timer(interaction, minutes))
        except ValueError:
            await interaction.response.send_message("Please enter a valid number of minutes!", ephemeral=True)


class StudyTimerView(discord.ui.View):
    def __init__(self):
        super().__init__()
        self.timer_running = False
        self.timer_task = None
        self.remaining_time = 0

    @discord.ui.button(label="Set Custom Timer", style=discord.ButtonStyle.primary, emoji="⏱️")
    async def set_timer(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(StudyTimerModal(self))

    @discord.ui.button(label="Pause/Resume", style=discord.ButtonStyle.secondary, emoji="⏸️")
    async def toggle_timer(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.timer_task:
            if self.timer_running:
                self.timer_running = False
                button.label = "Resume"
                button.emoji = "▶️"
                status = "paused"
            else:
                self.timer_running = True
                button.label = "Pause"
                button.emoji = "⏸️"
                status = "resumed"
            
            minutes = self.remaining_time // 60
            seconds = self.remaining_time % 60
            time_display = f"{minutes}m {seconds}s"
            
            await interaction.response.edit_message(view=self)
            await interaction.followup.send(f"⏱️ Timer {status}! Remaining time: {time_display}", ephemeral=True)
        else:
            await interaction.response.send_message("No active timer to pause/resume!", ephemeral=True)

    @discord.ui.button(label="Remove Timer", style=discord.ButtonStyle.danger, emoji="⏹️")
    async def stop_timer(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.timer_task:
            self.timer_task.cancel()
            self.timer_task = None
            self.timer_running = False
            self.remaining_time = 0
            await interaction.response.send_message("⏹️ Timer Removed/stopped!", ephemeral=True)
            
            for child in self.children:
                if child.label.startswith(("Pause", "Resume")):
                    child.label = "Pause/Resume"
                    child.emoji = "⏸️"
            await interaction.message.edit(view=self)
        else:
            await interaction.response.send_message("No active timer to stop!", ephemeral=True)

class StudyTimerModal(discord.ui.Modal, title="Study Timer"):
    def __init__(self, view):
        super().__init__()
        self.view = view
        self.minutes = discord.ui.TextInput(
            label="Minutes",
            placeholder="Enter duration in minutes",
            min_length=1,
            max_length=3
        )
        self.add_item(self.minutes)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            minutes = int(self.minutes.value)
            if minutes <= 0:
                raise ValueError("Duration must be positive")
            
            self.view.timer_running = True
            self.view.remaining_time = minutes * 60
            await interaction.response.send_message(f"⏱️ Timer set for {minutes} minutes!")
            
            self.view.timer_task = asyncio.create_task(self.run_timer(interaction, minutes))
        except ValueError:
            await interaction.response.send_message("Please enter a valid number of minutes!", ephemeral=True)

    async def run_timer(self, interaction, minutes):
        total_seconds = minutes * 60
        self.view.remaining_time = total_seconds
        last_minute_notified = None
        
        while total_seconds > 0:
            if self.view.timer_running:
                current_minute = total_seconds // 60
                if current_minute in [15, 10, 5, 1] and current_minute != last_minute_notified:
                    await interaction.channel.send(f"⏳ {interaction.user.mention}'s timer: {current_minute} minute{'s' if current_minute != 1 else ''} remaining!")
                    last_minute_notified = current_minute
                await asyncio.sleep(1)
                total_seconds -= 1
                self.view.remaining_time = total_seconds
            else:
                await asyncio.sleep(1)
        
        if self.view.timer_running:
            await interaction.channel.send(f"{interaction.user.mention} ⏰ Time's up! Study session complete!")
        self.view.timer_task = None
        self.view.remaining_time = 0


class GPACalculatorView(discord.ui.View):
    def __init__(self):
        super().__init__()

    @discord.ui.button(label="Calculate GPA", style=discord.ButtonStyle.primary, emoji="🎓")
    async def calculate_gpa(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(GPACalculatorModal())

class GPACalculatorModal(discord.ui.Modal, title="GPA Calculator"):
    def __init__(self):
        super().__init__()
        self.grades = discord.ui.TextInput(
            label="Enter letter grades (separated by spaces)",
            placeholder="e.g. A B+ B A- C+",
            style=discord.TextStyle.short
        )
        self.credits = discord.ui.TextInput(
            label="Enter credit hours",
            placeholder="e.g. 3 4 3 3 3",
            style=discord.TextStyle.short
        )
        self.add_item(self.grades)
        self.add_item(self.credits)

    async def on_submit(self, interaction: discord.Interaction):
        grade_points = {
            'A': 4.0, 'A-': 3.7,
            'B+': 3.3, 'B': 3.0, 'B-': 2.7,
            'C+': 2.3, 'C': 2.0, 'C-': 1.7,
            'D+': 1.3, 'D': 1.0, 'D-': 0.7,
            'F': 0.0
        }

        try:
            grades = self.grades.value.upper().split()
            credits = [float(x) for x in self.credits.value.split()]

            if len(grades) != len(credits):
                raise ValueError("Number of grades must match number of credits")

            total_points = sum(grade_points[g] * c for g, c in zip(grades, credits))
            total_credits = sum(credits)
            gpa = total_points / total_credits

            embed = discord.Embed(
                title="🎓 GPA Calculation Results",
                color=discord.Color.gold()
            )
            embed.add_field(
                name="Courses",
                value="\n".join(f"Grade: {g} | Credits: {c}" for g, c in zip(grades, credits)),
                inline=False
            )
            embed.add_field(name="Total Credits", value=f"{total_credits:.1f}")
            embed.add_field(name="GPA", value=f"{gpa:.2f}")

            classification = self.get_gpa_classification(gpa)
            embed.add_field(name="Standing", value=classification, inline=False)

            await interaction.response.send_message(embed=embed)
        except (ValueError, KeyError) as e:
            await interaction.response.send_message(
                "Please enter valid grades (A, A-, B+, etc.) and credit hours!",
                ephemeral=True
            )

    def get_gpa_classification(self, gpa):
        if gpa >= 3.9: return "Summa Cum Laude 🏆"
        elif gpa >= 3.7: return "Magna Cum Laude ⭐"
        elif gpa >= 3.5: return "Cum Laude 🌟"
        elif gpa >= 3.0: return "Dean's List 📚"
        elif gpa >= 2.0: return "Good Standing 👍"
        else: return "Academic Probation ⚠️"






class HashCalculatorView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.select(
        placeholder="Select Hash Algorithm",
        options=[
            discord.SelectOption(label="MD5", value="md5", emoji="1️⃣", description="Fast, not cryptographically secure"),
            discord.SelectOption(label="SHA-1", value="sha1", emoji="2️⃣", description="160-bit hash"),
            discord.SelectOption(label="SHA-256", value="sha256", emoji="3️⃣", description="Strong 256-bit hash"),
            discord.SelectOption(label="SHA-512", value="sha512", emoji="4️⃣", description="Most secure, 512-bit hash")
        ]
    )
    async def calculate_hash(self, interaction: discord.Interaction, select: discord.ui.Select):
        await interaction.response.send_modal(HashCalculatorModal(select.values[0]))

    @discord.ui.button(label="Back to Tools", style=discord.ButtonStyle.secondary, emoji="◀️")
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.edit_message(content="🔧 **Coding Tools**", view=CodingToolsView())



class ColorPickerView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=180)
        self.current_color = {"r": 255, "g": 0, "b": 0}
        self.current_hex = "#FF0000"
        
    def create_color_preview(self):
        
        img = Image.new('RGB', (300, 100), (self.current_color["r"], 
                                           self.current_color["g"], 
                                           self.current_color["b"]))
        draw = ImageDraw.Draw(img)
        
        rgb_text = f"RGB: ({self.current_color['r']}, {self.current_color['g']}, {self.current_color['b']})"
        hex_text = f"HEX: {self.current_hex}"
        hsv = colorsys.rgb_to_hsv(self.current_color["r"]/255, 
                                 self.current_color["g"]/255, 
                                 self.current_color["b"]/255)
        hsv_text = f"HSV: ({int(hsv[0]*360)}°, {int(hsv[1]*100)}%, {int(hsv[2]*100)}%)"
        
        text_color = (0, 0, 0) if sum(self.current_color.values())/3 > 128 else (255, 255, 255)
        draw.text((10, 10), rgb_text, fill=text_color)
        draw.text((10, 40), hex_text, fill=text_color)
        draw.text((10, 70), hsv_text, fill=text_color)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        return buffer

    @discord.ui.select(
        placeholder="Color Presets",
        options=[
            discord.SelectOption(label="Red", value="#FF0000"),
            discord.SelectOption(label="Green", value="#00FF00"),
            discord.SelectOption(label="Blue", value="#0000FF"),
            discord.SelectOption(label="Yellow", value="#FFFF00"),
            discord.SelectOption(label="Purple", value="#800080"),
            discord.SelectOption(label="Orange", value="#FFA500"),
            discord.SelectOption(label="Pink", value="#FFC0CB"),
            discord.SelectOption(label="Turquoise", value="#40E0D0")
        ]
    )
    async def preset_select(self, interaction: discord.Interaction, select: discord.ui.Select):
        hex_color = select.values[0]
        
        hex_color = hex_color.lstrip('#')
        self.current_color["r"] = int(hex_color[0:2], 16)
        self.current_color["g"] = int(hex_color[2:4], 16)
        self.current_color["b"] = int(hex_color[4:6], 16)
        self.current_hex = f"#{hex_color.upper()}"
        
        file = discord.File(self.create_color_preview(), filename="color.png")
        await interaction.response.edit_message(attachments=[file])

    @discord.ui.button(label="RGB Sliders", style=discord.ButtonStyle.primary, emoji="🎚️")
    async def rgb_sliders(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(RGBSliderModal(self))

class RGBSliderModal(discord.ui.Modal, title="RGB Color Picker"):
    def __init__(self, color_view):
        super().__init__()
        self.color_view = color_view
        
        self.red = discord.ui.TextInput(
            label="Red (0-255)",
            placeholder="Enter red value",
            default=str(color_view.current_color["r"]),
            min_length=1,
            max_length=3
        )
        self.green = discord.ui.TextInput(
            label="Green (0-255)",
            placeholder="Enter green value",
            default=str(color_view.current_color["g"]),
            min_length=1,
            max_length=3
        )
        self.blue = discord.ui.TextInput(
            label="Blue (0-255)",
            placeholder="Enter blue value",
            default=str(color_view.current_color["b"]),
            min_length=1,
            max_length=3
        )
        
        self.add_item(self.red)
        self.add_item(self.green)
        self.add_item(self.blue)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            r = max(0, min(255, int(self.red.value)))
            g = max(0, min(255, int(self.green.value)))
            b = max(0, min(255, int(self.blue.value)))
            
            self.color_view.current_color = {"r": r, "g": g, "b": b}
            self.color_view.current_hex = f"#{r:02x}{g:02x}{b:02x}".upper()
            
            file = discord.File(self.color_view.create_color_preview(), filename="color.png")
            await interaction.response.edit_message(attachments=[file])
            
        except ValueError:
            await interaction.response.send_message("Please enter valid numbers between 0 and 255!", ephemeral=True)

class CodingTools(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def code(self, ctx):
        
        embed = discord.Embed(
            title="🔧 Coding Helper Tools",
            description="Select a tool from the menu below:",
            color=discord.Color.blue()
        )
        view = CodingToolsView()
        await ctx.send(embed=embed, view=view)

class CodingToolsView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)
        
    @discord.ui.select(
        placeholder="🔧 Select Coding Tool",
        options=[
            discord.SelectOption(
                label="Color Picker & Converter",
                value="color",
                emoji="🎨",
                description="Interactive color tools with live preview"
            ),
            discord.SelectOption(
                label="Number Base Converter",
                value="base",
                emoji="🔢",
                description="Convert between decimal, binary, hex"
            ),
            discord.SelectOption(
                label="String Tools",
                value="string",
                emoji="📝",
                description="Encode/decode text in various formats"
            ),
            discord.SelectOption(
                label="Hash Calculator",
                value="hash",
                emoji="🔐",
                description="Generate secure hashes"
            )
        ]
    )
    async def select_tool(self, interaction: discord.Interaction, select: discord.ui.Select):
        if select.values[0] == "color":
            view = ColorPickerView()
            file = discord.File(view.create_color_preview(), filename="color.png")
            await interaction.response.edit_message(content="🎨 **Color Tools**", attachments=[file], view=view)
        elif select.values[0] == "base":
            await interaction.response.send_modal(BaseConverterModal())
        elif select.values[0] == "string":
            view = StringToolsView()
            await interaction.response.edit_message(content="📝 **String Tools**", view=view)
        elif select.values[0] == "hash":
            view = HashCalculatorView()
            await interaction.response.edit_message(content="🔐 **Hash Tools**", view=view)

class StringToolsView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.select(
        placeholder="Choose String Operation",
        options=[
            discord.SelectOption(label="Base64 Encode", value="b64e", emoji="🔒", description="Encode text to Base64"),
            discord.SelectOption(label="Base64 Decode", value="b64d", emoji="🔓", description="Decode Base64 to text"),
            discord.SelectOption(label="URL Encode", value="urle", emoji="🔗", description="Encode text for URLs"),
            discord.SelectOption(label="URL Decode", value="urld", emoji="🌐", description="Decode URL-encoded text")
        ]
    )
    async def string_operation(self, interaction: discord.Interaction, select: discord.ui.Select):
        await interaction.response.send_modal(StringOperationModal(select.values[0]))

    @discord.ui.button(label="Back to Tools", style=discord.ButtonStyle.secondary, emoji="◀️")
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.edit_message(content="🔧 **Coding Tools**", view=CodingToolsView())


class BaseConverterModal(discord.ui.Modal, title="Base Converter"):
    def __init__(self):
        super().__init__()
        self.number = discord.ui.TextInput(
            label="Enter Number",
            placeholder="Enter number with base prefix (0x, 0b, or decimal)"
        )
        self.add_item(self.number)

    async def on_submit(self, interaction: discord.Interaction):
        try:
           
            value = self.number.value.lower().strip()
            if value.startswith('0x'):
                num = int(value[2:], 16)
                base = 16
            elif value.startswith('0b'):
                num = int(value[2:], 2)
                base = 2
            else:
                num = int(value)
                base = 10

            embed = discord.Embed(
                title="🔢 Base Conversion Results",
                color=discord.Color.green()
            )
            embed.add_field(name="Input", value=f"```{value}```", inline=False)
            embed.add_field(name="Decimal", value=f"```{num}```")
            embed.add_field(name="Hexadecimal", value=f"```0x{num:X}```")
            embed.add_field(name="Binary", value=f"```0b{bin(num)[2:]}```")
            embed.add_field(name="Octal", value=f"```0o{oct(num)[2:]}```")
            
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("Invalid number format!", ephemeral=True)

class StringOperationModal(discord.ui.Modal):
    def __init__(self, operation):
        super().__init__(title="String Encoder/Decoder")
        self.operation = operation
        self.input_text = discord.ui.TextInput(
            label="Enter Text",
            placeholder="Text to encode/decode",
            style=discord.TextStyle.paragraph
        )
        self.add_item(self.input_text)

    async def on_submit(self, interaction: discord.Interaction):
        import base64
        import urllib.parse
        
        text = self.input_text.value
        result = ""
        
        try:
            if self.operation == "b64e":
                result = base64.b64encode(text.encode()).decode()
                op_name = "Base64 Encode"
            elif self.operation == "b64d":
                result = base64.b64decode(text.encode()).decode()
                op_name = "Base64 Decode"
            elif self.operation == "urle":
                result = urllib.parse.quote(text)
                op_name = "URL Encode"
            elif self.operation == "urld":
                result = urllib.parse.unquote(text)
                op_name = "URL Decode"

            embed = discord.Embed(
                title="📝 String Operation Result",
                color=discord.Color.blue()
            )
            embed.add_field(name="Operation", value=op_name, inline=False)
            embed.add_field(name="Input", value=f"```{text}```", inline=False)
            embed.add_field(name="Output", value=f"```{result}```", inline=False)
            
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await interaction.response.send_message(f"Error: Invalid input for {op_name}", ephemeral=True)

class HashCalculatorModal(discord.ui.Modal):
    def __init__(self, hash_type):
        super().__init__(title=f"{hash_type.upper()} Hash Calculator")
        self.hash_type = hash_type
        self.input_text = discord.ui.TextInput(
            label="Enter Text",
            placeholder="Text to hash",
            style=discord.TextStyle.paragraph
        )
        self.add_item(self.input_text)

    async def on_submit(self, interaction: discord.Interaction):
        import hashlib
        
        text = self.input_text.value
        
        hash_functions = {
            'md5': hashlib.md5(),
            'sha1': hashlib.sha1(),
            'sha256': hashlib.sha256(),
            'sha512': hashlib.sha512()
        }
        
        hasher = hash_functions[self.hash_type]
        hasher.update(text.encode())
        hash_result = hasher.hexdigest()

        embed = discord.Embed(
            title="🔐 Hash Calculation Result",
            color=discord.Color.red()
        )
        embed.add_field(name="Hash Type", value=self.hash_type.upper(), inline=False)
        embed.add_field(name="Input Text", value=f"```{text}```", inline=False)
        embed.add_field(name="Hash", value=f"```{hash_result}```", inline=False)
        embed.set_footer(text="Note: Hashing is one-way encryption")
        
        await interaction.response.send_message(embed=embed)

class TimeTools(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
    @commands.group(invoke_without_command=True)
    async def time(self, ctx):
        embed = discord.Embed(
            title="⏰ Time & Date Tools",
            description="Select a tool from the menu below:",
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed, view=TimeToolsView())

class TimeToolsView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)
        
    @discord.ui.select(
        placeholder="Choose Time Tool",
        options=[
            discord.SelectOption(label="Time Zone Converter", value="timezone", emoji="🌍", description="Convert between time zones"),
            discord.SelectOption(label="Date Difference", value="datediff", emoji="📅", description="Calculate days between dates"),
            discord.SelectOption(label="Project Deadline", value="deadline", emoji="⏳", description="Calculate project timelines"),
            discord.SelectOption(label="Meeting Scheduler", value="meeting", emoji="👥", description="Schedule across time zones")
        ]
    )
    async def select_tool(self, interaction: discord.Interaction, select: discord.ui.Select):
        tool_views = {
            "timezone": TimeZoneView(),
            "datediff": DateDiffView(),
            "deadline": DeadlineView(),
            "meeting": MeetingView()
        }
        await interaction.response.edit_message(view=tool_views[select.values[0]])

class DateDiffView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.button(label="Calculate Date Difference", style=discord.ButtonStyle.primary, emoji="📅")
    async def calculate_diff(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(DateDiffModal())

class DateDiffModal(discord.ui.Modal, title="Date Difference Calculator"):
    def __init__(self):
        super().__init__()
        self.date1 = discord.ui.TextInput(
            label="Start Date",
            placeholder="YYYY-MM-DD (e.g. 2024-02-26)"
        )
        self.date2 = discord.ui.TextInput(
            label="End Date",
            placeholder="YYYY-MM-DD (e.g. 2024-03-26)"
        )
        self.add_item(self.date1)
        self.add_item(self.date2)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            date1 = datetime.strptime(self.date1.value, "%Y-%m-%d")
            date2 = datetime.strptime(self.date2.value, "%Y-%m-%d")
            diff = date2 - date1
            
            embed = discord.Embed(title="📅 Date Difference Results", color=discord.Color.green())
            embed.add_field(name="Start Date", value=date1.strftime("%B %d, %Y"), inline=True)
            embed.add_field(name="End Date", value=date2.strftime("%B %d, %Y"), inline=True)
            embed.add_field(name="Difference", value=f"{abs(diff.days)} days", inline=False)
            embed.add_field(name="Weeks", value=f"{abs(diff.days) // 7} weeks and {abs(diff.days) % 7} days", inline=False)
            
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("Please use the format YYYY-MM-DD!", ephemeral=True)

class DeadlineView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.button(label="Set Project Deadline", style=discord.ButtonStyle.primary, emoji="⏳")
    async def set_deadline(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(DeadlineModal())

class DeadlineModal(discord.ui.Modal, title="Project Deadline Calculator"):
    def __init__(self):
        super().__init__()
        self.start_date = discord.ui.TextInput(
            label="Start Date",
            placeholder="YYYY-MM-DD (e.g. 2024-02-26)"
        )
        self.duration = discord.ui.TextInput(
            label="Project Duration (days)",
            placeholder="e.g. 30"
        )
        self.add_item(self.start_date)
        self.add_item(self.duration)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            start = datetime.strptime(self.start_date.value, "%Y-%m-%d")
            days = int(self.duration.value)
            end = start + timedelta(days=days)
            
            milestones = [
                ("25% Complete", start + timedelta(days=days//4)),
                ("50% Complete", start + timedelta(days=days//2)),
                ("75% Complete", start + timedelta(days=3*days//4)),
                ("Deadline", end)
            ]
            
            embed = discord.Embed(title="⏳ Project Timeline", color=discord.Color.gold())
            embed.add_field(name="Project Start", value=start.strftime("%B %d, %Y"), inline=True)
            embed.add_field(name="Project Duration", value=f"{days} days", inline=True)
            embed.add_field(name="Project End", value=end.strftime("%B %d, %Y"), inline=True)
            
            for milestone, date in milestones:
                embed.add_field(name=milestone, value=date.strftime("%B %d, %Y"), inline=False)
            
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("Please check your input format!", ephemeral=True)

class MeetingView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.button(label="Schedule Meeting", style=discord.ButtonStyle.primary, emoji="👥")
    async def schedule_meeting(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(MeetingModal())

class MeetingModal(discord.ui.Modal, title="Meeting Scheduler"):
    def __init__(self):
        super().__init__()
        self.meeting_date = discord.ui.TextInput(
            label="Meeting Date",
            placeholder="YYYY-MM-DD (e.g. 2024-02-26)"
        )
        self.meeting_time = discord.ui.TextInput(
            label="Meeting Time (Your Local Time)",
            placeholder="HH:MM (e.g. 14:30 or 02:30 PM)"
        )
        self.timezone = discord.ui.TextInput(
            label="Your Timezone",
            placeholder="e.g. US/Pacific, Europe/London"
        )
        self.add_item(self.meeting_date)
        self.add_item(self.meeting_time)
        self.add_item(self.timezone)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            date = datetime.strptime(self.meeting_date.value, "%Y-%m-%d")
            time = datetime.strptime(self.meeting_time.value, "%H:%M").time()
            local_tz = pytz.timezone(self.timezone.value)
            
            dt = datetime.combine(date, time)
            local_time = local_tz.localize(dt)
            
            common_timezones = {
                "US/Pacific": "Los Angeles",
                "US/Eastern": "New York",
                "Europe/London": "London",
                "Europe/Paris": "Paris",
                "Asia/Tokyo": "Tokyo",
                "Australia/Sydney": "Sydney"
            }
            
            embed = discord.Embed(title="👥 Meeting Schedule", color=discord.Color.blue())
            embed.add_field(name="Meeting Date", value=date.strftime("%B %d, %Y"), inline=False)
            
            for tz, city in common_timezones.items():
                converted = local_time.astimezone(pytz.timezone(tz))
                embed.add_field(
                    name=f"Time in {city}",
                    value=f"{converted.strftime('%I:%M %p')} ({converted.strftime('%H:%M')})",
                    inline=True
                )
            
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("Please check your input format!", ephemeral=True)
        except pytz.exceptions.UnknownTimeZoneError:
            await interaction.response.send_message("Invalid timezone! Please use a valid timezone name.", ephemeral=True)

class TimeZoneModal(discord.ui.Modal, title="Time Zone Converter"):
    def __init__(self, from_tz: str, to_tz: str):
        super().__init__()
        self.from_tz = from_tz
        self.to_tz = to_tz
        self.time_input = discord.ui.TextInput(
            label="Enter time (HH:MM)",
            placeholder="e.g. 14:30 or 02:30 PM"
        )
        self.add_item(self.time_input)

    async def on_submit(self, interaction: discord.Interaction):
        try:
        
            input_time = self.parse_time(self.time_input.value)
            
            from_zone = pytz.timezone(self.from_tz)
            to_zone = pytz.timezone(self.to_tz)
            
            now = datetime.now()
            dt = datetime.combine(now.date(), input_time)
            dt = from_zone.localize(dt)
            converted = dt.astimezone(to_zone)

            embed = discord.Embed(
                title="🌍 Time Zone Conversion",
                color=discord.Color.blue()
            )
            embed.add_field(
                name=f"Time in {self.get_location_name(self.from_tz)}",
                value=f"```{dt.strftime('%I:%M %p')} ({dt.strftime('%H:%M')} Military)```"
            )
            embed.add_field(
                name=f"Time in {self.get_location_name(self.to_tz)}",
                value=f"```{converted.strftime('%I:%M %p')} ({converted.strftime('%H:%M')} Military)```"
            )
            
            time_diff = self.get_time_difference(from_zone, to_zone)
            embed.add_field(
                name="Time Difference",
                value=f"```{time_diff}```",
                inline=False
            )

            await interaction.response.send_message(embed=embed)

        except ValueError as e:
            await interaction.response.send_message(f"Error: {str(e)}", ephemeral=True)

    def parse_time(self, time_str: str) -> datetime.time:
        try:
            
            return datetime.strptime(time_str, "%H:%M").time()
        except ValueError:
            try:
                
                return datetime.strptime(time_str, "%I:%M %p").time()
            except ValueError:
                raise ValueError("Invalid time format. Use HH:MM or HH:MM AM/PM")

    def get_location_name(self, tz: str) -> str:
        
        return tz.replace('_', ' ').split('/')[-1]

    def get_time_difference(self, tz1: pytz.timezone, tz2: pytz.timezone) -> str:
        now = datetime.now()
        tz1_time = now.astimezone(tz1)
        tz2_time = now.astimezone(tz2)
        diff = int((tz2_time.utcoffset() - tz1_time.utcoffset()).total_seconds() / 3600)
        return f"{abs(diff)} hours {'ahead' if diff > 0 else 'behind'}"

class TimeZoneView(discord.ui.View):
    def __init__(self):
        super().__init__()
        self.from_tz = None
        self.to_tz = None
        self.common_zones = {
            "🌎 North America": [
                ("US/Pacific", "Los Angeles, Vancouver"),
                ("US/Mountain", "Denver, Calgary"),
                ("US/Central", "Chicago, Mexico City"),
                ("US/Eastern", "New York, Toronto")
            ],
            "🌍 Europe": [
                ("Europe/London", "London, Dublin"),
                ("Europe/Paris", "Paris, Berlin, Rome"),
                ("Europe/Moscow", "Moscow, St. Petersburg")
            ],
            "🌏 Asia/Pacific": [
                ("Asia/Tokyo", "Tokyo, Seoul"),
                ("Asia/Shanghai", "Beijing, Shanghai"),
                ("Australia/Sydney", "Sydney, Melbourne"),
                ("Pacific/Auckland", "Auckland, Wellington")
            ]
        }

        self.from_select = discord.ui.Select(
            placeholder="Convert from (Region)",
            options=[
                discord.SelectOption(
                    label=description,
                    value=zone,
                    description=f"UTC{datetime.now(pytz.timezone(zone)).strftime('%z')}"
                )
                for region, zones in self.common_zones.items()
                for zone, description in zones
            ]
        )
        self.to_select = discord.ui.Select(
            placeholder="Convert to (Region)",
            options=[
                discord.SelectOption(
                    label=description,
                    value=zone,
                    description=f"UTC{datetime.now(pytz.timezone(zone)).strftime('%z')}"
                )
                for region, zones in self.common_zones.items()
                for zone, description in zones
            ]
        )

        self.from_select.callback = self.from_region_select
        self.to_select.callback = self.to_region_select

        self.add_item(self.from_select)
        self.add_item(self.to_select)

    async def from_region_select(self, interaction: discord.Interaction):
        self.from_tz = self.from_select.values[0]
        if self.to_tz:
            await interaction.response.send_modal(TimeZoneModal(self.from_tz, self.to_tz))

    async def to_region_select(self, interaction: discord.Interaction):
        self.to_tz = self.to_select.values[0]
        if self.from_tz:
            await interaction.response.send_modal(TimeZoneModal(self.from_tz, self.to_tz))

from textblob import TextBlob

class EmotionalSupportCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.sensitive_triggers = [
            r"\b(kill\smyself|end\smy\slife|suicide|hurt\smyself|i\sam\sworthless|i\shave\snothing\sto\slose)\b",
            r"\b(depressed|hopeless|empty|alone|nobody\scares|i\shave\snobody|nobody\sunderstands|nothing\sworks)\b",
            r"\b(fail|failure|can’t\sdo\sanything|no\sway\sout|no\sone\scares|i\sfeel\shelpless|i\sfeel\so\strapped)\b",
            r"\b(nothing\sleft|why\sshould\si\stry|i\shave\sno\shope|i\should\sjust\squit)\b",
        ]

        self.subtle_triggers = [
            r"\b(feeling\s*(down|stressed|overwhelmed|useless|empty|lost|alone|helpless))\b",
            r"\b(feels\s*like\s*i\slost\severything|everything\sfeels\swrong|it\sdosen't\sget\sbetter)\b",
            r"\b(scared|worry|freaked\s*out|panic\sattack|i\scannot\scope)\b",
            r"\b(i\scannot\sdeal\swith\sthis|i\swish\si\swould\sgo\saway)\b"
        ]

    def detect_sentiment(self, user_input):
        
        analysis = TextBlob(user_input)
        sentiment = analysis.sentiment.polarity  
        return sentiment
    
    def detect_emotional_distress(self, user_input):

        for pattern in self.sensitive_triggers:
            if re.search(pattern, user_input, re.IGNORECASE):
                return True
        return False
    
    def detect_subtle_distress(self, user_input, sentiment_score):
        
        if any(re.search(pattern, user_input, re.IGNORECASE) for pattern in self.subtle_triggers):
            if sentiment_score < -0.3: 
                return True
        return False
    
    def emotional_support_response(self):  
        return (
            "Hey there, I noticed you might be going through a tough time. 💙 If you're feeling mentally unstable or "
            "overwhelmed, please reach out to someone you trust, whether it's a friend, family member, or a professional. "
            "You're not alone, and support is always available. 🌟\n\n"
            "I'm really sorry you're feeling like this, but I'm not equipped to handle this situation. "
            "It's really important to talk to someone who can help. Please reach out to a friend, family member, "
            "or a professional. You're not alone, and help is available. 💛\n\n"
            "Take care, and remember that there’s always light ahead. 💫\n\nGreetings, Z"
        )

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.guild:  
            return           
        if message.author == self.bot.user:
            return

        user_message = message.content.lower()

        sentiment_score = self.detect_sentiment(user_message)

        if self.detect_emotional_distress(user_message):
            await message.channel.send(self.emotional_support_response())
            return
        
        if self.detect_subtle_distress(user_message, sentiment_score):
            await message.channel.send(self.emotional_support_response())
            return

class UnitConverterView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)
        self.conversion_type = None
        self.from_unit = None
        self.to_unit = None

    @discord.ui.select(
        placeholder="Select Unit Type",
        options=[
            discord.SelectOption(label="Length", value="length", emoji="📏"),
            discord.SelectOption(label="Volume", value="volume", emoji="🧊"),
            discord.SelectOption(label="Mass", value="mass", emoji="⚖️")
        ]
    )
    async def unit_type_select(self, interaction: discord.Interaction, select: discord.ui.Select):
        self.conversion_type = select.values[0]
        units = list(MathPhysicsTools.unit_conversions[self.conversion_type].keys())
        
        from_select = discord.ui.Select(
            placeholder="Convert from",
            options=[discord.SelectOption(label=unit, value=unit) for unit in units]
        )
        to_select = discord.ui.Select(
            placeholder="Convert to",
            options=[discord.SelectOption(label=unit, value=unit) for unit in units]
        )

        async def from_callback(interaction: discord.Interaction):
            self.from_unit = from_select.values[0]
            if self.to_unit: 
                await interaction.response.send_modal(
                    UnitConverterModal(self.conversion_type, self.from_unit, self.to_unit)
                )

        async def to_callback(interaction: discord.Interaction):
            self.to_unit = to_select.values[0]
            if self.from_unit:  
                await interaction.response.send_modal(
                    UnitConverterModal(self.conversion_type, self.from_unit, self.to_unit)
                )

        from_select.callback = from_callback
        to_select.callback = to_callback

        self.clear_items()
        self.add_item(from_select)
        self.add_item(to_select)
        await interaction.response.edit_message(view=self)


class GeometryView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.select(
        placeholder="Select Shape",
        options=[
            discord.SelectOption(label="Circle", value="circle", emoji="⭕"),
            discord.SelectOption(label="Square", value="square", emoji="⬛"),
            discord.SelectOption(label="Triangle", value="triangle", emoji="📐"),
            discord.SelectOption(label="Sphere", value="sphere", emoji="🔮")
        ]
    )
    async def shape_select(self, interaction: discord.Interaction, select: discord.ui.Select):
        await interaction.response.send_modal(GeometryModal(select.values[0]))

class PhysicsView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.select(
        placeholder="Select Formula",
        options=[
            discord.SelectOption(label="Velocity", value="velocity", emoji="🏃"),
            discord.SelectOption(label="Force", value="force", emoji="💪"),
            discord.SelectOption(label="Energy", value="energy", emoji="⚡")
        ]
    )
    async def formula_select(self, interaction: discord.Interaction, select: discord.ui.Select):
        await interaction.response.send_modal(PhysicsModal(select.values[0]))


class StatisticsModal(discord.ui.Modal, title="Statistical Analysis"):
    def __init__(self):
        super().__init__()
        self.numbers_input = discord.ui.TextInput(
            label="Enter numbers (separated by spaces)",
            placeholder="e.g. 1 2 3.5 4.7 5",
            required=True
        )
        self.add_item(self.numbers_input)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            
            numbers = [float(x) for x in self.numbers_input.value.split()]
            
            if not numbers:
                raise ValueError("No numbers provided")

            mean = sum(numbers) / len(numbers)
            sorted_nums = sorted(numbers)
            median = sorted_nums[len(numbers)//2] if len(numbers) % 2 else (sorted_nums[len(numbers)//2-1] + sorted_nums[len(numbers)//2])/2
            variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)
            std_dev = variance ** 0.5

            embed = discord.Embed(
                title="📊 Statistical Analysis Results",
                color=discord.Color.purple()
            )
            embed.add_field(name="Numbers Analyzed", value=f"`{', '.join(map(str, numbers))}`", inline=False)
            embed.add_field(name="Count", value=str(len(numbers)))
            embed.add_field(name="Mean", value=f"{mean:.2f}")
            embed.add_field(name="Median", value=f"{median:.2f}")
            embed.add_field(name="Standard Deviation", value=f"{std_dev:.2f}")
            embed.add_field(name="Range", value=f"{max(numbers) - min(numbers):.2f}")

            await interaction.response.send_message(embed=embed)

        except ValueError:
            await interaction.response.send_message("Please enter valid numbers separated by spaces!", ephemeral=True)

class StatisticsView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)

    @discord.ui.button(label="Enter Numbers", style=discord.ButtonStyle.primary, emoji="📊")
    async def enter_numbers(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(StatisticsModal())

class MathPhysicsView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=120)
        
    @discord.ui.select(
        placeholder="Choose Calculator Type",
        options=[
            discord.SelectOption(label="Unit Converter", value="units", emoji="📏", description="Convert between different units"),
            discord.SelectOption(label="Geometry", value="geometry", emoji="📐", description="Calculate areas, volumes, perimeters"),
            discord.SelectOption(label="Physics", value="physics", emoji="⚡", description="Physics formulas and calculations"),
            discord.SelectOption(label="Statistics", value="stats", emoji="📊", description="Statistical analysis tools")
        ]
    )
    async def select_calculator(self, interaction: discord.Interaction, select: discord.ui.Select):
        calculator_views = {
            "units": UnitConverterView(),
            "geometry": GeometryView(),
            "physics": PhysicsView(),
            "stats": StatisticsView()
        }
        await interaction.response.edit_message(view=calculator_views[select.values[0]])

class UnitConverterModal(discord.ui.Modal, title="Unit Converter"):
    def __init__(self, conversion_type, from_unit, to_unit):
        super().__init__()
        self.conversion_type = conversion_type
        self.from_unit = from_unit
        self.to_unit = to_unit
        
        self.value = discord.ui.TextInput(
            label=f"Enter value in {from_unit}",
            placeholder="e.g. 100",
            required=True
        )
        self.add_item(self.value)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            value = float(self.value.value)
            result = MathPhysicsTools.convert_unit(value, self.from_unit, self.to_unit, self.conversion_type)
            
            embed = discord.Embed(
                title="📏 Unit Conversion Result",
                description=f"{value} {self.from_unit} = {result:.4f} {self.to_unit}",
                color=discord.Color.green()
            )
            embed.add_field(name="Conversion Type", value=self.conversion_type.title())
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("❌ Please enter a valid number!", ephemeral=True)

class GeometryModal(discord.ui.Modal, title="Geometry Calculator"):
    def __init__(self, shape):
        super().__init__()
        self.shape = shape
        
        if shape in ["circle", "sphere"]:
            self.radius = discord.ui.TextInput(label="Radius", required=True)
            self.add_item(self.radius)
        elif shape == "square":
            self.side = discord.ui.TextInput(label="Side Length", required=True)
            self.add_item(self.side)
        elif shape == "triangle":
            self.side_a = discord.ui.TextInput(label="Side A", required=True)
            self.side_b = discord.ui.TextInput(label="Side B", required=True)
            self.side_c = discord.ui.TextInput(label="Side C", required=True)
            self.add_item(self.side_a)
            self.add_item(self.side_b)
            self.add_item(self.side_c)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            results = MathPhysicsTools.calculate_geometry(self.shape, self.get_values())
            
            embed = discord.Embed(
                title=f"📐 {self.shape.title()} Calculations",
                color=discord.Color.blue()
            )
            for key, value in results.items():
                embed.add_field(name=key, value=f"{value:.2f}")
            
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("❌ Please enter valid numbers!", ephemeral=True)

    def get_values(self):
        if self.shape in ["circle", "sphere"]:
            return [float(self.radius.value)]
        elif self.shape == "square":
            return [float(self.side.value)]
        elif self.shape == "triangle":
            return [float(self.side_a.value), float(self.side_b.value), float(self.side_c.value)]

class PhysicsModal(discord.ui.Modal, title="Physics Calculator"):
    def __init__(self, formula):
        super().__init__()
        self.formula = formula
        
        if formula == "velocity":
            self.distance = discord.ui.TextInput(label="Distance (meters)", required=True)
            self.time = discord.ui.TextInput(label="Time (seconds)", required=True)
            self.add_item(self.distance)
            self.add_item(self.time)
        elif formula == "force":
            self.mass = discord.ui.TextInput(label="Mass (kg)", required=True)
            self.acceleration = discord.ui.TextInput(label="Acceleration (m/s²)", required=True)
            self.add_item(self.mass)
            self.add_item(self.acceleration)
        elif formula == "energy":
            self.mass = discord.ui.TextInput(label="Mass (kg)", required=True)
            self.velocity = discord.ui.TextInput(label="Velocity (m/s)", required=True)
            self.add_item(self.mass)
            self.add_item(self.velocity)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            result = MathPhysicsTools.calculate_physics(self.formula, self.get_values())
            
            embed = discord.Embed(
                title=f"⚡ Physics Calculation: {self.formula.title()}",
                color=discord.Color.gold()
            )
            embed.add_field(name="Result", value=f"{result:.2f}")
            embed.add_field(name="Formula Used", value=self.get_formula_display())
            
            await interaction.response.send_message(embed=embed)
        except ValueError:
            await interaction.response.send_message("❌ Please enter valid numbers!", ephemeral=True)

    def get_values(self):
        if self.formula == "velocity":
            return [float(self.distance.value), float(self.time.value)]
        elif self.formula == "force":
            return [float(self.mass.value), float(self.acceleration.value)]
        elif self.formula == "energy":
            return [float(self.mass.value), float(self.velocity.value)]

    def get_formula_display(self):
        formulas = {
            "velocity": "v = d/t",
            "force": "F = ma",
            "energy": "E = ½mv²"
        }
        return formulas[self.formula]


class MathPhysicsTools(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    unit_conversions = {
            'length': {
                'm': 1, 'km': 1000, 'cm': 0.01, 'mm': 0.001,
                'mile': 1609.34, 'yard': 0.9144, 'foot': 0.3048, 'inch': 0.0254
            },
            'volume': {
                'l': 1, 'ml': 0.001, 'm3': 1000,
                'gallon': 3.78541, 'quart': 0.946353, 'cup': 0.236588
            },
            'mass': {
                'kg': 1, 'g': 0.001, 'mg': 0.000001,
                'pound': 0.453592, 'ounce': 0.0283495
            }
        }
    def __init__(self, bot):
        self.bot = bot


    @staticmethod
    def convert_unit(value: float, from_unit: str, to_unit: str, conversion_type: str) -> float:
        conversions = MathPhysicsTools.unit_conversions[conversion_type]
        base_value = value * conversions[from_unit]
        return base_value / conversions[to_unit]

    @staticmethod
    def calculate_geometry(shape: str, values: list) -> dict:
        PI = 3.14159
        
        if shape == "circle":
            r = values[0]
            return {
                "Area": PI * r * r,
                "Circumference": 2 * PI * r
            }
        elif shape == "square":
            s = values[0]
            return {
                "Area": s * s,
                "Perimeter": 4 * s
            }
        elif shape == "triangle":
            a, b, c = values
            s = (a + b + c) / 2  
            area = (s*(s-a)*(s-b)*(s-c)) ** 0.5  
            return {
                "Area": area,
                "Perimeter": a + b + c
            }
        elif shape == "sphere":
            r = values[0]
            return {
                "Volume": (4/3) * PI * r**3,
                "Surface Area": 4 * PI * r**2
            }

    @staticmethod
    def calculate_physics(formula: str, values: list) -> float:
        if formula == "velocity":
            distance, time = values
            return distance / time
        elif formula == "force":
            mass, acceleration = values
            return mass * acceleration
        elif formula == "energy":
            mass, velocity = values
            return 0.5 * mass * velocity**2

    @commands.command()
    async def math(self, ctx):
        embed = discord.Embed(
            title="🔢 Advanced Math & Physics Calculator",
            description="Select a calculator type from the menu below:",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Available Tools",
            value=(
                "📏 **Unit Converter** - Convert between different units\n"
                "📐 **Geometry** - Calculate areas, volumes, perimeters\n"
                "⚡ **Physics** - Various physics formulas\n"
                "📊 **Statistics** - Statistical analysis"
            ),
            inline=False
        )
        embed.set_footer(text="Interactive calculator • Timeout: 120 seconds")
        
        await ctx.send(embed=embed, view=MathPhysicsView())

    @commands.command()
    async def physics(self, ctx):
        embed = discord.Embed(
            title="⚡ Physics Calculator",
            description="Select a physics formula to use:",
            color=discord.Color.gold()
        )
        embed.add_field(
            name="Available Formulas",
            value=(
                "🏃 **Velocity** (v=d/t)\n"
                "💪 **Force** (F=ma)\n"
                "⚡ **Energy** (E=½mv²)"
            ),
            inline=False
        )
        embed.set_footer(text="Interactive calculator • Timeout: 120 seconds")
        
        await ctx.send(embed=embed, view=PhysicsView())

class BMICalculator(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.MIN_WEIGHT_KG, self.MAX_WEIGHT_KG = 20, 300
        self.MIN_HEIGHT_M, self.MAX_HEIGHT_M = 0.5, 2.5
        self.MIN_AGE, self.MAX_AGE = 2, 120

    def calculate_bmi(self, weight: float, height_m: float) -> float:
        return round(weight / (height_m ** 2), 2)

    def calculate_body_fat(self, bmi: float, age: int, gender: str) -> float:
        if gender.lower() == "male":
            body_fat = (1.20 * bmi) + (0.23 * age) - 16.2
        elif gender.lower() == "female":
            body_fat = (1.20 * bmi) + (0.23 * age) - 5.4
        else:
            body_fat = (1.20 * bmi) + (0.23 * age) - 10
        return round(body_fat, 2)

    def calculate_bmr(self, weight: float, height_cm: float, age: int, gender: str) -> float:
        if gender.lower() == "male":
            return round(10 * weight + 6.25 * height_cm - 5 * age + 5, 2)
        elif gender.lower() == "female":
            return round(10 * weight + 6.25 * height_cm - 5 * age - 161, 2)
        return round(10 * weight + 6.25 * height_cm - 5 * age - 78, 2)

    def get_macros(self, bmr: float) -> str:
        protein = round(bmr * 0.3 / 4)
        carbs = round(bmr * 0.5 / 4)
        fats = round(bmr * 0.2 / 9)
        return f"Protein: {protein}g\nCarbs: {carbs}g\nFats: {fats}g"

    def classify_bmi(self, bmi: float, age: int, gender: str, bmr: float, body_fat: float) -> str:
        if bmi < 18.5:
            classification = "📉 Underweight - Consider increasing nutrition intake"
        elif 18.5 <= bmi < 24.9:
            classification = "✅ Normal weight - Maintain current lifestyle"
        elif 25 <= bmi < 29.9:
            classification = "⚠️ Overweight - Consider increasing activity"
        else:
            classification = "⚠️ Obesity - Consult healthcare provider"
        
        return classification

    @commands.command(name="bmi")
    async def bmi_calculator(self, ctx):
        questions = [
            "What is your weight in kg?",
            "What is your height in meters?",
            "What is your age?",
            "What is your gender? (male/female/other)"
        ]
        answers = []

        for question in questions:
            await ctx.send(question)
            try:
                msg = await self.bot.wait_for(
                    'message',
                    timeout=30.0,
                    check=lambda m: m.author == ctx.author and m.channel == ctx.channel
                )
                answers.append(msg.content)
            except asyncio.TimeoutError:
                await ctx.send("❌ Timed out! Please try again.")
                return

        try:
            weight = float(answers[0])
            height = float(answers[1])
            age = int(answers[2])
            gender = answers[3].lower()

            if not (self.MIN_WEIGHT_KG <= weight <= self.MAX_WEIGHT_KG):
                await ctx.send("❌ Invalid weight! Must be between 20-300 kg.")
                return
            if not (self.MIN_HEIGHT_M <= height <= self.MAX_HEIGHT_M):
                await ctx.send("❌ Invalid height! Must be between 0.5-2.5 meters.")
                return
            if not (self.MIN_AGE <= age <= self.MAX_AGE):
                await ctx.send("❌ Invalid age! Must be between 2-120 years.")
                return

            bmi = self.calculate_bmi(weight, height)
            body_fat = self.calculate_body_fat(bmi, age, gender)
            bmr = self.calculate_bmr(weight, height * 100, age, gender)
            classification = self.classify_bmi(bmi, age, gender, bmr, body_fat)
            macros = self.get_macros(bmr)

            embed = discord.Embed(
                title="🏋️ BMI & Health Calculator Results",
                color=discord.Color.blue()
            )
            embed.add_field(name="BMI", value=f"{bmi}", inline=True)
            embed.add_field(name="Body Fat %", value=f"{body_fat}%", inline=True)
            embed.add_field(name="BMR", value=f"{bmr} kcal/day", inline=True)
            embed.add_field(name="Classification", value=classification, inline=False)
            embed.add_field(name="Daily Macro Recommendations", value=macros, inline=False)
            embed.set_footer(text="Note: These are estimates. Consult a healthcare professional for accurate advice.")

            await ctx.send(embed=embed)

        except ValueError:
            await ctx.send("❌ Please enter valid numbers for weight, height, and age!")




class AI_CHAT(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.ai_channels = {}
        self.available_models = {
            "gpt-4": "Most capable model, best for complex tasks",
            "gpt-3.5-turbo": "Fast and efficient for general chat",
            "gpt-4-32k": "Extended context model for longer conversations",
            "claude-2": "Alternative model with different capabilities"
        }
        self.default_model = "gpt-3.5-turbo"
        self.channel_states = {}
        self.conversation_history = {}
        self.api_key = os.getenv('OPENAI_API_KEY')  
        self.rate_limits = {}  
        self.rate_limit_cooldown = 30  

        
        if not self.api_key:
            print("⚠️ Warning: OPENAI_API_KEY not found in .env file")


    @commands.command(name="ai_info")
    async def ai_info(self, ctx):
        embed = discord.Embed(
            title="🤖 AI Chat System Information",
            description="Complete overview of models, pricing and commands",
            color=discord.Color.blue()
        )

        pricing_info = """
        **GPT-4 Models:**
        • GPT-4: $0.03 per message (~750 words)
        • GPT-4-32K: $0.06 per message (~2000 words)

        **GPT-3.5 Models:**
        • GPT-3.5-Turbo: $0.002 per message (~750 words)
        • GPT-3.5-16K: $0.004 per message (~2000 words)

        **Claude-2:**
        • $0.11 per 1000 tokens (~750 words)
        """
        embed.add_field(name="📊 Models & Pricing", value=pricing_info, inline=False)

        commands_info = """
        **Admin Commands:**
        `!ai_chat <model>` - Select AI model
        `!ai_chat_set <channel>` - Set AI chat channel
        `!ai_chat_unset` - Remove AI chat channel
        `!ai_chat_pause` - Pause AI responses (save credits)
        `!ai_chat_resume` - Resume AI responses

        **User Commands:**
        Just type your message in the designated AI chat channel!
        """
        embed.add_field(name="⌨️ Available Commands", value=commands_info, inline=False)

        guild_id = ctx.guild.id
        if guild_id in self.ai_channels:
            model = self.ai_channels[guild_id].get("model", "Not set")
            channel_id = self.ai_channels[guild_id].get("channel")
            status = "Active ✅" if self.channel_states.get(channel_id, False) else "Paused ⏸️"
            
            status_info = f"""
            **Current Model:** {model}
            **Status:** {status}
            **Channel:** <#{channel_id}> if channel_id else "Not set"
            """
            embed.add_field(name="📱 Current Settings", value=status_info, inline=False)

        await ctx.send(embed=embed)


    @commands.command(name="ai_chat")
    @commands.has_permissions(administrator=True)
    async def ai_chat(self, ctx, model: str = None):
        if not model:
            embed = discord.Embed(
                title="Available AI Models",
                color=discord.Color.blue(),
                description="Select a model using `!ai_chat <model_name>`"
            )
            for model_name, description in self.available_models.items():
                embed.add_field(name=model_name, value=description, inline=False)
            await ctx.send(embed=embed)
            return

        if model.lower() not in self.available_models:
            await ctx.send(f"❌ Invalid model. Use one of: {', '.join(self.available_models.keys())}")
            return

        guild_id = ctx.guild.id
        self.ai_channels[guild_id] = {"model": model.lower()}
        await ctx.send(f"✅ AI chat model set to: `{model}`")

    @commands.command(name="ai_chat_set")
    @commands.has_permissions(administrator=True)
    async def ai_chat_set(self, ctx, channel: discord.TextChannel):
        guild_id = ctx.guild.id
        if guild_id not in self.ai_channels:
            self.ai_channels[guild_id] = {"model": self.default_model}
        
        self.ai_channels[guild_id]["channel"] = channel.id
        self.channel_states[channel.id] = True  
        
        embed = discord.Embed(
            title="AI Chat Channel Set",
            description=f"AI Chat enabled in {channel.mention}",
            color=discord.Color.green()
        )
        embed.add_field(name="Model", value=self.ai_channels[guild_id]["model"])
        embed.add_field(name="Status", value="Active")
        await ctx.send(embed=embed)

    @commands.command(name="ai_chat_unset")
    @commands.has_permissions(administrator=True)
    async def ai_chat_unset(self, ctx):
        guild_id = ctx.guild.id
        if guild_id in self.ai_channels:
            channel_id = self.ai_channels[guild_id].get("channel")
            if channel_id:
                del self.channel_states[channel_id]
            del self.ai_channels[guild_id]
            await ctx.send("✅ AI chat configuration has been reset")
        else:
            await ctx.send("❌ No AI chat configuration found")

    @commands.command(name="ai_chat_pause")
    @commands.has_permissions(administrator=True)
    async def ai_chat_pause(self, ctx):
        guild_id = ctx.guild.id
        if guild_id in self.ai_channels and "channel" in self.ai_channels[guild_id]:
            channel_id = self.ai_channels[guild_id]["channel"]
            self.channel_states[channel_id] = False
            embed = discord.Embed(
                title="AI Chat Paused",
                description="AI responses are temporarily paused",
                color=discord.Color.orange()
            )
            await ctx.send(embed=embed)
        else:
            await ctx.send("❌ No active AI chat channel found")

    @commands.command(name="ai_chat_resume")
    @commands.has_permissions(administrator=True)
    async def ai_chat_resume(self, ctx):
        guild_id = ctx.guild.id
        if guild_id in self.ai_channels and "channel" in self.ai_channels[guild_id]:
            channel_id = self.ai_channels[guild_id]["channel"]
            self.channel_states[channel_id] = True
            embed = discord.Embed(
                title="AI Chat Resumed",
                description="AI responses are now active",
                color=discord.Color.green()
            )
            await ctx.send(embed=embed)
        else:
            await ctx.send("❌ No AI chat channel found")

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
        if message.guild is None:
            return  # Skip processing for DM messages
        guild_id = message.guild.id

        if guild_id not in self.ai_channels:
            return

        channel_id = self.ai_channels[guild_id].get("channel")
        if message.channel.id != channel_id:
            return

        if not self.channel_states.get(channel_id, False):
            return

        user_id = message.author.id
        current_time = time.time()
        
        if user_id in self.rate_limits:
            last_request = self.rate_limits[user_id]
            if current_time - last_request < self.rate_limit_cooldown:
                remaining_time = int(self.rate_limit_cooldown - (current_time - last_request))
                await message.reply(f"🕒 Please wait {remaining_time} seconds before sending another message!")
                return
        
        self.rate_limits[user_id] = current_time

        try:
            async with message.channel.typing():
                model = self.ai_channels[guild_id].get("model", self.default_model)
                
                if not self.api_key:
                    await message.channel.send("⚠️ OpenAI API key not configured!")
                    return

                if guild_id not in self.conversation_history:
                    self.conversation_history[guild_id] = []
                
                self.conversation_history[guild_id].append({"role": "user", "content": message.content})
                
                headers = {
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                }

                payload = {
                    "model": model,
                    "messages": [
                        {"role": "system", "content": "You are a helpful AI assistant."},
                        *self.conversation_history[guild_id][-5:]  
                    ],
                    "temperature": 0.7
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        "https://api.openai.com/v1/chat/completions",
                        headers=headers,
                        json=payload
                    ) as response:
                        if response.status == 200:
                            data = await response.json()
                            ai_response = data['choices'][0]['message']['content']
                            
                            self.conversation_history[guild_id].append(
                                {"role": "assistant", "content": ai_response}
                            )
                            
                            await message.reply(ai_response)
                        elif response.status == 402:
                            embed = discord.Embed(
                                title="❌ Insufficient Credits",
                                description="AI chat has been automatically paused. Please add credits to your OpenAI account.",
                                color=discord.Color.red()
                            )
                            self.channel_states[channel_id] = False
                            await message.channel.send(embed=embed)
                        elif response.status == 429:
                            embed = discord.Embed(
                                title="⚠️ Rate Limited",
                                description="Too many requests. Please try again in a few minutes.",
                                color=discord.Color.orange()
                            )
                            await message.channel.send(embed=embed)
                        else:
                            error_data = await response.json()
                            embed = discord.Embed(
                                title="❌ API Error",
                                description=error_data.get('error', {}).get('message', 'Unknown error'),
                                color=discord.Color.red()
                            )
                            await message.channel.send(embed=embed)

        except aiohttp.ClientError as e:
            embed = discord.Embed(
                title="❌ Network Error",
                description="Failed to connect to OpenAI API. Please try again later.",
                color=discord.Color.red()
            )
            await message.channel.send(embed=embed)
            print(f"API Request Error: {str(e)}")
        except Exception as e:
            embed = discord.Embed(
                title="❌ Unexpected Error",
                description=f"Please contact an administrator.\nError: {str(e)}",
                color=discord.Color.red()
            )
            await message.channel.send(embed=embed)

class AdvancedUserAnalytics(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.user_data = {}
        self.voice_times = {}
        self.analytics_db = AnalyticsDatabase()
        self.load_data()
        self.bot.loop.create_task(self.initialize_analytics_data())
        self.prediction_model = self.setup_prediction_model()
        
    def calculate_influence_score(self, user_data):
        influence_factors = {
            'reactions_received': 0.3,
            'message_replies': 0.25,
            'mentions': 0.2,
            'thread_activity': 0.15,
            'role_weight': 0.1
        }
        
        score = 0
        for factor, weight in influence_factors.items():
            value = user_data.get(factor, 0)
            score += value * weight
            
        activity_multiplier = min(user_data.get('active_days', 1) / 30, 1)
        final_score = score * activity_multiplier
        
        return round(final_score, 2)

    def calculate_engagement_rate(self, user_data):
        total_interactions = sum([
            user_data.get('messages', 0),
            user_data.get('reactions_given', 0),
            user_data.get('reactions_received', 0),
            user_data.get('voice_minutes', 0),
            user_data.get('thread_participation', 0)
        ])
        
        active_days = user_data.get('active_days', 1)
        engagement_rate = (total_interactions / active_days) * 100
        
        return round(engagement_rate, 2)

    def calculate_activity_score(self, user_data):
        weights = {
            'messages': 0.4,
            'voice_minutes': 0.3,
            'reactions': 0.2,
            'commands': 0.1
        }
        
        score = 0
        for metric, weight in weights.items():
            value = user_data.get(metric, 0)
            score += value * weight
            
        return round(score, 2)

    async def initialize_analytics_data(self):
        for guild in self.bot.guilds:
            if guild.id not in self.user_data:
                self.user_data[guild.id] = {}
                
            for member in guild.members:
                if member.id not in self.user_data[guild.id]:
                    self.user_data[guild.id][member.id] = {
                        'messages': 0,
                        'voice_time': 0,
                        'reactions': 0,
                        'commands': 0,
                        'activity_hours': {str(i): 0 for i in range(24)},
                        'channel_activity': {},
                        'role_history': [role.name for role in member.roles],
                        'join_date': member.joined_at.isoformat() if member.joined_at else None,
                        'last_active': datetime.now().isoformat(),
                        'infractions': [],
                        'achievements': [],
                        'engagement_metrics': {
                            'replies': 0,
                            'mentions': 0,
                            'threads': 0,
                            'reactions_given': 0,
                            'reactions_received': 0
                        }
                    }
        self.save_data()

    def load_data(self):
        try:
            with open('data/analytics_data.json', 'r') as f:
                self.user_data = json.load(f)
        except FileNotFoundError:
            self.user_data = {}
            self.save_data()

    def save_data(self):
        guild_data = {}
        for guild in self.bot.guilds:
            guild_data[guild.id] = {
                'roles': {
                    role.id: {
                        'name': role.name,
                        'color': role.color.value,
                        'members': len(role.members),
                        'position': role.position,
                        'hoisted': role.hoist,
                        'mentionable': role.mentionable
                    } for role in guild.roles
                },
                'members': {
                    member.id: {
                        'messages': self.user_data.get(guild.id, {}).get(member.id, {}).get('messages', 0),
                        'voice_time': self.user_data.get(guild.id, {}).get(member.id, {}).get('voice_time', 0),
                        'reactions': self.user_data.get(guild.id, {}).get(member.id, {}).get('reactions', 0),
                        'commands': self.user_data.get(guild.id, {}).get(member.id, {}).get('commands', 0),
                        'activity_hours': self.user_data.get(guild.id, {}).get(member.id, {}).get('activity_hours', {}),
                        'channel_activity': self.user_data.get(guild.id, {}).get(member.id, {}).get('channel_activity', {}),
                        'role_history': self.user_data.get(guild.id, {}).get(member.id, {}).get('role_history', []),
                        'join_date': member.joined_at.isoformat() if member.joined_at else None,
                        'last_active': datetime.now().isoformat(),
                        'engagement_metrics': self.user_data.get(guild.id, {}).get(member.id, {}).get('engagement_metrics', {
                            'replies': 0,
                            'mentions': 0,
                            'threads': 0,
                            'reactions_given': 0,
                            'reactions_received': 0
                        })
                    } for member in guild.members
                }
            }
        
        with open('data/analytics_data.json', 'w') as f:
            json.dump(guild_data, f, indent=4)

    def setup_prediction_model(self):
        return {
            'activity_weights': {
                'messages': 0.4,
                'voice': 0.3,
                'reactions': 0.2,
                'commands': 0.1
            },
            'trend_window': 7
        }

    def prepare_export_data(self, guild_id, timeframe):
        guild = self.bot.get_guild(guild_id)
        guild_data = self.user_data.get(guild_id, {})

        data = {
            'timeframe': timeframe,
            'export_date': datetime.now().isoformat(),
            'guild_id': guild_id,
            'analytics': {
                'activity': {
                    'messages': guild_data.get('total_messages', 0),
                    'active_users': len([m for m in guild.members if not m.bot]),
                    'reactions': guild_data.get('total_reactions', 0),
                    'peak_hour': max(range(24), key=lambda h: guild_data.get('hourly_activity', {}).get(str(h), 0)),
                    'channel_activity': {
                        channel.id: {
                            'name': channel.name,
                            'messages': guild_data.get('channel_stats', {}).get(str(channel.id), 0)
                        } for channel in guild.text_channels
                    }
                },
                'roles': {
                    'hierarchy': [role.name for role in sorted(guild.roles, key=lambda r: r.position, reverse=True)],
                    'statistics': {
                        'total': len(guild.roles),
                        'hoisted': len([r for r in guild.roles if r.hoist]),
                        'colored': len([r for r in guild.roles if r.color != discord.Color.default()]),
                        'managed': len([r for r in guild.roles if r.managed])
                    },
                    'distribution': {role.name: len(role.members) for role in guild.roles},
                    'recent_changes': guild_data.get('role_changes', [])
                },
                'content_analysis': {
                    'message_types': guild_data.get('message_types', {}),
                    'trending_topics': dict(sorted(
                        guild_data.get('trending_topics', {}).items(),
                        key=lambda x: x[1],
                        reverse=True
                    )[:10]),
                    'metrics': {
                        'avg_message_length': guild_data.get('content_metrics', {}).get('total_length', 0) / 
                                            (guild_data.get('total_messages', 1) or 1),
                        'engagement_rate': guild_data.get('total_reactions', 0) / 
                                        (guild_data.get('total_messages', 1) or 1),
                        'content_uniqueness': len(guild_data.get('trending_topics', {})) / 
                                            (guild_data.get('total_messages', 1) or 1) * 100
                    }
                },
                'predictive_analytics': {
                    'membership': {
                        'predicted_members': len(guild.members) + int(len(guild.members) * 0.1),
                        'growth_rate': guild_data.get('growth_rate', 0.1)
                    },
                    'health_score': guild_data.get('health_score', 50)
                },
                'activity_heatmap': {
                    f"{hour:02d}:00": guild_data.get('hourly_activity', {}).get(str(hour), 0)
                    for hour in range(24)
                }
            }
        }
        
        return data

    @commands.command(name="analytics")
    async def show_analytics(self, ctx, target: Union[discord.Member, str] = None):
        if isinstance(target, str) and target.lower() == "server":
            view = ServerAnalyticsView(self, ctx)
            embed = self.create_server_overview(ctx.guild)
            await ctx.send(embed=embed, view=view)
        else:
            member = target or ctx.author
            view = EnhancedUserAnalyticsView(self, ctx, member)
            embed = self.create_advanced_overview(member)
            await ctx.send(embed=embed, view=view)

    @commands.command(name="analytics_export")
    @commands.has_permissions(administrator=True)
    async def export_analytics(self, ctx, timeframe: str = "all"):
        data = self.prepare_export_data(ctx.guild.id, timeframe)
        file = discord.File(
            io.StringIO(json.dumps(data, indent=2)),
            filename=f"analytics_export_{ctx.guild.id}_{timeframe}.json"
        )
        await ctx.send("Analytics data export:", file=file)

    @commands.Cog.listener()
    async def on_message(self, message):
        if not message.guild or message.author.bot:
            return
        if message.guild:  
            return               
        guild_id = message.guild.id
        hour = message.created_at.hour
        

        if guild_id not in self.user_data:
            self.user_data[guild_id] = {
                'total_messages': 0,
                'message_types': {'text': 0, 'images': 0, 'videos': 0, 'links': 0, 'embeds': 0, 'files': 0},
                'hourly_activity': {str(h): 0 for h in range(24)},
                'channel_stats': {},
                'trending_topics': {},
                'content_metrics': {'total_length': 0}
            }
        

        if 'total_messages' not in self.user_data[guild_id]:
            self.user_data[guild_id]['total_messages'] = 0
        
        if 'hourly_activity' not in self.user_data[guild_id]:
            self.user_data[guild_id]['hourly_activity'] = {str(h): 0 for h in range(24)}
        elif str(hour) not in self.user_data[guild_id]['hourly_activity']:
            self.user_data[guild_id]['hourly_activity'][str(hour)] = 0
        
        if 'message_types' not in self.user_data[guild_id]:
            self.user_data[guild_id]['message_types'] = {'text': 0, 'images': 0, 'videos': 0, 'links': 0, 'embeds': 0, 'files': 0}
        
        if 'channel_stats' not in self.user_data[guild_id]:
            self.user_data[guild_id]['channel_stats'] = {}
        
        if 'trending_topics' not in self.user_data[guild_id]:
            self.user_data[guild_id]['trending_topics'] = {}
        
        if 'content_metrics' not in self.user_data[guild_id]:
            self.user_data[guild_id]['content_metrics'] = {'total_length': 0}
        elif 'total_length' not in self.user_data[guild_id]['content_metrics']:
            self.user_data[guild_id]['content_metrics']['total_length'] = 0


        self.user_data[guild_id]['total_messages'] += 1
        self.user_data[guild_id]['hourly_activity'][str(hour)] += 1
        
        if message.attachments:
            for attachment in message.attachments:
                if hasattr(attachment, 'content_type') and attachment.content_type:
                    if 'image' in attachment.content_type:
                        self.user_data[guild_id]['message_types']['images'] += 1
                    elif 'video' in attachment.content_type:
                        self.user_data[guild_id]['message_types']['videos'] += 1
                    else:
                        self.user_data[guild_id]['message_types']['files'] += 1
                else:
                    
                    self.user_data[guild_id]['message_types']['files'] += 1
        elif message.embeds:
            self.user_data[guild_id]['message_types']['embeds'] += 1
        elif any(url in message.content for url in ['http://', 'https://']):
            self.user_data[guild_id]['message_types']['links'] += 1
        else:
            self.user_data[guild_id]['message_types']['text'] += 1

        channel_id = str(message.channel.id)
        self.user_data[guild_id]['channel_stats'][channel_id] = self.user_data[guild_id]['channel_stats'].get(channel_id, 0) + 1

        self.user_data[guild_id]['content_metrics']['total_length'] += len(message.content)
        
        words = message.content.lower().split()
        for word in words:
            if len(word) > 3:
                self.user_data[guild_id]['trending_topics'][word] = self.user_data[guild_id]['trending_topics'].get(word, 0) + 1

        self.save_data()

    @commands.Cog.listener()
    async def on_reaction_add(self, reaction, user):
        if not reaction.message.guild or user.bot:
            return
        await self.analytics_db.update_user_activity(
            user.id,
            reaction.message.guild.id,
            'reaction',
            1
        )

    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if member.bot:
            return
            
        if not before.channel and after.channel:
            self.voice_times[member.id] = time.time()
        elif before.channel and not after.channel and member.id in self.voice_times:
            duration = time.time() - self.voice_times[member.id]
            minutes = int(duration / 60)
            await self.analytics_db.update_user_activity(
                member.id,
                member.guild.id,
                'voice',
                minutes
            )
            del self.voice_times[member.id]

    def create_advanced_overview(self, member):
        embed = discord.Embed(
            title=f"Analytics Overview for {member.name}",
            color=member.color,
            timestamp=datetime.now()
        )

        user_stats = self.user_data.get(member.guild.id, {}).get(str(member.id), {})
        
        activity_score = self.calculate_activity_score(user_stats)
        engagement_rate = self.calculate_engagement_rate(user_stats)
        influence_score = self.calculate_influence_score(user_stats)
        
        embed.add_field(
            name="Activity Metrics",
            value=f"Messages: {user_stats.get('messages', 0)}\n"
                f"Voice Time: {user_stats.get('voice_time', 0)} minutes\n"
                f"Reactions: {user_stats.get('reactions', 0)}\n"
                f"Commands Used: {user_stats.get('commands', 0)}",
            inline=True
        )
        
        embed.add_field(
            name="Performance Metrics",
            value=f"Activity Score: {activity_score}\n"
                f"Engagement Rate: {engagement_rate}%\n"
                f"Influence Score: {influence_score}",
            inline=True
        )
        
        engagement_metrics = user_stats.get('engagement_metrics', {})
        embed.add_field(
            name="Engagement Details",
            value=f"Replies: {engagement_metrics.get('replies', 0)}\n"
                f"Mentions: {engagement_metrics.get('mentions', 0)}\n"
                f"Thread Activity: {engagement_metrics.get('threads', 0)}",
            inline=False
        )

        return embed

class BaseAnalyticsButton(discord.ui.Button):
    def __init__(self, label, emoji, style=discord.ButtonStyle.primary):
        super().__init__(label=label, emoji=emoji, style=style)
        self.historical_data = {}

    def calculate_growth_rate(self, data):
        periods = len(data['historical_members'])
        if periods < 2:
            return 0
        initial = data['historical_members'][0]
        final = data['historical_members'][-1]
        return (final - initial) / initial / periods

    def analyze_activity_pattern(self, data):
        activity_data = data.get('activity_history', [])
        if not activity_data:
            return []
        
        pattern = []
        for i in range(len(activity_data) - 7):
            week_data = activity_data[i:i+7]
            pattern.append(sum(week_data) / 7)
        return pattern

    async def get_historical_data(self, guild):
        now = datetime.now()
        thirty_days_ago = now - timedelta(days=30)
        
        data = {
            'members': [],
            'message_history': [],
            'reaction_history': [],
            'voice_history': [],
            'activity_history': []
        }
        
        async for entry in guild.audit_logs(action=discord.AuditLogAction.member_update, after=thirty_days_ago):
            data['members'].append(entry.target.id)
            
        for channel in guild.text_channels:
            try:
                message_count = 0
                reaction_count = 0
                async for message in channel.history(after=thirty_days_ago, limit=None):
                    message_count += 1
                    reaction_count += sum(reaction.count for reaction in message.reactions)
                    
                data['message_history'].append(message_count)
                data['reaction_history'].append(reaction_count)
            except discord.Forbidden:
                continue
                
        voice_users = sum(len(vc.members) for vc in guild.voice_channels)
        data['voice_history'].append(voice_users)
        
        return data

class ActivityHeatmapButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Activity Heatmap", emoji="🌡️")
   
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer()
        activity_data = await self.get_hourly_activity_data(interaction.guild)
        heatmap = self.generate_ascii_heatmap(activity_data)
        
        embed = discord.Embed(title="Server Activity Heatmap", color=discord.Color.blue())
        embed.add_field(name="24-Hour Activity Pattern", value=f"```{heatmap}```", inline=False)
        embed.add_field(name="Peak Hours", value=self.get_peak_hours(activity_data), inline=True)
        embed.add_field(name="Quiet Hours", value=self.get_quiet_hours(activity_data), inline=True)
        
        await interaction.followup.send(embed=embed)

    async def get_hourly_activity_data(self, guild):
        data = {i: 0 for i in range(24)}
        now = datetime.now()
        day_ago = now - timedelta(days=1)
        
        for channel in guild.text_channels:
            try:
                async for message in channel.history(after=day_ago):
                    hour = message.created_at.hour
                    data[hour] += 1
            except discord.Forbidden:
                continue
        
        return data

    def generate_ascii_heatmap(self, data):
        max_value = max(data.values()) if data.values() else 1
        heatmap = ""
        for hour in range(24):
            activity = data[hour]
            intensity = min(int((activity / max_value) * 8), 8)
            bar = "█" * intensity + "░" * (8 - intensity)
            heatmap += f"{hour:02d}:00 {bar} ({activity})\n"
        return heatmap

    def get_peak_hours(self, data):
        sorted_hours = sorted(data.items(), key=lambda x: x[1], reverse=True)
        peak_hours = [f"{hour:02d}:00" for hour, _ in sorted_hours[:3]]
        return ", ".join(peak_hours)

    def get_quiet_hours(self, data):
        sorted_hours = sorted(data.items(), key=lambda x: x[1])
        quiet_hours = [f"{hour:02d}:00" for hour, _ in sorted_hours[:3]]
        return ", ".join(quiet_hours)

class EnhancedUserAnalyticsView(discord.ui.View):
    def __init__(self, cog, ctx, member):
        super().__init__(timeout=300)
        self.cog = cog
        self.ctx = ctx
        self.member = member
        self.timeframe = "week"
        self.setup_buttons()

    def setup_buttons(self):
        self.add_item(ActivityHeatmapButton())
        self.add_item(EngagementMetricsButton())
        self.add_item(RoleProgressionButton())
        self.add_item(ContentAnalysisButton())
        self.add_item(PredictiveTrendsButton())

class ServerAnalyticsDashboard(discord.ui.View):
    def __init__(self, cog, guild):
        super().__init__()
        self.cog = cog
        self.guild = guild
        self.setup_dashboard()

    def setup_dashboard(self):
        self.add_item(ActivityHeatmapButton())
        self.add_item(MemberRetentionButton())
        self.add_item(RoleDistributionButton())
        self.add_item(ChannelHealthButton())
        self.add_item(CommunityGrowthButton())
        self.add_item(EngagementMetricsButton())
        self.add_item(ModrationStatsButton())
        self.add_item(ContentAnalysisButton())
        self.add_item(TimelineViewButton())
        self.add_item(PredictiveTrendsButton())


class PredictiveTrendsButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Predictive Trends", emoji="🔮")

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer()
        predictions = await self.generate_predictions(interaction.guild)
        embed = self.create_predictions_embed(predictions)
        await interaction.followup.send(embed=embed)

    async def generate_predictions(self, guild):
        historical_data = await self.get_historical_data(guild)
        return {
            'member_growth': self.predict_member_growth(historical_data),
            'activity_trends': self.predict_activity_trends(historical_data),
            'engagement_forecast': self.predict_engagement_levels(historical_data),
            'channel_predictions': self.predict_channel_activity(historical_data),
            'content_trends': self.predict_content_trends(historical_data),
            'role_evolution': self.predict_role_changes(historical_data),
            'community_health': self.predict_community_health(historical_data)
        }

    async def get_historical_data(self, guild):
        now = datetime.now()
        week_ago = now - timedelta(days=7)
        
        data = {
            'members': [],
            'message_history': [],
            'reaction_history': [],
            'active_users': set(),
            'channel_activity': {},
            'peak_posting_times': {},
            'content_types': {'text': 0, 'images': 0, 'links': 0}
        }
        
        for channel in guild.text_channels:
            try:
                async for message in channel.history(after=week_ago):
                    hour = message.created_at.hour
                    data['peak_posting_times'][hour] = data['peak_posting_times'].get(hour, 0) + 1
                    data['active_users'].add(message.author.id)
                    data['message_history'].append(message.created_at.timestamp())
                    data['reaction_history'].append(sum(r.count for r in message.reactions))
                    data['channel_activity'][channel.id] = data['channel_activity'].get(channel.id, 0) + 1
                    
                    if message.attachments:
                        data['content_types']['images'] += 1
                    elif any(url in message.content for url in ['http://', 'https://']):
                        data['content_types']['links'] += 1
                    else:
                        data['content_types']['text'] += 1
            except discord.Forbidden:
                continue
                
        data['members'] = [m.id for m in guild.members]
        return data

    def predict_member_growth(self, data):
        members = data.get('members', [])
        current_members = len(members)
        growth_rate = 0.1
        seasonal_factor = 1.0
        trend_adjustment = 0
        
        predicted_growth = current_members * (1 + growth_rate) * seasonal_factor + trend_adjustment
        confidence_interval = (predicted_growth * 0.9, predicted_growth * 1.1)
        
        return {
            'predicted_members': round(predicted_growth),
            'confidence_interval': confidence_interval,
            'growth_rate': growth_rate,
            'seasonal_impact': seasonal_factor,
            'trend_strength': trend_adjustment
        }

    def predict_activity_trends(self, data):
        message_history = data.get('message_history', [])
        activity_pattern = [sum(1 for msg in message_history if msg > time.time() - 86400 * (i + 1)) for i in range(7)]
        
        return {
            'daily_predictions': activity_pattern,
            'peak_times': self.get_peak_hours(data),
            'activity_type_distribution': {'messages': 0.6, 'reactions': 0.3, 'voice': 0.1},
            'engagement_levels': {'high': 0.3, 'medium': 0.5, 'low': 0.2}
        }

    def predict_content_trends(self, data):
        total_content = sum(data['content_types'].values()) or 1
        content_distribution = {
            k: v / total_content for k, v in data['content_types'].items()
        }
        
        return {
            'popular_content_types': content_distribution,
            'emerging_topics': ['topic1', 'topic2', 'topic3'],
            'engagement_patterns': {'increasing': 0.6, 'stable': 0.3, 'decreasing': 0.1},
            'content_quality_trends': {'improving': 0.7, 'stable': 0.2, 'declining': 0.1}
        }

    def predict_engagement_levels(self, data):
        return {
            'daily_active_users': len(data.get('active_users', [])),
            'message_frequency': len(data.get('message_history', [])),
            'reaction_rate': sum(data.get('reaction_history', [])),
            'trend': 'increasing'
        }

    def predict_channel_activity(self, data):
        return {
            'active_channels': len(data.get('channel_activity', {})),
            'growth_channels': [],
            'declining_channels': [],
            'suggested_actions': []
        }

    def predict_role_changes(self, data):
        return {
            'role_distribution': {},
            'role_trends': [],
            'suggested_changes': []
        }

    def predict_community_health(self, data):
        active_ratio = len(data.get('active_users', [])) / len(data.get('members', [1])) if data.get('members') else 0
        health_score = min(round(active_ratio * 100), 100)
        
        return {
            'health_score': health_score,
            'risk_factors': [],
            'improvement_areas': []
        }

    def get_peak_hours(self, data):
        activity_by_hour = data.get('peak_posting_times', {})
        sorted_hours = sorted(activity_by_hour.items(), key=lambda x: x[1], reverse=True)
        return [hour for hour, _ in sorted_hours[:3]] if sorted_hours else [12, 15, 18]

    def create_predictions_embed(self, predictions):
        embed = discord.Embed(
            title="Predictive Analytics Dashboard",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        member_growth = predictions['member_growth']
        embed.add_field(
            name="Membership Forecast",
            value=f"Predicted Members: {member_growth['predicted_members']}\n"
                  f"Growth Rate: {member_growth['growth_rate']:.2%}",
            inline=False
        )
        
        activity = predictions['activity_trends']
        embed.add_field(
            name="Activity Forecast",
            value=f"Peak Hours: {', '.join(f'{h:02d}:00' for h in activity['peak_times'])}\n"
                  f"Engagement Trend: {'📈' if activity['engagement_levels']['high'] > 0.3 else '📉'}",
            inline=True
        )
        
        content = predictions['content_trends']
        embed.add_field(
            name="Content Trends",
            value=f"Top Type: {max(content['popular_content_types'].items(), key=lambda x: x[1])[0]}\n"
                  f"Quality Trend: {'📈' if content['content_quality_trends']['improving'] > 0.5 else '📊'}",
            inline=True
        )
        
        health = predictions['community_health']
        embed.add_field(
            name="Community Health",
            value=f"Health Score: {health['health_score']}%\n"
                  f"Status: {'🟢 Healthy' if health['health_score'] > 70 else '🟡 Moderate' if health['health_score'] > 40 else '🔴 Needs Attention'}",
            inline=False
        )
        
        return embed

class EngagementMetricsButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Engagement Metrics", emoji="📊")
   
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer()
        metrics = await self.calculate_engagement_metrics(interaction.guild)
        embed = self.create_engagement_embed(metrics)
        await interaction.followup.send(embed=embed)

    async def calculate_engagement_metrics(self, guild):
        now = datetime.now()
        week_ago = now - timedelta(days=7)
        metrics = {
            'total_messages': 0,
            'active_users': set(),
            'reactions_given': 0,
            'threads_created': 0,
            'voice_minutes': 0,
            'peak_times': {},
            'channel_activity': {}
        }
        
        for channel in guild.text_channels:
            try:
                async for message in channel.history(after=week_ago):
                    metrics['total_messages'] += 1
                    metrics['active_users'].add(message.author.id)
                    metrics['reactions_given'] += sum(r.count for r in message.reactions)
                    hour = message.created_at.hour
                    metrics['peak_times'][hour] = metrics['peak_times'].get(hour, 0) + 1
                    metrics['channel_activity'][channel.id] = metrics['channel_activity'].get(channel.id, 0) + 1
            except discord.Forbidden:
                continue
        
        return metrics

    def create_engagement_embed(self, metrics):
        embed = discord.Embed(
            title="Engagement Metrics Dashboard",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        embed.add_field(
            name="Activity Overview",
            value=f"Messages: {metrics['total_messages']}\n"
                  f"Active Users: {len(metrics['active_users'])}\n"
                  f"Total Reactions: {metrics['reactions_given']}",
            inline=False
        )
        
        if metrics['peak_times']:
            peak_hour = max(metrics['peak_times'].items(), key=lambda x: x[1])[0]
            embed.add_field(
                name="Peak Activity",
                value=f"Most Active Hour: {peak_hour:02d}:00",
                inline=True
            )
        
        if metrics['channel_activity']:
            top_channel = max(metrics['channel_activity'].items(), key=lambda x: x[1])[0]
            embed.add_field(
                name="Channel Activity",
                value=f"Most Active Channel: <#{top_channel}>",
                inline=True
            )
        
        return embed

class RoleProgressionButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Role Progress", emoji="📈")
   
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer()
        progression = await self.analyze_role_progression(interaction.guild)
        embed = self.create_progression_embed(progression)
        await interaction.followup.send(embed=embed)

    async def analyze_role_progression(self, guild):
        role_data = {
            'hierarchy': [],
            'distribution': {},
            'recent_changes': [],
            'suggested_next': {},
            'role_stats': {
                'total_roles': len(guild.roles),
                'hoisted_roles': len([r for r in guild.roles if r.hoist]),
                'color_roles': len([r for r in guild.roles if r.color != discord.Color.default()]),
                'managed_roles': len([r for r in guild.roles if r.managed])
            }
        }
        
        for role in sorted(guild.roles, key=lambda r: r.position, reverse=True):
            role_data['hierarchy'].append(role.name)
            role_data['distribution'][role.name] = len(role.members)
            
        async for entry in guild.audit_logs(action=discord.AuditLogAction.member_role_update, limit=20):
            if entry.target:
                before_roles = getattr(getattr(entry.changes, 'before', None), 'roles', [])
                after_roles = getattr(getattr(entry.changes, 'after', None), 'roles', [])
                
                for role in after_roles:
                    if role not in before_roles:
                        role_data['recent_changes'].append({
                            'user': entry.target.name,
                            'role': role.name,
                            'type': 'added',
                            'date': entry.created_at
                        })
                
                for role in before_roles:
                    if role not in after_roles:
                        role_data['recent_changes'].append({
                            'user': entry.target.name,
                            'role': role.name,
                            'type': 'removed',
                            'date': entry.created_at
                        })
        
        return role_data

    def create_progression_embed(self, progression):
        embed = discord.Embed(
            title="Role Progression Analysis",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        if progression['hierarchy']:
            hierarchy_text = "\n".join(f"{idx+1}. {role}" for idx, role in enumerate(progression['hierarchy'][:10]))
            embed.add_field(
                name="Role Hierarchy (Top 10)",
                value=hierarchy_text or "No roles found",
                inline=False
            )
        
        stats = progression.get('role_stats', {})
        stats_text = (
            f"Total Roles: {stats.get('total_roles', 0)}\n"
            f"Hoisted Roles: {stats.get('hoisted_roles', 0)}\n"
            f"Color Roles: {stats.get('color_roles', 0)}\n"
            f"Managed Roles: {stats.get('managed_roles', 0)}"
        )
        embed.add_field(name="Role Statistics", value=stats_text, inline=True)
        
        if progression['recent_changes']:
            changes = "\n".join(
                f"• {change['user']}: {change['type']} {change['role']}"
                for change in sorted(
                    progression['recent_changes'][:5],
                    key=lambda x: x['date'],
                    reverse=True
                )
            )
            embed.add_field(name="Recent Changes", value=changes or "No recent changes", inline=False)
        
        top_roles = sorted(
            progression['distribution'].items(),
            key=lambda x: x[1],
            reverse=True
        )[:5]
        distribution_text = "\n".join(f"{role}: {count} members" for role, count in top_roles)
        embed.add_field(name="Most Popular Roles", value=distribution_text or "No data", inline=True)
        
        return embed

class TimelineViewButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Timeline", emoji="📅")
    
    async def callback(self, interaction: discord.Interaction):
        timeline = await self.generate_timeline(interaction.guild)
        embed = self.create_timeline_embed(timeline)
        await interaction.response.edit_message(embed=embed)

    async def generate_timeline(self, guild):
        now = datetime.now()
        month_ago = now - timedelta(days=30)
        
        timeline = {
            'member_joins': [],
            'channel_creation': [],
            'role_changes': [],
            'major_events': [],
            'activity_spikes': []
        }
        
        async for entry in guild.audit_logs(after=month_ago):
            if entry.action == discord.AuditLogAction.member_join:
                timeline['member_joins'].append((entry.target.name, entry.created_at))
            elif entry.action == discord.AuditLogAction.channel_create:
                timeline['channel_creation'].append((entry.target.name, entry.created_at))
            elif entry.action == discord.AuditLogAction.member_role_update:
                timeline['role_changes'].append((entry.target.name, entry.changes, entry.created_at))
                
        return timeline

class ModrationStatsButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Moderation Stats", emoji="🛡️")
    
    async def callback(self, interaction: discord.Interaction):
        stats = await self.gather_moderation_stats(interaction.guild)
        embed = self.create_moderation_embed(stats)
        await interaction.response.edit_message(embed=embed)

    async def gather_moderation_stats(self, guild):
        now = datetime.now()
        month_ago = now - timedelta(days=30)
        
        stats = {
            'warnings': 0,
            'kicks': 0,
            'bans': 0,
            'mutes': 0,
            'message_deletions': 0,
            'mod_actions_by_user': {},
            'most_common_reasons': {},
            'active_mods': set(),
            'peak_incident_times': {},
            'repeat_offenders': set()
        }
        
        async for entry in guild.audit_logs(after=month_ago):
            if entry.action == discord.AuditLogAction.ban:
                stats['bans'] += 1
            elif entry.action == discord.AuditLogAction.kick:
                stats['kicks'] += 1
            elif entry.action == discord.AuditLogAction.message_delete:
                stats['message_deletions'] += 1
                
            if entry.user.guild_permissions.moderate_members:
                stats['active_mods'].add(entry.user.id)
                stats['mod_actions_by_user'][entry.user.id] = stats['mod_actions_by_user'].get(entry.user.id, 0) + 1
                
            hour = entry.created_at.hour
            stats['peak_incident_times'][hour] = stats['peak_incident_times'].get(hour, 0) + 1
            
        return stats

class ChannelHealthButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Channel Health", emoji="📊")
    
    async def callback(self, interaction: discord.Interaction):
        health_data = await self.analyze_channel_health(interaction.guild)
        embed = self.create_health_embed(health_data)
        await interaction.response.edit_message(embed=embed)

    async def analyze_channel_health(self, guild):
        now = datetime.now()
        week_ago = now - timedelta(days=7)
        
        health_data = {
            'channels': {},
            'categories': {},
            'overall_health': 0,
            'recommendations': [],
            'inactive_channels': [],
            'overactive_channels': [],
            'engagement_distribution': {}
        }
        
        for channel in guild.text_channels:
            try:
                message_count = 0
                unique_users = set()
                reaction_count = 0
                
                async for message in channel.history(after=week_ago):
                    message_count += 1
                    unique_users.add(message.author.id)
                    reaction_count += sum(r.count for r in message.reactions)
                    
                health_score = self.calculate_channel_health_score(
                    message_count,
                    len(unique_users),
                    reaction_count
                )
                
                health_data['channels'][channel.id] = {
                    'name': channel.name,
                    'message_count': message_count,
                    'unique_users': len(unique_users),
                    'reaction_count': reaction_count,
                    'health_score': health_score
                }
                
                if health_score < 30:
                    health_data['inactive_channels'].append(channel.id)
                elif health_score > 80:
                    health_data['overactive_channels'].append(channel.id)
                    
            except discord.Forbidden:
                continue
                
        return health_data

    def calculate_channel_health_score(self, messages, users, reactions):
        base_score = min((messages / 100) * 40 + (users / 10) * 40 + (reactions / messages if messages else 0) * 20, 100)
        return round(base_score, 2)

class CommunityGrowthButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Growth Analytics", emoji="📈")
    
    async def callback(self, interaction: discord.Interaction):
        growth_data = await self.analyze_growth(interaction.guild)
        embed = self.create_growth_embed(growth_data)
        await interaction.response.edit_message(embed=embed)

    async def analyze_growth(self, guild):
        now = datetime.now()
        growth_data = {
            'joins_by_day': {},
            'leaves_by_day': {},
            'net_growth': [],
            'retention_rate': 0,
            'invitation_stats': {},
            'growth_velocity': 0,
            'projected_growth': {},
            'member_milestones': [],
            'seasonal_patterns': {},
            'demographic_changes': {}
        }
        
        async for entry in guild.audit_logs(limit=None):
            if entry.action == discord.AuditLogAction.member_join:
                day = entry.created_at.date()
                growth_data['joins_by_day'][day] = growth_data['joins_by_day'].get(day, 0) + 1
            elif entry.action == discord.AuditLogAction.member_remove:
                day = entry.created_at.date()
                growth_data['leaves_by_day'][day] = growth_data['leaves_by_day'].get(day, 0) + 1
        
        for day in sorted(set(growth_data['joins_by_day'].keys()) | set(growth_data['leaves_by_day'].keys())):
            joins = growth_data['joins_by_day'].get(day, 0)
            leaves = growth_data['leaves_by_day'].get(day, 0)
            net = joins - leaves
            growth_data['net_growth'].append((day, net))
            
        if len(growth_data['net_growth']) >= 2:
            recent_growth = sum(net for _, net in growth_data['net_growth'][-7:])
            growth_data['growth_velocity'] = recent_growth / 7
            
        return growth_data

class ContentAnalysisButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Content Analysis", emoji="📝")

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer()
        content_stats = await self.analyze_content(interaction.guild)
        embed = self.create_content_embed(content_stats)
        await interaction.followup.send(embed=embed)

    async def analyze_content(self, guild):
        content_stats = {
            'message_types': {
                'text': 0,
                'images': 0,
                'videos': 0,
                'links': 0,
                'embeds': 0,
                'files': 0
            },
            'popular_topics': {},
            'link_domains': {},
            'file_types': {},
            'emoji_usage': {},
            'avg_message_length': 0,
            'content_engagement': {},
            'peak_posting_times': {},
            'thread_activity': {},
            'quality_metrics': {
                'readability': 0,
                'engagement_rate': 0,
                'uniqueness': 0
            }
        }

        total_messages = 0
        total_length = 0
        emoji_pattern = re.compile(r'[\U0001F300-\U0001F9FF]|[\u2600-\u26FF\u2700-\u27BF]')
        
        for channel in guild.text_channels:
            try:
                async for message in channel.history(limit=1000):
                    total_messages += 1
                    total_length += len(message.content)
                    
                    if message.attachments:
                        for attachment in message.attachments:
                            file_ext = attachment.filename.split('.')[-1].lower()
                            content_stats['file_types'][file_ext] = content_stats['file_types'].get(file_ext, 0) + 1
                            
                            if attachment.content_type:
                                if 'image' in attachment.content_type:
                                    content_stats['message_types']['images'] += 1
                                elif 'video' in attachment.content_type:
                                    content_stats['message_types']['videos'] += 1
                                else:
                                    content_stats['message_types']['files'] += 1
                    
                    elif message.embeds:
                        content_stats['message_types']['embeds'] += 1
                        
                    urls = re.findall(r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[^\s]*', message.content)
                    if urls:
                        content_stats['message_types']['links'] += 1
                        for url in urls:
                            domain = url.split('/')[2]
                            content_stats['link_domains'][domain] = content_stats['link_domains'].get(domain, 0) + 1
                    else:
                        content_stats['message_types']['text'] += 1

                    emojis = emoji_pattern.findall(message.content)
                    for emoji_char in emojis:
                        content_stats['emoji_usage'][emoji_char] = content_stats['emoji_usage'].get(emoji_char, 0) + 1

                    words = message.content.lower().split()
                    for word in words:
                        if len(word) > 3 and not word.startswith(('http', 'https')):
                            content_stats['popular_topics'][word] = content_stats['popular_topics'].get(word, 0) + 1

                    engagement_score = len(message.reactions) + (1 if message.reference else 0)
                    content_stats['content_engagement'][message.id] = engagement_score

                    hour = message.created_at.hour
                    content_stats['peak_posting_times'][hour] = content_stats['peak_posting_times'].get(hour, 0) + 1

                    if hasattr(message, 'thread') and message.thread is not None:
                        thread_id = str(message.thread.id)
                        content_stats['thread_activity'][thread_id] = content_stats['thread_activity'].get(thread_id, 0) + 1

            except discord.Forbidden:
                continue

        if total_messages > 0:
            content_stats['avg_message_length'] = total_length / total_messages
            content_stats['quality_metrics']['engagement_rate'] = sum(content_stats['content_engagement'].values()) / total_messages
            content_stats['quality_metrics']['uniqueness'] = len(content_stats['popular_topics']) / total_messages * 100

        content_stats['popular_topics'] = dict(sorted(content_stats['popular_topics'].items(), key=lambda x: x[1], reverse=True)[:10])
        content_stats['emoji_usage'] = dict(sorted(content_stats['emoji_usage'].items(), key=lambda x: x[1], reverse=True)[:10])
        content_stats['link_domains'] = dict(sorted(content_stats['link_domains'].items(), key=lambda x: x[1], reverse=True)[:10])

        return content_stats

    def create_content_embed(self, stats):
        embed = discord.Embed(
            title="Content Analysis Dashboard",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )

        msg_types = stats['message_types']
        embed.add_field(
            name="Message Types",
            value="\n".join(f"{k.title()}: {v}" for k, v in msg_types.items()),
            inline=True
        )

        if stats['emoji_usage']:
            top_emojis = "\n".join(f"{emoji}: {count}" for emoji, count in list(stats['emoji_usage'].items())[:5])
            embed.add_field(name="Top Emojis", value=top_emojis or "None", inline=True)

        if stats['popular_topics']:
            topics = "\n".join(f"{topic}: {count}" for topic, count in list(stats['popular_topics'].items())[:5])
            embed.add_field(name="Trending Topics", value=topics or "None", inline=True)

        embed.add_field(
            name="Content Metrics",
            value=f"Avg Message Length: {stats['avg_message_length']:.1f}\n"
                  f"Engagement Rate: {stats['quality_metrics']['engagement_rate']:.2f}\n"
                  f"Content Uniqueness: {stats['quality_metrics']['uniqueness']:.1f}%",
            inline=False
        )

        peak_times = sorted(stats['peak_posting_times'].items(), key=lambda x: x[1], reverse=True)[:3]
        peak_times_str = "\n".join(f"{hour:02d}:00: {count} messages" for hour, count in peak_times)
        embed.add_field(name="Peak Activity Hours", value=peak_times_str or "No data", inline=True)

        return embed



class AnalyticsDatabase:
    def __init__(self):
        self.db_path = 'data/analytics.db'
        self.db = None
        self.queue = []
        self.flush_interval = 5  
        self.queue_lock = asyncio.Lock()
        self.batch_size = 1000  
        self.last_flush = time.time()
        asyncio.create_task(self.initialize_db())
        asyncio.create_task(self.flush_queue_loop())

    async def initialize_db(self):
        self.db = await aiosqlite.connect(self.db_path)
        await self.db.execute('PRAGMA journal_mode=WAL')  
        await self.db.execute('PRAGMA synchronous=NORMAL')  
        await self.db.execute('PRAGMA cache_size=-64000')  
        await self.setup_database()

    async def setup_database(self):
        await self.db.execute('''
            CREATE TABLE IF NOT EXISTS user_activity (
                user_id INTEGER,
                guild_id INTEGER,
                message_count INTEGER DEFAULT 0,
                voice_minutes INTEGER DEFAULT 0,
                reaction_count INTEGER DEFAULT 0,
                command_count INTEGER DEFAULT 0,
                timestamp DATETIME,
                PRIMARY KEY (user_id, guild_id, timestamp)
            ) WITHOUT ROWID
        ''')
        
        await self.db.execute('''
            CREATE TABLE IF NOT EXISTS guild_metrics (
                guild_id INTEGER,
                member_count INTEGER DEFAULT 0,
                active_members INTEGER DEFAULT 0,
                message_count INTEGER DEFAULT 0,
                voice_users INTEGER DEFAULT 0,
                timestamp DATETIME,
                PRIMARY KEY (guild_id, timestamp)
            ) WITHOUT ROWID
        ''')
        
        await self.db.execute('CREATE INDEX IF NOT EXISTS idx_timestamp ON user_activity(timestamp)')
        await self.db.commit()

    async def flush_queue_loop(self):
        while True:
            try:
                await asyncio.sleep(self.flush_interval)
                await self.flush_queue()
            except Exception as e:
                print(f"Error in flush queue loop: {e}")

    async def flush_queue(self):
        async with self.queue_lock:
            if not self.queue:
                return
            
            current_queue = self.queue
            self.queue = []

        try:
           
            for i in range(0, len(current_queue), self.batch_size):
                batch = current_queue[i:i + self.batch_size]
                await self.db.executemany('''
                    INSERT INTO user_activity 
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                    ON CONFLICT(user_id, guild_id, timestamp) 
                    DO UPDATE SET 
                        message_count = message_count + ?,
                        voice_minutes = voice_minutes + ?,
                        reaction_count = reaction_count + ?,
                        command_count = command_count + ?
                ''', batch)
                
                await self.db.commit()

        except Exception as e:
            print(f"Error during queue flush: {e}")
            
            async with self.queue_lock:
                self.queue.extend(current_queue)

    async def update_user_activity(self, user_id, guild_id, activity_type, amount):
        timestamp = datetime.now().strftime('%Y-%m-%d %H:00:00')
        
        values = (
            user_id, guild_id,
            amount if activity_type == 'message' else 0,
            amount if activity_type == 'voice' else 0,
            amount if activity_type == 'reaction' else 0,
            amount if activity_type == 'command' else 0,
            timestamp,
            amount if activity_type == 'message' else 0,
            amount if activity_type == 'voice' else 0,
            amount if activity_type == 'reaction' else 0,
            amount if activity_type == 'command' else 0
        )
        
        async with self.queue_lock:
            self.queue.append(values)
            
            if len(self.queue) >= self.batch_size:
                asyncio.create_task(self.flush_queue())

    async def close(self):
        try:
            if self.queue:
                await self.flush_queue()
            if self.db:
                await self.db.execute('PRAGMA optimize')  
                await self.db.close()
        except Exception as e:
            print(f"Error during database close: {e}")


class Analytics(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.voice_times = {}
        self.analytics_db = AnalyticsDatabase()

    def cog_unload(self):
        asyncio.create_task(self.analytics_db.close())

    @commands.Cog.listener()
    async def on_message(self, message):
        if not message.guild or message.author.bot:
            return
        if message.guild:  
            return           
        await self.analytics_db.update_user_activity(
            message.author.id,
            message.guild.id,
            'message',
            1
        )

    @commands.Cog.listener()
    async def on_reaction_add(self, reaction, user):
        if not reaction.message.guild or user.bot:
            return
        await self.analytics_db.update_user_activity(
            user.id,
            reaction.message.guild.id,
            'reaction',
            1
        )

    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if member.bot:
            return
            
        if not before.channel and after.channel:
            self.voice_times[member.id] = time.time()
        elif before.channel and not after.channel and member.id in self.voice_times:
            duration = time.time() - self.voice_times[member.id]
            minutes = int(duration / 60)
            await self.analytics_db.update_user_activity(
                member.id,
                member.guild.id,
                'voice',
                minutes
            )
            del self.voice_times[member.id]

class ServerAnalyticsView(discord.ui.View):
    def __init__(self, cog, ctx):
        super().__init__(timeout=300)
        self.cog = cog
        self.ctx = ctx
        self.setup_buttons()

    def setup_buttons(self):
        self.add_item(ActivityHeatmapButton())
        self.add_item(MemberRetentionButton())
        self.add_item(RoleDistributionButton())
        self.add_item(ChannelHealthButton())
        self.add_item(CommunityGrowthButton())

class RoleDistributionButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Role Distribution", emoji="👥")
    
    async def callback(self, interaction: discord.Interaction):
        distribution = await self.get_role_distribution(interaction.guild)
        embed = self.create_distribution_embed(distribution)
        await interaction.response.edit_message(embed=embed)

    async def get_role_distribution(self, guild):
        distribution = {
            'roles': {},
            'hierarchy': [],
            'member_counts': {},
            'permissions': {},
            'color_groups': {},
            'hoisted_roles': [],
            'mentionable_roles': [],
            'bot_roles': [],
            'integration_roles': []
        }
        
        for role in guild.roles:
            distribution['roles'][role.id] = {
                'name': role.name,
                'color': role.color.value,
                'members': len(role.members),
                'position': role.position,
                'permissions': role.permissions.value,
                'hoisted': role.hoist,
                'mentionable': role.mentionable
            }
            
            distribution['hierarchy'].append(role.id)
            distribution['member_counts'][role.id] = len(role.members)
            
            if role.hoist:
                distribution['hoisted_roles'].append(role.id)
            if role.mentionable:
                distribution['mentionable_roles'].append(role.id)
                
        return distribution

class MemberRetentionButton(BaseAnalyticsButton):
    def __init__(self):
        super().__init__(label="Member Retention", emoji="📊")
    
    async def callback(self, interaction: discord.Interaction):
        retention_data = await self.analyze_retention(interaction.guild)
        embed = self.create_retention_embed(retention_data)
        await interaction.response.edit_message(embed=embed)

    async def analyze_retention(self, guild):
        now = datetime.now()
        retention_data = {
            'join_cohorts': {},
            'leave_rates': {},
            'retention_rates': {},
            'engagement_correlation': {},
            'risk_factors': {},
            'successful_retention': [],
            'churn_patterns': {},
            'retention_by_role': {},
            'activity_impact': {}
        }
        
        for member in guild.members:
            join_month = member.joined_at.strftime('%Y-%m')
            retention_data['join_cohorts'][join_month] = retention_data['join_cohorts'].get(join_month, 0) + 1
            
        async for entry in guild.audit_logs(action=discord.AuditLogAction.member_remove, limit=None):
            if entry.target:
                leave_month = entry.created_at.strftime('%Y-%m')
                retention_data['leave_rates'][leave_month] = retention_data['leave_rates'].get(leave_month, 0) + 1
                
        return retention_data

    def create_retention_embed(self, data):
        embed = discord.Embed(
            title="Member Retention Analysis",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        for cohort, count in data['join_cohorts'].items():
            leaves = data['leave_rates'].get(cohort, 0)
            retention_rate = ((count - leaves) / count * 100) if count > 0 else 0
            embed.add_field(
                name=f"Cohort {cohort}",
                value=f"Retention: {retention_rate:.1f}%\nJoins: {count}\nLeaves: {leaves}",
                inline=True
            )
            
        return embed

class ServerAdsHub(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.ads_db = {}  
        self.allowed_users = {}  
        self.channel_categories = {}  
        self.bump_cooldown = 12 * 3600  
        self.analytics = {}  
        self.cleanup_expired_ads.start()
        self.save_analytics.start()
        self.load_data()

    class ServerAdView(discord.ui.View):
        def __init__(self, cog, ad_data, server_id):
            super().__init__(timeout=None)
            self.cog = cog
            self.server_id = server_id
           
            self.add_item(discord.ui.Button(
                label="Join Server",
                url=ad_data["invite_link"],
                style=discord.ButtonStyle.url
            ))
           
            self.add_item(discord.ui.Button(
                label=f"👥 {ad_data['member_count']} Members",
                disabled=True,
                style=discord.ButtonStyle.gray
            ))

        async def interaction_check(self, interaction: discord.Interaction) -> bool:
            self.cog.analytics[self.server_id]["clicks"] += 1
            return True

    @commands.group(invoke_without_command=True)
    async def serverad(self, ctx):
        
        embed = discord.Embed(
            title="📢 Server Advertisement Hub",
            description=(
                "**Available Commands:**\n"
                "`!serverad post` - Create a new advertisement\n"
                "`!serverad bump` - Bump your server ad\n"
                "`!serverad preview` - Preview your current ad\n"
                "`!serverad stats` - View advertisement analytics\n"
                "`!serverad allow` - Grant ad permissions\n"
                "`!serverad template` - Get ad template"
            ),
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed)


    @tasks.loop(minutes=1)
    async def cleanup_expired_ads(self):
        try:
         
            if isinstance(self.channel_categories, list):
                channel_dict = {str(channel.id): {"name": channel.name} for channel in self.channel_categories}
            else:
                channel_dict = self.channel_categories

            for channel_id, data in channel_dict.items():
                channel = self.bot.get_channel(int(channel_id))
                if channel:
                    async for message in channel.history(limit=100):
                       
                        if (datetime.utcnow() - message.created_at).total_seconds() > 86400:  
                            try:
                                await message.delete()
                            except discord.errors.NotFound:
                                pass  
                            except discord.errors.Forbidden:
                                pass  
        except Exception as e:
            print(f"Error in cleanup_expired_ads: {str(e)}")



    async def check_ad_permission(self, ctx):
        
        if ctx.channel.id not in self.allowed_users:
            raise commands.CheckFailure("This channel is not authorized for advertisements")
        if ctx.author.id not in self.allowed_users[ctx.channel.id]:
            raise commands.CheckFailure("You don't have permission to post ads here")
        return True

    @serverad.command()
    async def preview(self, ctx):
        
        await self.check_ad_permission(ctx)
        if ctx.author.id not in self.ads_db:
            return await ctx.send("❌ You don't have an active advertisement!")
        await self.send_ad(ctx, self.ads_db[ctx.author.id]["server_data"], ctx.guild.id)

    @serverad.command()
    async def rename_channel(self, ctx, *, new_name: str):
        
        await self.check_ad_permission(ctx)
        if len(new_name) > 100:
            return await ctx.send("❌ Channel name too long! Max 100 characters.")
        await ctx.channel.edit(name=new_name)
        await ctx.send(f"✅ Channel renamed to: {new_name}")


    async def send_ad(self, ctx, server_data, server_id):
        
        embed = discord.Embed(
            title=f"🌟 {server_data['name']}",
            description=server_data['description'],
            color=discord.Color.gold()
        )
        embed.add_field(name="✨ Features", value=server_data['features'], inline=False)
        embed.add_field(name="🏷️ Tags", value=" • ".join(server_data['tags']), inline=False)
        
        stats = self.analytics[server_id]
        embed.set_footer(text=f"📊 Bumps: {stats['bumps']} | 👀 Views: {stats['views']}")
        
        view = self.ServerAdView(self, server_data, server_id)
        message = await ctx.send(embed=embed, view=view)
        self.analytics[server_id]["views"] += 1
        
        return message


    @serverad.command()
    async def post(self, ctx):
        
        await self.check_ad_permission(ctx)
        
        questions = {
            "name": "What's your server name? (60 chars max)",
            "description": "Describe your server: (200 chars max)",
            "features": "List 3-5 key features (one per line)",
            "tags": "Add some tags (comma-separated, max 5)",
            "invite": "Permanent server invite link:"
        }
        
        answers = {}
        for key, question in questions.items():
            embed = discord.Embed(
                title="📝 Advertisement Creation",
                description=question,
                color=discord.Color.blue()
            )
            await ctx.send(embed=embed)
            
            try:
                msg = await self.bot.wait_for(
                    'message',
                    timeout=300,
                    check=lambda m: m.author == ctx.author and m.channel == ctx.channel
                )
                answers[key] = msg.content
            except asyncio.TimeoutError:
                return await ctx.send("⏰ Setup timed out!")

        try:
            
            invite = await self.bot.fetch_invite(answers["invite"])
            
            features = "\n• ".join(
                [f for f in answers["features"].split("\n") if f.strip()][:5]
            )
            
            server_data = {
                "name": answers["name"][:60],
                "description": answers["description"][:200],
                "features": f"• {features}",
                "tags": [tag.strip() for tag in answers["tags"].split(",")[:5]],
                "invite_link": answers["invite"],
                "member_count": invite.approximate_member_count,
                "created_at": datetime.now().timestamp()
            }
            
            self.ads_db[ctx.author.id] = {
                "last_bump": datetime.now().timestamp(),
                "server_data": server_data
            }
            
            if invite.guild.id not in self.analytics:
                self.analytics[invite.guild.id] = {"views": 0, "clicks": 0, "bumps": 0}
            
            await self.send_ad(ctx, server_data, invite.guild.id)
            
        except discord.NotFound:
            await ctx.send("❌ Invalid invite link! Make sure it's permanent.")


    @serverad.command(name="allow")
    @commands.has_permissions(administrator=True)
    async def ads_allow(self, ctx, user: discord.Member, channel: discord.TextChannel, duration: int = 7):
        
        await channel.set_permissions(ctx.guild.default_role, send_messages=False)
        await channel.set_permissions(user, send_messages=True)
        
        if channel.id not in self.allowed_users:
            self.allowed_users[channel.id] = set()
        self.allowed_users[channel.id].add(user.id)
        
        channel_embed = discord.Embed(
            title="✅ Advertisement Channel Access Granted",
            description=f"{user.mention} has been granted access to post advertisements",
            color=discord.Color.green()
        )
        channel_embed.add_field(
            name="Available Commands",
            value=(
                "`!serverad post` - Create your advertisement\n"
                "`!serverad bump` - Bump your ad\n"
                "`!serverad preview` - Preview your ad\n"
                "`!serverad stats` - View analytics"
            ),
            inline=False
        )
        channel_embed.set_footer(text="© ZygnalBot | TheHolyOneZ")
        await ctx.send(embed=channel_embed)
        
        user_embed = discord.Embed(
            title="🎉 Advertisement Access Granted!",
            description=f"You now have access to post in {channel.mention}",
            color=discord.Color.blue()
        )
        user_embed.add_field(
            name="Getting Started",
            value=(
                "1. Use `!serverad template` to see the format\n"
                "2. Create your ad with `!serverad post`\n"
                "3. Bump every 12 hours with `!serverad bump`\n"
                "4. Track performance with `!serverad stats`"
            ),
            inline=False
        )
        user_embed.set_footer(text="© ZygnalBot | TheHolyOneZ")
        try:
            await user.send(embed=user_embed)
        except discord.Forbidden:
            pass



    @tasks.loop(minutes=30)
    async def save_analytics(self):
        
        analytics_data = {
            "timestamp": datetime.now().timestamp(),
            "total_ads": len(self.ads_db),
            "channel_stats": self.channel_categories,
            "server_stats": self.analytics
        }
        
        with open('data/ad_analytics.json', 'w') as f:
            json.dump(analytics_data, f, indent=4)

    def load_data(self):
        
        try:
            with open('data/ad_analytics.json', 'r') as f:
                self.analytics = json.load(f)
            with open('data/channel_categories.json', 'r') as f:
                self.channel_categories = json.load(f)
        except FileNotFoundError:
            pass

    def save_data(self):
        
        with open('data/ad_analytics.json', 'w') as f:
            json.dump(self.analytics, f)
        with open('data/channel_categories.json', 'w') as f:
            json.dump(self.channel_categories, f)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def setup_ad_category(self, ctx):
        
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        try:
            
            await ctx.send("What would you like to name the advertisement category?")
            category_msg = await self.bot.wait_for('message', timeout=30.0, check=check)
            
            category = await ctx.guild.create_category(category_msg.content)
            
            await ctx.send("How many advertisement channels would you like to create? (1-10)")
            num_msg = await self.bot.wait_for('message', timeout=30.0, check=check)
            num_channels = min(max(1, int(num_msg.content)), 10)

            channels = []
            for i in range(num_channels):
                await ctx.send(f"Name for channel #{i+1}?")
                name_msg = await self.bot.wait_for('message', timeout=30.0, check=check)
                
                overwrites = {
                    ctx.guild.default_role: discord.PermissionOverwrite(send_messages=False),
                    ctx.guild.me: discord.PermissionOverwrite(send_messages=True)
                }

                channel = await category.create_text_channel(
                    name=name_msg.content,
                    overwrites=overwrites
                )
                
                self.channel_categories[channel.id] = {
                    "name": name_msg.content,
                    "ads": {},
                    "position": i,
                    "created_at": datetime.now().timestamp()
                }
                
                channels.append(channel)

            for channel in channels:
                info_embed = discord.Embed(
                    title="📢 Advertisement Channel",
                    description=(
                        "**Channel Rules:**\n"
                        "1. Only authorized users can post ads\n"
                        "2. Ads are sorted by bump count\n"
                        "3. Bumps are limited to once every 12 hours\n"
                        "4. Inappropriate content will result in removal"
                    ),
                    color=discord.Color.gold()
                )
                await channel.send(embed=info_embed, pin=True)

            await ctx.send("✅ Advertisement category setup complete!")
            
        except asyncio.TimeoutError:
            await ctx.send("❌ Setup timed out!")
        except ValueError:
            await ctx.send("❌ Please enter a valid number!")

    @serverad.command()
    @commands.cooldown(1, 43200, commands.BucketType.user)
    async def bump(self, ctx):
        
        await self.check_ad_permission(ctx)
        
        if ctx.author.id not in self.ads_db:
            return await ctx.send("❌ You don't have an active advertisement!")
            
        channel_id = ctx.channel.id
        if channel_id not in self.channel_categories:
            return await ctx.send("❌ This channel is not properly configured!")

        self.ads_db[ctx.author.id]["last_bump"] = datetime.now().timestamp()
        server_data = self.ads_db[ctx.author.id]["server_data"]
        
        try:
           
            invite = await self.bot.fetch_invite(server_data["invite_link"])
            server_data["member_count"] = invite.approximate_member_count
            
            self.analytics[invite.guild.id]["bumps"] += 1
            
            async for message in ctx.channel.history():
                if message.author == self.bot.user and message.embeds:
                    embed = message.embeds[0]
                    if embed.title.endswith(server_data['name']):
                        await message.delete()
                        if message.id in self.channel_categories[channel_id]["ads"]:
                            del self.channel_categories[channel_id]["ads"][message.id]
            
            new_message = await self.send_ad(ctx, server_data, invite.guild.id)
            self.channel_categories[channel_id]["ads"][new_message.id] = self.analytics[invite.guild.id]["bumps"]
            
            await self.sort_ads_by_bumps(ctx.channel)
            
            await ctx.send("🚀 Server bumped and ads reordered!", delete_after=5)
            
        except discord.NotFound:
            await ctx.send("❌ Invalid invite link! Please update your ad.")

    async def sort_ads_by_bumps(self, channel):
        
        if channel.id not in self.channel_categories:
            return
            
        ads = []
        async for message in channel.history(limit=100):
            if message.id in self.channel_categories[channel.id]["ads"]:
                ads.append({
                    "message": message,
                    "bumps": self.channel_categories[channel.id]["ads"][message.id]
                })
        
        sorted_ads = sorted(ads, key=lambda x: x["bumps"], reverse=True)
        
        for ad in sorted_ads:
            message = ad["message"]
            if message.embeds:
                embed = message.embeds[0]
                await message.delete()
                new_msg = await channel.send(embed=embed)
                self.channel_categories[channel.id]["ads"][new_msg.id] = ad["bumps"]

    @serverad.command()
    async def template(self, ctx):
        
        template = discord.Embed(
            title="📝 Advertisement Template",
            description=(
                "**Server Name**\n"
                "Your server name here\n\n"
                "**Description**\n"
                "Describe your server (200 chars max)\n\n"
                "**Key Features**\n"
                "• Feature 1\n"
                "• Feature 2\n"
                "• Feature 3\n\n"
                "**Tags**\n"
                "gaming, community, fun"
            ),
            color=discord.Color.blue()
        )
        await ctx.send(embed=template)

    @serverad.command()
    async def edit(self, ctx):
        
        await self.check_ad_permission(ctx)
        
        if ctx.author.id not in self.ads_db:
            return await ctx.send("❌ You don't have an active advertisement!")
        
        current_ad = self.ads_db[ctx.author.id]["server_data"]
        
        edit_options = {
            "1": "Server Name",
            "2": "Description",
            "3": "Features",
            "4": "Tags",
            "5": "Invite Link"
        }
        
        embed = discord.Embed(
            title="📝 Edit Advertisement",
            description="\n".join(f"{k}. {v}" for k, v in edit_options.items()),
            color=discord.Color.blue()
        )
        embed.set_footer(text="Type the number of what you want to edit, or 'cancel' to exit")
        
        await ctx.send(embed=embed)
        
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
        
        try:
            choice = await self.bot.wait_for('message', timeout=30.0, check=check)
            if choice.content.lower() == 'cancel':
                return await ctx.send("✅ Edit cancelled!")
                
            if choice.content not in edit_options:
                return await ctx.send("❌ Invalid option!")
                
            await ctx.send(f"Please provide the new {edit_options[choice.content]}:")
            new_content = await self.bot.wait_for('message', timeout=60.0, check=check)
            
            if choice.content == "1":
                current_ad["name"] = new_content.content[:60]
            elif choice.content == "2":
                current_ad["description"] = new_content.content[:200]
            elif choice.content == "3":
                features = "\n• ".join([f for f in new_content.content.split("\n") if f.strip()][:5])
                current_ad["features"] = f"• {features}"
            elif choice.content == "4":
                current_ad["tags"] = [tag.strip() for tag in new_content.content.split(",")[:5]]
            elif choice.content == "5":
                if new_content.content.lower() != "skip":
                    try:
                        invite = await self.bot.fetch_invite(new_content.content)
                        current_ad["invite_link"] = new_content.content
                        current_ad["member_count"] = invite.approximate_member_count
                    except discord.NotFound:
                        return await ctx.send("❌ Invalid invite link!")
                else:
                    current_ad["invite_link"] = "Not provided"
                    current_ad["member_count"] = 0
            
            self.ads_db[ctx.author.id]["server_data"] = current_ad
            
            async for message in ctx.channel.history():
                if message.author == self.bot.user and message.embeds:
                    embed = message.embeds[0]
                    if embed.title.endswith(current_ad['name']):
                        await message.delete()
            
            await self.send_ad(ctx, current_ad, ctx.guild.id)
            await ctx.send("✅ Advertisement updated successfully!")
            
        except asyncio.TimeoutError:
            await ctx.send("❌ Edit timed out!")

    def cog_unload(self):
        
        self.cleanup_expired_ads.cancel()
        self.save_analytics.cancel()
        self.save_data()
    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_settings(self, ctx):
        
        embed = discord.Embed(
            title="⚙️ Advertisement Settings",
            description=(
                "**Available Settings:**\n"
                "1️⃣ Bump Cooldown\n"
                "2️⃣ Channel Categories\n"
                "3️⃣ Auto-cleanup Duration\n"
                "4️⃣ Permission Management\n"
                "5️⃣ Analytics Settings"
            ),
            color=discord.Color.blue()
        )
        settings_msg = await ctx.send(embed=embed)
        
        reactions = ['1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣']
        for reaction in reactions:
            await settings_msg.add_reaction(reaction)

        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in reactions

        try:
            reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)
            await self.handle_settings_menu(ctx, str(reaction.emoji))
        except asyncio.TimeoutError:
            await ctx.send("Settings menu timed out!", delete_after=5)

    async def handle_settings_menu(self, ctx, choice):
        
        if choice == '1️⃣':
            await self.set_bump_cooldown(ctx)
        elif choice == '2️⃣':
            await self.manage_categories(ctx)
        elif choice == '3️⃣':
            await self.set_cleanup_duration(ctx)
        elif choice == '4️⃣':
            await self.manage_permissions(ctx)
        elif choice == '5️⃣':
            await self.configure_analytics(ctx)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_stats(self, ctx):
        
        total_ads = len(self.ads_db)
        total_bumps = sum(stats["bumps"] for stats in self.analytics.values())
        total_views = sum(stats["views"] for stats in self.analytics.values())
        total_clicks = sum(stats["clicks"] for stats in self.analytics.values())

        stats_embed = discord.Embed(
            title="📊 Advertisement System Statistics",
            color=discord.Color.gold()
        )
        stats_embed.add_field(name="Total Advertisements", value=total_ads)
        stats_embed.add_field(name="Total Bumps", value=total_bumps)
        stats_embed.add_field(name="Total Views", value=total_views)
        stats_embed.add_field(name="Total Clicks", value=total_clicks)
        stats_embed.add_field(
            name="Conversion Rate", 
            value=f"{(total_clicks/total_views*100 if total_views else 0):.2f}%"
        )

        await ctx.send(embed=stats_embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_cleanup(self, ctx):
        
        before = len(self.ads_db)
        current_time = datetime.now().timestamp()
        
        expired = [user_id for user_id, data in self.ads_db.items()
                  if current_time - data["last_bump"] > 86400 * 7]
                  
        for user_id in expired:
            del self.ads_db[user_id]
        
        after = len(self.ads_db)
        removed = before - after
        
        await ctx.send(f"✅ Removed {removed} expired advertisements!")




    @commands.command()
    @commands.has_permissions(administrator=True)
    async def reset_analytics(self, ctx):
        
        confirm = await ctx.send("⚠️ Are you sure you want to reset all analytics? This cannot be undone!")
        
        await confirm.add_reaction('✅')
        await confirm.add_reaction('❌')
        
        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in ['✅', '❌']
            
        try:
            reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)
            if str(reaction.emoji) == '✅':
                self.analytics = {}
                await ctx.send("✅ Analytics have been reset!")
            else:
                await ctx.send("❌ Analytics reset cancelled!")
        except asyncio.TimeoutError:
            await ctx.send("❌ Reset timed out!")
    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_blacklist(self, ctx, user: discord.Member):
        
        if user.id in self.ads_db:
            del self.ads_db[user.id]
            
        for channel_id in self.allowed_users:
            self.allowed_users[channel_id].discard(user.id)
            
        for channel_id, data in self.channel_categories.items():
            channel = ctx.guild.get_channel(channel_id)
            if channel:
                async for message in channel.history():
                    if message.embeds and message.id in data["ads"]:
                        embed = message.embeds[0]
                        if str(user.id) in embed.footer.text:
                            await message.delete()
                            del data["ads"][message.id]

        await ctx.send(f"✅ {user.mention} has been blacklisted from posting advertisements")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def move_ad(self, ctx, message_id: int, channel: discord.TextChannel):
        
        if channel.id not in self.channel_categories:
            return await ctx.send("❌ Target channel is not an advertisement channel!")

        try:
            message = await ctx.channel.fetch_message(message_id)
            if not message.embeds:
                return await ctx.send("❌ Message is not an advertisement!")

            new_message = await channel.send(embed=message.embeds[0])
            self.channel_categories[channel.id]["ads"][new_message.id] = \
                self.channel_categories[ctx.channel.id]["ads"].get(message.id, 0)
            
            await message.delete()
            if message.id in self.channel_categories[ctx.channel.id]["ads"]:
                del self.channel_categories[ctx.channel.id]["ads"][message.id]

            await self.sort_ads_by_bumps(channel)
            await ctx.send("✅ Advertisement moved successfully!")

        except discord.NotFound:
            await ctx.send("❌ Message not found!")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_audit(self, ctx):
        
        audit_report = {
            "broken_ads": 0,
            "fixed_ads": 0,
            "invalid_channels": 0,
            "total_checked": 0
        }

        for channel_id in list(self.channel_categories.keys()):
            channel = self.bot.get_channel(channel_id)
            if not channel:
                del self.channel_categories[channel_id]
                audit_report["invalid_channels"] += 1
                continue

            ads = self.channel_categories[channel_id]["ads"]
            for message_id in list(ads.keys()):
                try:
                    await channel.fetch_message(message_id)
                    audit_report["total_checked"] += 1
                except discord.NotFound:
                    del ads[message_id]
                    audit_report["broken_ads"] += 1
                    audit_report["fixed_ads"] += 1

        embed = discord.Embed(
            title="📋 Advertisement Audit Report",
            color=discord.Color.blue()
        )
        for key, value in audit_report.items():
            embed.add_field(name=key.replace("_", " ").title(), value=value)
        
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_channel_stats(self, ctx, channel: discord.TextChannel = None):
        
        if not channel:
            channel = ctx.channel
            
        if channel.id not in self.channel_categories:
            return await ctx.send("❌ This is not an advertisement channel!")

        data = self.channel_categories[channel.id]
        total_ads = len(data["ads"])
        total_bumps = sum(data["ads"].values())
        
        embed = discord.Embed(
            title=f"📊 Channel Statistics: {channel.name}",
            color=discord.Color.blue()
        )
        embed.add_field(name="Total Advertisements", value=total_ads)
        embed.add_field(name="Total Bumps", value=total_bumps)
        embed.add_field(name="Average Bumps", value=f"{total_bumps/total_ads:.2f}" if total_ads else 0)
        
        sorted_ads = sorted(data["ads"].items(), key=lambda x: x[1], reverse=True)[:5]
        if sorted_ads:
            top_ads = "\n".join(f"ID: {msg_id} - {bumps} bumps" for msg_id, bumps in sorted_ads)
            embed.add_field(name="Top Advertisements", value=top_ads, inline=False)
        
        await ctx.send(embed=embed)
    async def handle_ad_error(self, ctx, error):
        
        error_messages = {
            commands.CommandOnCooldown: f"⏰ Please wait {error.retry_after:.2f}s before bumping again!",
            commands.MissingPermissions: "❌ You don't have permission to use this command!",
            commands.CheckFailure: str(error),
            discord.Forbidden: "❌ Bot lacks required permissions!"
        }

        error_msg = error_messages.get(type(error), "❌ An unexpected error occurred!")
        await ctx.send(error_msg, delete_after=10)

    @commands.Cog.listener()
    async def on_guild_channel_delete(self, channel):
        
        if channel.id in self.channel_categories:
            del self.channel_categories[channel.id]
        if channel.id in self.allowed_users:
            del self.allowed_users[channel.id]
        self.save_data()

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_restore(self, ctx, user: discord.Member):
        
        backup_file = f'ad_backups/{user.id}.json'
        try:
            with open(backup_file, 'r') as f:
                ad_data = json.load(f)
            
            self.ads_db[user.id] = ad_data
            await self.send_ad(ctx, ad_data["server_data"], ad_data["server_data"]["guild_id"])
            await ctx.send(f"✅ Restored advertisement for {user.mention}")
            
        except FileNotFoundError:
            await ctx.send("❌ No backup found for this user!")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ad_template_create(self, ctx):
        
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        try:
            await ctx.send("Please provide the template name:")
            name = (await self.bot.wait_for('message', timeout=30.0, check=check)).content

            await ctx.send("Please provide the template content:")
            content = (await self.bot.wait_for('message', timeout=60.0, check=check)).content

            template_data = {
                "name": name,
                "content": content,
                "created_by": ctx.author.id,
                "created_at": datetime.now().timestamp()
            }

            with open(f'ad_templates/{name}.json', 'w') as f:
                json.dump(template_data, f)

            await ctx.send(f"✅ Template '{name}' created successfully!")

        except asyncio.TimeoutError:
            await ctx.send("❌ Template creation timed out!")

    @commands.command()
    async def ad_search(self, ctx, *, query: str):
        
        matches = []
        for user_id, data in self.ads_db.items():
            server_data = data["server_data"]
            if (query.lower() in server_data["name"].lower() or 
                any(query.lower() in tag.lower() for tag in server_data["tags"])):
                matches.append(server_data)

        if not matches:
            return await ctx.send("❌ No advertisements found matching your search!")

        pages = []
        for i in range(0, len(matches), 5):
            embed = discord.Embed(
                title="🔍 Search Results",
                color=discord.Color.blue()
            )
            for server_data in matches[i:i+5]:
                embed.add_field(
                    name=server_data["name"],
                    value=f"Tags: {', '.join(server_data['tags'])}",
                    inline=False
                )
            pages.append(embed)

        await self.send_paginated_results(ctx, pages)

    async def send_paginated_results(self, ctx, pages):
        
        if not pages:
            return

        current_page = 0
        message = await ctx.send(embed=pages[0])

        if len(pages) > 1:
            await message.add_reaction('⬅️')
            await message.add_reaction('➡️')

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ['⬅️', '➡️']

            while True:
                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)

                    if str(reaction.emoji) == '➡️':
                        current_page = (current_page + 1) % len(pages)
                    elif str(reaction.emoji) == '⬅️':
                        current_page = (current_page - 1) % len(pages)

                    await message.edit(embed=pages[current_page])
                    await message.remove_reaction(reaction, user)

                except asyncio.TimeoutError:
                    break

            await message.clear_reactions()



class CustomVerification(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.verification_settings = {}
        self.role_assignments = {}

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def verify_user_setup(self, ctx):
        
        
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        embed = discord.Embed(
            title="🔧 Custom Verification Setup",
            description="Let's configure your verification system!",
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed)

        await ctx.send("Please mention or enter the ID of the role to **remove** during verification:")
        try:
            msg = await self.bot.wait_for('message', check=check, timeout=60)
            role1_id = int(msg.content.strip('<@&>'))
            role1 = ctx.guild.get_role(role1_id)
            if not role1:
                return await ctx.send("❌ Invalid role! Setup cancelled.")
        except ValueError:
            return await ctx.send("❌ Please provide a valid role ID or mention!")

        await ctx.send("Please mention or enter the ID of the role to **add** during verification:")
        try:
            msg = await self.bot.wait_for('message', check=check, timeout=60)
            role2_id = int(msg.content.strip('<@&>'))
            role2 = ctx.guild.get_role(role2_id)
            if not role2:
                return await ctx.send("❌ Invalid role! Setup cancelled.")
        except ValueError:
            return await ctx.send("❌ Please provide a valid role ID or mention!")

        example_msg = (
            "Enter your custom verification message. You can use:\n"
            "• {user} - Mentions the verified user\n"
            "• {role_removed} - Shows removed role\n"
            "• {role_added} - Shows added role\n\n"
            "Example: Welcome {user}! Removed {role_removed} and added {role_added}"
        )
        await ctx.send(example_msg)
        msg = await self.bot.wait_for('message', check=check, timeout=60)
        success_msg = msg.content

        self.verification_settings[ctx.guild.id] = {
            'remove_role': role1_id,
            'add_role': role2_id,
            'success_msg': success_msg
        }

        setup_complete = await ctx.send(
            embed=discord.Embed(
                title="✅ Setup Complete!",
                description=f"""
                **Remove Role:** {role1.mention}
                **Add Role:** {role2.mention}
                **Success Message Preview:**
                {success_msg.format(user='@User', role_removed=role1.name, role_added=role2.name)}
                
                Use `!verify_user @member` to verify members!
                """,
                color=discord.Color.green()
            )
        )
        await asyncio.sleep(5)
        await setup_complete.delete()

    @commands.command()
    @commands.has_permissions(manage_roles=True)
    async def verify_user(self, ctx, member: discord.Member):
        
        
        if ctx.guild.id not in self.verification_settings:
            return await ctx.send("⚠️ Please setup the verification system first using `!verify_user_setup`")

        settings = self.verification_settings[ctx.guild.id]
        
        remove_role = ctx.guild.get_role(settings['remove_role'])
        add_role = ctx.guild.get_role(settings['add_role'])

        if not remove_role or not add_role:
            return await ctx.send("❌ One or more roles are invalid! Please run setup again.")

        try:
            await member.remove_roles(remove_role)
            await member.add_roles(add_role)
            
            success_msg = settings['success_msg'].format(
                user=member.mention,
                role_removed=remove_role.name,
                role_added=add_role.name
            )
            
            verify_msg = await ctx.send(
                embed=discord.Embed(
                    title="✅ Verification Successful",
                    description=success_msg,
                    color=discord.Color.green()
                ).set_footer(text=f"Verified by {ctx.author}")
            )
            await asyncio.sleep(5)
            await verify_msg.delete()
            
        except discord.Forbidden:
            await ctx.send("❌ I don't have permission to manage these roles!")
        except Exception as e:
            await ctx.send(f"❌ An error occurred: {str(e)}")
    
    @commands.command()
    async def verify_setup_help(self, ctx):
        embed = discord.Embed(
            title="📚 Verification Setup Guide",
            description="A complete guide to setting up the verification system!",
            color=discord.Color.blue()
        )

        embed.add_field(
            name="Setup Steps",
            value="""
            **Step 1:** Remove Role
            When prompted for "role to remove", this is the role members have before verification
            Example: Unverified Role, New Member Role
            
            **Step 2:** Add Role
            When prompted for "role to add", this is the role members get after verification
            Example: Verified Role, Member Role
            """,
            inline=False
        )

        embed.add_field(
            name="Message Placeholders",
            value="""
            Use these in your custom message:
            • `{user}` - Mentions the verified user
            • `{role_removed}` - Shows the removed role name
            • `{role_added}` - Shows the added role name
            """,
            inline=False
        )

        embed.add_field(
            name="Message Examples",
            value="""
            **Example 1:**
            ```Welcome {user}! You're now verified! Removed {role_removed} and added {role_added}```

            **Example 2:**
            ```{user} has been verified! ✅
            Removed: {role_removed}
            Added: {role_added}```
            
            **Example 3:**
            ```Verification complete for {user}! You now have the {role_added} role!```
            """,
            inline=False
        )

        embed.set_footer(text="Use !verify_user_setup to begin the setup process!")
        await ctx.send(embed=embed)



class WebhookDeleteModal(discord.ui.Modal, title="Delete Webhook"):
    def __init__(self, interaction: discord.Interaction):
        super().__init__()
        self.bot = interaction.client
        
    webhook_id = discord.ui.TextInput(
        label="Webhook ID",
        placeholder="Enter webhook ID to delete...",
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            webhook = await interaction.client.fetch_webhook(int(self.webhook_id.value))
            await webhook.delete()
            embed = discord.Embed(title="✅ Webhook Deleted", color=discord.Color.green())
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(title="❌ Error", description=str(e), color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)


class WebhookTestModal(discord.ui.Modal, title="Test Webhook"):
    webhook_id = discord.ui.TextInput(
        label="Webhook ID",
        placeholder="Enter webhook ID to test...",
        required=True
    )
    test_message = discord.ui.TextInput(
        label="Test Message",
        placeholder="Enter a test message...",
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            webhook = await interaction.client.fetch_webhook(int(self.webhook_id.value))
            await webhook.send(self.test_message.value)
            embed = discord.Embed(title="✅ Test Message Sent", color=discord.Color.green())
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(title="❌ Error", description=str(e), color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)

class WebhookConfigView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        
    @discord.ui.button(label="Avatar", style=ButtonStyle.grey)
    async def avatar_config(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = WebhookAvatarModal()
        await interaction.response.send_modal(modal)
        
    @discord.ui.button(label="Name", style=ButtonStyle.grey)
    async def name_config(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = WebhookNameModal()
        await interaction.response.send_modal(modal)
        
    @discord.ui.button(label="Channel", style=ButtonStyle.grey)
    async def channel_config(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = WebhookChannelModal()
        await interaction.response.send_modal(modal)

class WebhookAvatarModal(discord.ui.Modal, title="Change Webhook Avatar"):
    webhook_id = discord.ui.TextInput(
        label="Webhook ID",
        placeholder="Enter webhook ID...",
        required=True
    )
    avatar_url = discord.ui.TextInput(
        label="New Avatar URL",
        placeholder="Enter new avatar URL...",
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
           
            response = requests.get(self.avatar_url.value)
            img = Image.open(io.BytesIO(response.content))
            
            img = img.resize((128, 128))
            
            img_byte_arr = io.BytesIO()
            img.save(img_byte_arr, format='PNG')
            img_byte_arr = img_byte_arr.getvalue()
            
            webhook = await interaction.client.fetch_webhook(int(self.webhook_id.value))
            await webhook.edit(avatar=img_byte_arr)
            
            embed = discord.Embed(title="✅ Avatar Updated", color=discord.Color.green())
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(title="❌ Error", description=str(e), color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)

class WebhookNameModal(discord.ui.Modal, title="Change Webhook Name"):
    webhook_id = discord.ui.TextInput(
        label="Webhook ID",
        placeholder="Enter webhook ID...",
        required=True
    )
    new_name = discord.ui.TextInput(
        label="New Name",
        placeholder="Enter new webhook name...",
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            webhook = await interaction.client.fetch_webhook(int(self.webhook_id.value))
            await webhook.edit(name=self.new_name.value)
            embed = discord.Embed(title="✅ Name Updated", color=discord.Color.green())
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(title="❌ Error", description=str(e), color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)


class WebhookChannelModal(discord.ui.Modal, title="Change Webhook Channel"):
    webhook_id = discord.ui.TextInput(
        label="Webhook ID",
        placeholder="Enter webhook ID...",
        required=True
    )
    channel_id = discord.ui.TextInput(
        label="New Channel ID",
        placeholder="Enter new channel ID...",
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            webhook = await interaction.client.fetch_webhook(int(self.webhook_id.value))
            channel = interaction.guild.get_channel(int(self.channel_id.value))
            await webhook.edit(channel=channel)
            embed = discord.Embed(title="✅ Channel Updated", color=discord.Color.green())
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(title="❌ Error", description=str(e), color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)


class WebhookManager(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
    @commands.command()
    @commands.has_permissions(administrator=True)
    async def webhook(self, ctx):
        webhooks = await ctx.guild.webhooks()
        active_webhooks = len(webhooks)
        last_webhook = webhooks[-1].created_at.strftime("%Y-%m-%d %H:%M:%S") if webhooks else "Never"

        embed = discord.Embed(
            title="🔗 Webhook Management Dashboard",
            description="Manage all your webhook configurations from one place",
            color=discord.Color.blue()
        )
        embed.add_field(name="📊 Current Status", value=f"Active Webhooks: {active_webhooks}\nLast Created: {last_webhook}", inline=False)
        embed.add_field(name="🔧 Options", value="Configure your webhook settings using the buttons below", inline=False)
        embed.set_footer(text=f"Opened by {ctx.author} | Server: {ctx.guild.name}")
        
        view = WebhookView()
        await ctx.send(embed=embed, view=view)

class WebhookView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        
    @discord.ui.button(label="Create", style=ButtonStyle.green)
    async def create_webhook(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = WebhookCreateModal()
        await interaction.response.send_modal(modal)
        
    @discord.ui.button(label="Configure", style=ButtonStyle.blurple)
    async def configure_webhook(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="⚙️ Webhook Configuration",
            description="Select what you want to configure:",
            color=discord.Color.gold()
        )
        config_view = WebhookConfigView()
        await interaction.response.send_message(embed=embed, view=config_view, ephemeral=True)

    @discord.ui.button(label="List", style=ButtonStyle.grey)
    async def list_webhooks(self, interaction: discord.Interaction, button: discord.ui.Button):
        webhooks = await interaction.guild.webhooks()
        embed = discord.Embed(title="📋 Active Webhooks", color=discord.Color.blue())
        for webhook in webhooks:
            embed.add_field(
                name=f"ID: {webhook.id}",
                value=f"Name: {webhook.name}\nChannel: {webhook.channel.mention}\nCreated: {webhook.created_at.strftime('%Y-%m-%d')}",
                inline=False
            )
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Delete", style=ButtonStyle.red)
    async def delete_webhook(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = WebhookDeleteModal(interaction)
        await interaction.response.send_modal(modal)


    @discord.ui.button(label="Test", style=ButtonStyle.blurple)
    async def test_webhook(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = WebhookTestModal()
        await interaction.response.send_modal(modal)

class WebhookCreateModal(discord.ui.Modal, title="Create New Webhook"):
    name = discord.ui.TextInput(
        label="Webhook Name",
        placeholder="Enter webhook name...",
        required=True
    )
    
    channel = discord.ui.TextInput(
        label="Channel ID",
        placeholder="Enter channel ID...",
        required=True
    )
    
    avatar_url = discord.ui.TextInput(
        label="Avatar URL (Optional)",
        placeholder="Enter avatar URL...",
        required=False
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            channel = interaction.guild.get_channel(int(self.channel.value))
            webhook = await channel.create_webhook(
                name=self.name.value,
                avatar=self.avatar_url.value if self.avatar_url.value else None
            )
            
            embed = discord.Embed(
                title="✅ Webhook Created Successfully",
                description=f"Webhook URL: {webhook.url}\nChannel: {channel.mention}",
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            embed = discord.Embed(
                title="❌ Error Creating Webhook",
                description=str(e),
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)


class ProfileSetupView(discord.ui.View):
    def __init__(self, cog, ctx):
        super().__init__(timeout=300)
        self.cog = cog
        self.ctx = ctx

    @discord.ui.button(label="Set Bio", style=discord.ButtonStyle.primary, emoji="📝", row=0)
    async def bio_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Please enter your bio (max 1000 characters):", ephemeral=True)
        
        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel
            
        try:
            bio_msg = await self.cog.bot.wait_for('message', check=check, timeout=300)
            if len(bio_msg.content) > 1000:
                await interaction.followup.send("❌ Bio too long! Max 1000 characters.", ephemeral=True)
                return
                
            if interaction.user.id not in self.cog.profiles:
                self.cog.profiles[interaction.user.id] = self.cog.default_profile()
            
            self.cog.profiles[interaction.user.id]['bio'] = bio_msg.content
            self.cog.profiles[interaction.user.id]['last_updated'] = datetime.now().isoformat()
            await bio_msg.delete()
            await interaction.followup.send("✅ Bio updated successfully!", ephemeral=True)
            
            await self.update_preview(interaction)
            
        except asyncio.TimeoutError:
            await interaction.followup.send("❌ Setup timed out!", ephemeral=True)

    @discord.ui.button(label="Set Banner", style=discord.ButtonStyle.primary, emoji="🎨", row=0)
    async def banner_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Please enter a banner image URL:", ephemeral=True)
        
        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel
            
        try:
            banner_msg = await self.cog.bot.wait_for('message', check=check, timeout=300)
            if interaction.user.id not in self.cog.profiles:
                self.cog.profiles[interaction.user.id] = self.cog.default_profile()
            
            self.cog.profiles[interaction.user.id]['banner'] = banner_msg.content
            await banner_msg.delete()
            await interaction.followup.send("✅ Banner updated successfully!", ephemeral=True)
            await self.update_preview(interaction)
            
        except asyncio.TimeoutError:
            await interaction.followup.send("❌ Setup timed out!", ephemeral=True)

    @discord.ui.button(label="Set Social Links", style=discord.ButtonStyle.primary, emoji="🔗", row=1)
    async def socials_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message(
            "Enter your social media links in this format:\n"
            "platform1: link1\n"
            "platform2: link2\n"
            "Example:\n"
            "twitter: https://twitter.com/username\n"
            "github: https://github.com/username",
            ephemeral=True
        )
        
        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel
            
        try:
            socials_msg = await self.cog.bot.wait_for('message', check=check, timeout=300)
            if interaction.user.id not in self.cog.profiles:
                self.cog.profiles[interaction.user.id] = self.cog.default_profile()
            
            socials = {}
            for line in socials_msg.content.split('\n'):
                if ':' in line:
                    platform, link = line.split(':', 1)
                    socials[platform.strip().lower()] = link.strip()
            
            self.cog.profiles[interaction.user.id]['socials'] = socials
            await socials_msg.delete()
            await interaction.followup.send("✅ Social links updated successfully!", ephemeral=True)
            await self.update_preview(interaction)
            
        except asyncio.TimeoutError:
            await interaction.followup.send("❌ Setup timed out!", ephemeral=True)

    @discord.ui.button(label="Set Badges", style=discord.ButtonStyle.primary, emoji="🏆", row=1)
    async def badges_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        available_badges = "🎮 Gamer\n🎨 Artist\n📚 Bookworm\n💻 Developer\n🎵 Musician"
        await interaction.response.send_message(
            f"Available badges:\n{available_badges}\nEnter the badges you want (separated by spaces):",
            ephemeral=True
        )
        
        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel
            
        try:
            badges_msg = await self.cog.bot.wait_for('message', check=check, timeout=300)
            if interaction.user.id not in self.cog.profiles:
                self.cog.profiles[interaction.user.id] = self.cog.default_profile()
            
            self.cog.profiles[interaction.user.id]['badges'] = badges_msg.content.split()
            await badges_msg.delete()
            await interaction.followup.send("✅ Badges updated successfully!", ephemeral=True)
            await self.update_preview(interaction)
            
        except asyncio.TimeoutError:
            await interaction.followup.send("❌ Setup timed out!", ephemeral=True)

    async def update_preview(self, interaction):
        profile = self.cog.profiles[interaction.user.id]
        embed = self.cog.create_profile_embed(interaction.user, profile)
        await interaction.message.edit(embed=embed)

class ProfileSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.profiles = {}

    def default_profile(self):
        return {
            'bio': 'No bio set',
            'banner': None,
            'badges': [],
            'socials': {},
            'created_at': datetime.now().isoformat(),
            'last_updated': datetime.now().isoformat(),
            'profile_views': 0
        }

    def create_profile_embed(self, user, profile):
        embed = discord.Embed(
            title=f"{user.name}'s Profile",
            description=profile['bio'],
            color=user.color,
            timestamp=datetime.now()
        )
        
        if profile.get('banner'):
            embed.set_image(url=profile['banner'])
        
        embed.set_thumbnail(url=user.avatar.url)
        
        if profile['badges']:
            embed.add_field(name="🏆 Badges", value=' '.join(profile['badges']), inline=False)
        
        if profile['socials']:
            social_text = '\n'.join([f"{platform}: {link}" for platform, link in profile['socials'].items()])
            embed.add_field(name="🔗 Social Links", value=social_text, inline=False)
        
        created_at = datetime.fromisoformat(profile['created_at'])
        last_updated = datetime.fromisoformat(profile['last_updated'])
        
        embed.add_field(name="📊 Stats", value=f"Profile Views: {profile['profile_views']}\nCreated: {created_at.strftime('%Y-%m-%d')}\nLast Updated: {last_updated.strftime('%Y-%m-%d')}", inline=False)
        
        embed.set_footer(text=f"{user.name}#{user.discriminator}", icon_url=user.avatar.url)
        return embed

    @commands.group(invoke_without_command=True)
    async def p(self, ctx, user: discord.Member = None):
        user = user or ctx.author
        if user.id not in self.profiles:
            if user == ctx.author:
                embed = discord.Embed(
                    title="Profile Not Found",
                    description="You haven't set up your profile yet! Use `!p setup` to get started.",
                    color=discord.Color.orange()
                )
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(
                    title="Profile Not Found",
                    description="This user hasn't set up their profile yet!",
                    color=discord.Color.orange()
                )
                await ctx.send(embed=embed)
            return
        
        profile = self.profiles[user.id]
        profile['profile_views'] += 1
        embed = self.create_profile_embed(user, profile)
        await ctx.send(embed=embed)

    @p.command(name="setup")
    async def profile_setup(self, ctx):
        embed = discord.Embed(
            title="✨ Profile Setup",
            description="Customize your profile using the buttons below!",
            color=discord.Color.blue()
        )
        view = ProfileSetupView(self, ctx)
        await ctx.send(embed=embed, view=view)



class TempChannelButton(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=None)
        self.cog = cog

    @discord.ui.button(label="Create Temporary Channel", style=discord.ButtonStyle.green, emoji="📝", custom_id="create_temp_channel")
    async def create_temp_channel(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = CreateChannelModal(self.cog)
        await interaction.response.send_modal(modal)

class CreateChannelModal(discord.ui.Modal, title="Create Temporary Channel"):
    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    channel_name = discord.ui.TextInput(
        label="Channel Name",
        placeholder="Enter channel name...",
        min_length=1,
        max_length=32
    )
    
    duration = discord.ui.TextInput(
        label="Duration (in hours)",
        placeholder="Enter duration (1-72 hours)",
        min_length=1,
        max_length=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            duration = int(self.duration.value)
            if not 1 <= duration <= 72:
                raise ValueError
        except ValueError:
            return await interaction.response.send_message("Duration must be between 1 and 72 hours!", ephemeral=True)

        overwrites = {
            interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.guild.me: discord.PermissionOverwrite(read_messages=True),
            interaction.user: discord.PermissionOverwrite(
                read_messages=True,
                send_messages=True,
                manage_messages=True,
                embed_links=True,
                attach_files=True,
                add_reactions=True,
                manage_channels=True
            )
        }

        channel = await interaction.guild.create_text_channel(
            name=self.channel_name.value,
            category=interaction.channel.category,
            overwrites=overwrites
        )

        invite_view = InviteUserView(channel)
        await channel.send(
            f"Private channel created by {interaction.user.mention}\n"
            f"This channel will be deleted in {duration} hours.\n"
            "Use the button below to invite users:",
            view=invite_view
        )

        self.cog.temp_channels[channel.id] = {
            'delete_at': datetime.now() + timedelta(hours=duration),
            'owner': interaction.user.id,
            'members': [interaction.user.id]
        }

        await interaction.response.send_message(f"Private channel {channel.mention} created!", ephemeral=True)

class InviteUserView(discord.ui.View):
    def __init__(self, channel):
        super().__init__(timeout=None)
        self.channel = channel

    @discord.ui.button(label="Invite User", style=discord.ButtonStyle.blurple, emoji="➕", custom_id="invite_user")
    async def invite_user(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.channel.permissions_for(interaction.user).read_messages:
            return await interaction.response.send_message("You must be a member of this channel to invite others!", ephemeral=True)

        modal = InviteUserModal(self.channel)
        await interaction.response.send_modal(modal)

class InviteUserModal(discord.ui.Modal, title="Invite User"):
    def __init__(self, channel):
        super().__init__()
        self.channel = channel

    user_id = discord.ui.TextInput(
        label="User ID or @mention",
        placeholder="Enter user ID or @mention to invite...",
        min_length=2,
        max_length=50
    )

    async def on_submit(self, interaction: discord.Interaction):
        user_input = self.user_id.value.strip()
        try:
            if user_input.startswith('<@') and user_input.endswith('>'):
                user_id = int(user_input[2:-1].replace('!', ''))
            else:
                user_id = int(user_input)
            
            user = await interaction.guild.fetch_member(user_id)
            await self.channel.set_permissions(user,
                read_messages=True,
                send_messages=True,
                embed_links=True,
                attach_files=True,
                add_reactions=True
            )
            await self.channel.send(f"{user.mention} has been invited to the channel by {interaction.user.mention}")
            await interaction.response.send_message(f"Successfully added {user.mention} to the channel!", ephemeral=True)
        except:
            await interaction.response.send_message("Invalid user ID/mention or user not found!", ephemeral=True)

class TempChannels(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.temp_channels = {}
        self.cleanup_task.start()

    def cog_unload(self):
        self.cleanup_task.cancel()

    @tasks.loop(minutes=5)
    async def cleanup_task(self):
        now = datetime.now()
        channels_to_delete = []
        
        for channel_id, data in self.temp_channels.items():
            if now >= data['delete_at']:
                channels_to_delete.append(channel_id)

        for channel_id in channels_to_delete:
            channel = self.bot.get_channel(channel_id)
            if channel:
                await channel.delete()
            del self.temp_channels[channel_id]

    @commands.has_permissions(administrator=True)
    @commands.command()
    async def setuptempchannel(self, ctx):
        
        view = TempChannelButton(self)
        await ctx.send("Click the button below to create a temporary private channel:", view=view)


class JSONEmbeds(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def jsonembed(self, ctx, *, json_data: str = None):
        
        try:
            
            if ctx.message.attachments:
                json_file = ctx.message.attachments[0]
                if not json_file.filename.endswith('.json'):
                    return await ctx.send("📄 File must be a .json file!")
                json_content = await json_file.read()
                data = json.loads(json_content)
            
            elif json_data:
                if json_data.startswith("```") and json_data.endswith("```"):
                    json_data = json_data[3:-3]
                if json_data.startswith("`") and json_data.endswith("`"):
                    json_data = json_data[1:-1]
                data = json.loads(json_data)
            
            else:
                return await ctx.send("Please provide JSON data or attach a .json file!")

            if "embeds" in data:
                embed_data = data["embeds"][0]  
            else:
                embed_data = data  
            
            embed = discord.Embed.from_dict(embed_data)
            content = data.get("content", None)
            await ctx.send(content=content, embed=embed)
            await ctx.message.add_reaction("✅")

        except json.JSONDecodeError:
            await ctx.send("❌ Invalid JSON format. Please check your JSON syntax.")
        except KeyError as e:
            await ctx.send(f"❌ Missing required field in JSON: {str(e)}")
        except Exception as e:
            await ctx.send(f"❌ An error occurred: {str(e)}")

    @commands.command()
    async def embedhelp(self, ctx):
        
        embed = discord.Embed(
            title="JSON Embed Help",
            description="Create embeds using JSON data. You can either:\n• Attach a .json file\n• Paste JSON directly",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="Command Usage",
            value="```!jsonembed <json data>\n# OR\n!jsonembed + attach .json file```",
            inline=False
        )
        
        embed.add_field(
            name="Discohook/Webhook Format",
            value="""```json
{
    "content": null,
    "embeds": [{
        "title": "Title",
        "description": "Description",
        "color": 16629952
    }]
}```""",
            inline=False
        )
        
        embed.add_field(
            name="Direct Format",
            value="""```json
{
    "title": "Title",
    "description": "Description",
    "color": 16629952
}```""",
            inline=False
        )
        
        embed.add_field(
            name="Complex Format",
            value="""```json
{
    "embeds": [{
        "title": "Title",
        "description": "Description",
        "color": 16629952,
        "fields": [
            {"name": "Field", "value": "Value"}
        ],
        "image": {"url": "image_url"}
    }]
}```""",
            inline=False
        )
        
        await ctx.send(embed=embed)


class AFKSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        if not hasattr(bot, 'afk_users'):
            bot.afk_users = {} 
        
    def format_time_elapsed(self, timestamp):
        time_diff = datetime.now() - timestamp
        return humanize.naturaltime(time_diff)

    def create_afk_embed(self, user, message, is_removal=False):
        if is_removal:
            afk_data = self.bot.afk_users.get(user.id)
            if afk_data:
                time_elapsed = self.format_time_elapsed(afk_data[0])
                description = f"Welcome back {user.name}! 👋\nYou were AFK for: {time_elapsed}"
            else:
                description = f"Welcome back {user.name}! 👋"
                
            embed = discord.Embed(
                title="🔰 AFK Status Removed",
                description=description,
                color=discord.Color.green()
            )
        else:
            embed = discord.Embed(
                title="🌙 AFK Status Set",
                description=f"**{user.name}** is now AFK\n📝 **Reason:** {message}\n🔔 **Active in all channels**",
                color=user.color or discord.Color.blue()
            )
            embed.set_footer(text="💡 Use !afk again to remove your AFK status")
        
        embed.set_thumbnail(url=user.display_avatar.url)
        return embed


    def create_mention_embed(self, user, timestamp, message, color):
        embed = discord.Embed(
            title="⚠️ User is AFK",
            description=f"**{user.name}** is currently away",
            color=color or discord.Color.orange()
        )
        embed.add_field(name="💭 Reason", value=message, inline=False)
        embed.add_field(
            name="⏰ Away Since", 
            value=self.format_time_elapsed(timestamp),
            inline=False
        )
        embed.set_thumbnail(url=user.display_avatar.url)
        embed.set_footer(text="They will see your message when they return")
        return embed

    @commands.command(name="afk", description="Set your AFK status with an optional message")
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def afk(self, ctx, *, message=None):
        user_id = ctx.author.id
        bot_roles = ctx.guild.me.roles
        highest_role = max(bot_roles, key=lambda r: r.position)


        if user_id in self.bot.afk_users:
            timestamp = self.bot.afk_users[user_id][0]
            del self.bot.afk_users[user_id]
            embed = self.create_afk_embed(ctx.author, None, is_removal=True)
            try:
              
                if ctx.author.display_name.startswith("[AFK] "):
                    await ctx.author.edit(nick=ctx.author.display_name[6:])
            except discord.Forbidden:
                pass
            await ctx.send(embed=embed)
            return



        message = message or "No reason provided"
        if len(message) > 100:
            message = message[:97] + "..."
        
        self.bot.afk_users[user_id] = (
            datetime.now(),
            message,
            ctx.author.color or discord.Color.blue(),
            ctx.guild.id
        )
        
        try:
        
            current_nick = ctx.author.display_name
            if not current_nick.startswith("[AFK] "):
                await ctx.author.edit(nick=f"[AFK] {current_nick}")
        except discord.Forbidden:
            pass

        embed = self.create_afk_embed(ctx.author, message)
        await ctx.send(embed=embed)

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
        if message.guild:  
            return               
        show_author_afk = False
        if message.author.id in self.bot.afk_users:
            if not message.content.lower().startswith(f"{self.bot.command_prefix}afk"):
                show_author_afk = True

        for mention in message.mentions:
            if mention.id in self.bot.afk_users:
                timestamp, afk_message, color, guild_id = self.bot.afk_users[mention.id]
                
                if guild_id != message.guild.id:
                    continue
                    
                embed = self.create_mention_embed(
                    mention,
                    timestamp,
                    afk_message,
                    color
                )
                await message.reply(embed=embed, mention_author=False)
        
        if show_author_afk:
            await self.afk.callback(self, await self.bot.get_context(message))


    @afk.error
    async def afk_error(self, ctx, error):
        if isinstance(error, commands.CommandOnCooldown):
            await ctx.send(f"⏰ Please wait {error.retry_after:.1f}s before using this command again.")




class EnhancedMinigames(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_games = {}
        self.scores = {}
        self.streaks = {}
        self.achievements = {}
        self.daily_challenges = {}
        self.tournament_matches = {}
        
        self.word_categories = {
            'animals': {
                'easy': ['cat', 'dog', 'bird', 'fish', 'lion'],
                'normal': ['elephant', 'giraffe', 'penguin', 'dolphin', 'kangaroo'],
                'hard': ['platypus', 'rhinoceros', 'hippopotamus', 'chameleon', 'orangutan']
            },
            'food': {
                'easy': ['pizza', 'pasta', 'bread', 'cake', 'rice'],
                'normal': ['spaghetti', 'hamburger', 'sandwich', 'pancake', 'chocolate'],
                'hard': ['ratatouille', 'bouillabaisse', 'wellington', 'tiramisu', 'bruschetta']
            },
            'countries': {
                'easy': ['spain', 'italy', 'china', 'india', 'egypt'],
                'normal': ['germany', 'france', 'japan', 'brazil', 'australia'],
                'hard': ['kazakhstan', 'azerbaijan', 'mauritius', 'zimbabwe', 'madagascar']
            }
        }

        self.trivia_categories = {
            'general': ['easy', 'normal', 'hard'],
            'science': ['easy', 'normal', 'hard'],
            'history': ['easy', 'normal', 'hard'],
            'geography': ['easy', 'normal', 'hard'],
            'entertainment': ['easy', 'normal', 'hard']
        }

        self.game_settings = {
            'rps': {'rounds': 3, 'special_moves': True},
            'memory': {'sizes': [4, 6, 8], 'time_limit': 180},
            'reaction': {'modes': ['classic', 'pattern', 'chain']},
            'trivia': {'questions_per_round': 5, 'time_per_question': 30}
        }

        self.trivia_questions = self.load_trivia_questions()
        self.game_stats = {
            'rps': {},
            'wordscramble': {},
            'memory': {},
            'hangman': {},
            'reaction': {},
            'aimtrainer': {},
            'trivia': {}
        }

    async def update_player_stats(self, user_id: int, game_type: str, won: bool = False, extra_data: dict = None):
        if user_id not in self.scores:
            self.scores[user_id] = {
                'total_games': 0,
                'total_wins': 0,
                'current_streak': 0,
                'best_streak': 0,
                'last_played': None,
                'games': {
                    'rps': {'played': 0, 'wins': 0, 'best_streak': 0, 'win_rate': 0},
                    'wordscramble': {'played': 0, 'wins': 0, 'best_time': float('inf'), 'words_solved': 0},
                    'memory': {'played': 0, 'wins': 0, 'best_time': float('inf'), 'perfect_matches': 0},
                    'hangman': {'played': 0, 'wins': 0, 'best_streak': 0, 'letters_guessed': 0},
                    'reaction': {'played': 0, 'wins': 0, 'best_time': float('inf'), 'avg_time': 0},
                    'aimtrainer': {'played': 0, 'wins': 0, 'best_accuracy': 0, 'total_hits': 0, 'best_streak': 0},
                    'trivia': {'played': 0, 'wins': 0, 'best_score': 0, 'correct_answers': 0}
                }
            }

        stats = self.scores[user_id]
        stats['total_games'] += 1
        stats['last_played'] = datetime.now().timestamp()
        
        if won:
            stats['total_wins'] += 1
            stats['current_streak'] += 1
            stats['best_streak'] = max(stats['best_streak'], stats['current_streak'])
            stats['games'][game_type]['wins'] += 1
        else:
            stats['current_streak'] = 0
        
        stats['games'][game_type]['played'] += 1
        stats['games'][game_type]['win_rate'] = (stats['games'][game_type]['wins'] / stats['games'][game_type]['played']) * 100

        if extra_data:
            game_stats = stats['games'][game_type]
            
            if game_type == 'aimtrainer':
                game_stats['best_accuracy'] = max(game_stats.get('best_accuracy', 0), extra_data.get('accuracy', 0))
                game_stats['total_hits'] = game_stats.get('total_hits', 0) + extra_data.get('hits', 0)
                game_stats['best_streak'] = max(game_stats.get('best_streak', 0), extra_data.get('streak', 0))
            
            elif game_type in ['reaction', 'memory', 'wordscramble']:
                if 'time' in extra_data:
                    game_stats['best_time'] = min(game_stats.get('best_time', float('inf')), extra_data['time'])
                    
                    times = game_stats.get('times', [])
                    times.append(extra_data['time'])
                    game_stats['avg_time'] = sum(times) / len(times)
                    game_stats['times'] = times[-10:]  
            
            elif game_type == 'trivia':
                game_stats['best_score'] = max(game_stats.get('best_score', 0), extra_data.get('score', 0))
                game_stats['correct_answers'] = game_stats.get('correct_answers', 0) + extra_data.get('correct', 0)

        await self.check_achievements(user_id, game_type, stats)



    def load_trivia_questions(self):
        
        return {
            'general': [
                {
                    'question': 'What is the capital of France?',
                    'answers': ['Paris', 'London', 'Berlin', 'Madrid'],
                    'correct': 0,
                    'difficulty': 'easy',
                    'points': 100
                },
                
            ],
            'science': [
                {
                    'question': 'What is the chemical symbol for gold?',
                    'answers': ['Au', 'Ag', 'Fe', 'Cu'],
                    'correct': 0,
                    'difficulty': 'easy',
                    'points': 100
                }
                
            ]
        }

    @commands.command(name='rps')
    async def rps(self, ctx, rounds: int = 3):
        
        embed = discord.Embed(
            title="🎮 Rock Paper Scissors",
            description=f"{ctx.author.mention} wants to play RPS!\nClick Join to play!",
            color=discord.Color.blue()
        )
        
        view = discord.ui.View(timeout=60)
        
        async def join_callback(interaction):
            if interaction.user == ctx.author:
                await interaction.response.send_message("You can't play against yourself!", ephemeral=True)
                return
                
            game_view = self.RPSView(ctx.author, interaction.user, rounds)
            await interaction.message.edit(
                embed=discord.Embed(
                    title="🎮 Rock Paper Scissors",
                    description=f"Game between {ctx.author.mention} and {interaction.user.mention}\n"
                            f"Best of {rounds}!\nMake your choice!",
                    color=discord.Color.blue()
                ),
                view=game_view
            )
        
        join = discord.ui.Button(label="Join Game", style=discord.ButtonStyle.green, emoji="🎮")
        join.callback = join_callback
        view.add_item(join)
        
        await ctx.send(embed=embed, view=view)

    @commands.command(name='memory')
    async def memory(self, ctx, size: int = 4):
        
        valid_sizes = [2, 4]
        if size not in valid_sizes:
            await ctx.send(f"Please choose a valid board size: {', '.join(map(str, valid_sizes))}!")
            return
            
        game_view = self.MemoryView(size)
        embed = discord.Embed(
            title="🎮 Memory Game",
            description=(
                f"Match pairs of emojis!\n"
                f"Board size: {size}x{size}\n\n"
                f"👉 Click the tiles to reveal emojis\n"
                f"🔄 Find matching pairs to keep them revealed\n"
                f"⭐ Complete the game as fast as you can!"
            ),
            color=discord.Color.blue()
        )
        
        await ctx.send(embed=embed, view=game_view)

    class HangmanView(discord.ui.View):
        def __init__(self, word: str, category: str, starter: discord.Member, party_players=None):
            super().__init__(timeout=180)
            self.word = word
            self.category = category
            self.guessed_letters = set()
            self.lives = 6
            self.starter = starter
            self.party_players = party_players or []
            self.current_player_index = 0
            self.message = None
            self.hangman_stages = [
                "```\n   ____\n  |    |\n  |\n  |\n  |\n _|_\n```",
                "```\n   ____\n  |    |\n  |    O\n  |\n  |\n _|_\n```",
                "```\n   ____\n  |    |\n  |    O\n  |    |\n  |\n _|_\n```",
                "```\n   ____\n  |    |\n  |    O\n  |   /|\n  |\n _|_\n```",
                "```\n   ____\n  |    |\n  |    O\n  |   /|\\\n  |\n _|_\n```",
                "```\n   ____\n  |    |\n  |    O\n  |   /|\\\n  |   /\n _|_\n```",
                "```\n   ____\n  |    |\n  |    O\n  |   /|\\\n  |   / \\\n _|_\n```"
            ]

        def get_word_display(self):
            return ' '.join(letter if letter in self.guessed_letters else '_' for letter in self.word)

        def create_game_embed(self):
            current_player = self.party_players[self.current_player_index] if self.party_players else self.starter
            
            embed = discord.Embed(
                title="🎯 Hangman Game",
                description=f"Category: {self.category.title()}\n\n"
                        f"{self.hangman_stages[6-self.lives]}\n\n"
                        f"Word: {self.get_word_display()}\n"
                        f"Lives: {'❤️' * self.lives}\n"
                        f"Guessed letters: {', '.join(sorted(self.guessed_letters))}\n\n"
                        f"Current turn: {current_player.mention}",
                color=discord.Color.blue()
            )
            return embed

        async def process_guess(self, message):
            if len(message.content) != 1 or not message.content.isalpha():
                return

            letter = message.content.lower()
            if letter in self.guessed_letters:
                return

            self.guessed_letters.add(letter)
            
            if letter not in self.word:
                self.lives -= 1
                if self.party_players:
                    self.current_player_index = (self.current_player_index + 1) % len(self.party_players)

            word_completed = all(letter in self.guessed_letters for letter in self.word)
            embed = self.create_game_embed()

            if word_completed:
                embed.description += f"\n\n🎉 You won! The word was: {self.word}"
                await self.message.edit(embed=embed)
                self.stop()
            elif self.lives <= 0:
                embed.description += f"\n\n💀 Game Over! The word was: {self.word}"
                await self.message.edit(embed=embed)
                self.stop()
            else:
                await self.message.edit(embed=embed)

    @commands.command(name='hangman')
    async def hangman(self, ctx, category: str = "random"):
        
        categories = {
            'animals': [
                'elephant', 'penguin', 'giraffe', 'dolphin', 'kangaroo', 'octopus', 'cheetah',
                'rhinoceros', 'hippopotamus', 'crocodile', 'butterfly', 'gorilla', 'panda',
                'tiger', 'zebra', 'koala', 'flamingo', 'jaguar', 'hedgehog', 'platypus',
                'chameleon', 'armadillo', 'orangutan', 'mongoose', 'salamander', 'jellyfish',
                'scorpion', 'hamster', 'peacock', 'pelican', 'albatross', 'anaconda', 'gazelle',
                'wolverine', 'meerkat', 'narwhal', 'pangolin', 'iguana', 'raccoon', 'walrus'
            ],
            'food': [
                'pizza', 'spaghetti', 'hamburger', 'chocolate', 'pancake', 'sandwich',
                'lasagna', 'burrito', 'croissant', 'cheesecake', 'quesadilla', 'meatballs',
                'ravioli', 'enchilada', 'dumplings', 'tiramisu', 'guacamole', 'carbonara',
                'ratatouille', 'macaroni', 'bruschetta', 'cannelloni', 'gnocchi', 'paella',
                'churros', 'fettuccine', 'gazpacho', 'hummus', 'risotto', 'tagliatelle',
                'tortellini', 'waffles', 'yogurt', 'zucchini', 'baklava', 'baguette',
                'calzone', 'empanada', 'falafel', 'nachos'
            ],
            'countries': [
                'germany', 'france', 'japan', 'brazil', 'australia', 'canada', 'spain',
                'portugal', 'switzerland', 'netherlands', 'argentina', 'madagascar', 'indonesia',
                'philippines', 'singapore', 'kazakhstan', 'zimbabwe', 'ethiopia', 'morocco',
                'bangladesh', 'azerbaijan', 'venezuela', 'guatemala', 'honduras', 'uruguay',
                'paraguay', 'cambodia', 'cameroon', 'tanzania', 'uganda', 'mozambique',
                'botswana', 'mauritius', 'montenegro', 'luxembourg', 'lithuania', 'slovenia',
                'slovakia', 'bulgaria', 'romania'
            ],
            'sports': [
                'football', 'basketball', 'tennis', 'volleyball', 'swimming', 'boxing',
                'skateboarding', 'gymnastics', 'snowboarding', 'waterpolo', 'badminton',
                'wrestling', 'taekwondo', 'cricket', 'baseball', 'handball', 'cycling',
                'surfing', 'climbing', 'karate', 'archery', 'fencing', 'rowing', 'sailing',
                'triathlon', 'marathon', 'parkour', 'snorkeling', 'canoeing', 'dodgeball',
                'hockey', 'lacrosse', 'rugby', 'polo', 'curling', 'javelin', 'judo',
                'kickboxing', 'bowling', 'squash'
            ]
        }

        
        if category == "random":
            category = random.choice(list(categories.keys()))
        elif category not in categories:
            await ctx.send(f"Available categories: {', '.join(categories.keys())}")
            return

        word = random.choice(categories[category]).lower()
        game_view = self.HangmanView(word, category, ctx.author)
        
        embed = game_view.create_game_embed()
        game_view.message = await ctx.send(embed=embed)

        def check(m):
            return (m.author == ctx.author or m.author in game_view.party_players) and m.channel == ctx.channel

        while not game_view.is_finished():
            try:
                message = await ctx.bot.wait_for('message', timeout=180.0, check=check)
                await game_view.process_guess(message)
            except asyncio.TimeoutError:
                await ctx.send("Game timed out!")
                break


    @commands.command(name='party')
    async def party(self, ctx):
        
        await self.start_party_session(ctx, [ctx.author])

    @commands.command(name='games')
    async def games(self, ctx):
        
        embed = EmbedBuilder(
            "🎮 Enhanced Minigames Collection",
            "Welcome to the ultimate gaming experience!"
        ).set_color(discord.Color.blue())

        games_list = [
            (f"🎲 Rock Paper Scissors {CMD_PREFIX}rps [rounds]", f"{CMD_PREFIX}rps [rounds]",
            "Enhanced RPS with animations, best of 3/5/7, and special moves!"),
            
            (f"🔤 Word Scramble {CMD_PREFIX}wordscramble [category] [difficulty]", f"{CMD_PREFIX}wordscramble [category] [difficulty]",
            "Categories: animals, food, countries\nDifficulties: easy, normal, hard\nFeatures hints and time bonuses!"),
            
            (f"👻 Hangman {CMD_PREFIX}hangman [category]", f"{CMD_PREFIX}hangman [category]",
            "Enhanced with themes, hints, and progressive difficulty!\nCategories: animals, food, countries and sports"),
            
            (f"🧩 Memory {CMD_PREFIX}memory [size]", f"{CMD_PREFIX}memory [size]",
            "Match pairs with different board sizes and themes\nCompete for fastest times!\nSizes: 2x2, 4x4"),
            
            (f"❓ Trivia {CMD_PREFIX}trivia [category] [difficulty]",f"{CMD_PREFIX}trivia [category] [difficulty]",
            "Multiple categories with scoring system and daily challenges!\n"
            "Categories: general, science, history, geography, entertainment, sports, technology, literature, music, movies\n"
            "Difficulties: easy, normal, hard"),
            
            (f"⚡ Reaction Test {CMD_PREFIX}reactiontest [mode]", f"{CMD_PREFIX}reactiontest [mode]",
            "Test reactions with various modes and global rankings!\nModes: classic, pattern, chain"),
            
            (f"🎯 Aim Trainer {CMD_PREFIX}aimtrainer", f"{CMD_PREFIX}aimtrainer",
            "New! Test your clicking speed and accuracy!"),
            
            (f"🎪 Party Mode {CMD_PREFIX}party", f"{CMD_PREFIX}party",
            "New! Play random minigames in succession with friends!"),
            
            (f"🔢 Number Game {CMD_PREFIX}numbergame <number> <channel>", f"{CMD_PREFIX}numbergame <number> <channel>",
            "Classic number guessing game with customizable range!"),
            
            (f"⭕ TicTacToe {CMD_PREFIX}tictactoe", f"{CMD_PREFIX}tictactoe",
            "Classic TicTacToe game against other players!"),
            
            (f"4️⃣ Connect Four {CMD_PREFIX}connect4", f"{CMD_PREFIX}connect4",
            "Strategic Connect Four game with animations!"),
            
            (f"🏆 Leaderboard {CMD_PREFIX}leaderboard [game_type]", f"{CMD_PREFIX}leaderboard [game_type]",
            "View global or game-specific leaderboards!"),
            
            (f"👤 Profile {CMD_PREFIX}profile [user]", f"{CMD_PREFIX}profile [user]",
            "View detailed player statistics and achievements!"),
            
            (f"📅 Daily Challenges {CMD_PREFIX}daily", f"{CMD_PREFIX}daily",
            "Complete daily challenges for bonus points!")
        ]


        for game, command, description in games_list:
            embed.add_field(
                name=f"{game}",
                value=f"Command: `{command}`\n{description}",
                inline=False
            )

        if ctx.author.id in self.scores:
            stats = self.scores[ctx.author.id]
            embed.add_field(
                name="🏆 Your Statistics",
                value=f"Games Played: {stats['total_games']}\n"
                    f"Wins: {stats['wins']}\n"
                    f"Current Streak: {self.streaks.get(ctx.author.id, 0)}\n"
                    f"Achievement Points: {self.achievements.get(ctx.author.id, 0)}",
                inline=False
            )

        await ctx.send(embed=embed.build())


    async def update_stats(self, user_id, game_type, won=False):
        if user_id not in self.scores:
            self.scores[user_id] = {
                'total_games': 0,
                'wins': 0,
                'game_specific': {}
            }
        
        self.scores[user_id]['total_games'] += 1
        if won:
            self.scores[user_id]['wins'] += 1
            self.streaks[user_id] = self.streaks.get(user_id, 0) + 1
        else:
            self.streaks[user_id] = 0

    async def create_game_channel(self, ctx, interaction, game_type):
        overwrites = {
            ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            ctx.author: discord.PermissionOverwrite(read_messages=True),
            interaction.user: discord.PermissionOverwrite(read_messages=True),
            ctx.guild.me: discord.PermissionOverwrite(read_messages=True, manage_channels=True)
        }
        
        channel = await ctx.guild.create_text_channel(
            f"{game_type}-{ctx.author.name}-{interaction.user.name}",
            overwrites=overwrites
        )

        async def cleanup_channel():
            await asyncio.sleep(600)  
            try:
                await channel.delete()
            except:
                pass

        self.bot.loop.create_task(cleanup_channel())
        return channel
    
    class RPSView(discord.ui.View):
        def __init__(self, player1, player2, rounds=3):
            super().__init__(timeout=None)
            self.player1 = player1
            self.player2 = player2
            self.p1_choice = None
            self.p2_choice = None
            self.p1_score = 0
            self.p2_score = 0
            self.round = 1
            self.max_rounds = rounds
            self.special_move_available = True
            self.setup_buttons()



        async def make_choice(self, interaction: discord.Interaction):
            if interaction.user not in [self.player1, self.player2]:
                return

            choice = int(interaction.data['custom_id'].split('_')[1])
            
            if interaction.user == self.player1:
                self.p1_choice = int(choice)  
            else:
                self.p2_choice = int(choice)

            if self.p1_choice is not None and self.p2_choice is not None:
                await self.resolve_round(interaction)
            else:
                await interaction.response.defer()

        async def make_choice(self, interaction: discord.Interaction):
            if interaction.user not in [self.player1, self.player2]:
                return

            choice_id = interaction.data['custom_id'].split('_')[1]
            
            if choice_id == 'special':
                choice = 'special'
            else:
                choice = int(choice_id)
            
            if interaction.user == self.player1:
                self.p1_choice = choice
            else:
                self.p2_choice = choice

            if self.p1_choice is not None and self.p2_choice is not None:
                await self.resolve_round(interaction)
            else:
                await interaction.response.defer()

        async def resolve_round(self, interaction: discord.Interaction, special_result=None):
            choices = ['Rock', 'Paper', 'Scissors', '✨ Special Move ✨']
            
            p1_choice_display = choices[3] if self.p1_choice == 'special' else choices[self.p1_choice]
            p2_choice_display = choices[3] if self.p2_choice == 'special' else choices[self.p2_choice]
            
            if self.p1_choice == 'special' and self.p2_choice == 'special':
                
                winner = random.choice([self.player1, self.player2, None])
            elif self.p1_choice == 'special':
                
                result = random.choices(['win', 'lose', 'draw'], weights=[0.5, 0.25, 0.25])[0]
                winner = self.player1 if result == 'win' else (self.player2 if result == 'lose' else None)
            elif self.p2_choice == 'special':
                
                result = random.choices(['win', 'lose', 'draw'], weights=[0.5, 0.25, 0.25])[0]
                winner = self.player2 if result == 'win' else (self.player1 if result == 'lose' else None)
            else:
              
                p1_num = int(self.p1_choice)
                p2_num = int(self.p2_choice)
                
                if p1_num == p2_num:
                    winner = None
                elif (p1_num - p2_num) % 3 == 1:
                    winner = self.player1
                else:
                    winner = self.player2

            if winner == self.player1:
                self.p1_score += 1
                result_message = "🎯 Perfect move!" if self.p1_choice == 'special' else "Victory!"
            elif winner == self.player2:
                self.p2_score += 1
                result_message = "🎯 Perfect move!" if self.p2_choice == 'special' else "Victory!"
            else:
                result_message = "It's a draw!"

            embed = discord.Embed(
                title=f"Round {self.round}/{self.max_rounds}",
                description=f"{self.player1.mention}: {p1_choice_display}\n"
                            f"{self.player2.mention}: {p2_choice_display}\n\n"
                            f"{result_message}\n"
                            f"Winner: {winner.mention if winner else 'Draw!'}\n"
                            f"Score: {self.p1_score} - {self.p2_score}",
                color=discord.Color.blue()
            )

            if self.p1_choice == 'special' or self.p2_choice == 'special':
                embed.add_field(
                    name="✨ Special Move Used!",
                    value="Special moves are now on cooldown.",
                    inline=False
                )

            self.round += 1
            self.p1_choice = None
            self.p2_choice = None

            if self.round > self.max_rounds or self.p1_score > self.max_rounds//2 or self.p2_score > self.max_rounds//2:
                final_winner = self.player1 if self.p1_score > self.p2_score else self.player2
                embed.add_field(
                    name="🏆 Game Over!",
                    value=f"Champion: {final_winner.mention}\n"
                        f"Final Score: {self.p1_score} - {self.p2_score}",
                    inline=False
                )
                await interaction.response.edit_message(embed=embed, view=None)
                self.stop()
            else:
                await interaction.response.edit_message(embed=embed, view=self)

        def setup_buttons(self):
            
            choices = [('🪨', 'Rock'), ('📄', 'Paper'), ('✂️', 'Scissors')]
            for i, (emoji, name) in enumerate(choices):
                button = discord.ui.Button(
                    emoji=emoji, 
                    label=name, 
                    custom_id=f'choice_{i}', 
                    row=0,
                    style=discord.ButtonStyle.primary
                )
                button.callback = self.make_choice
                self.add_item(button)

            special = discord.ui.Button(
                emoji='🌟',
                label='Special Move',
                custom_id='special',
                row=1,
                style=discord.ButtonStyle.primary
            )
            special.callback = self.special_move
            self.add_item(special)

        async def special_move(self, interaction: discord.Interaction):
            if not self.special_move_available or interaction.user not in [self.player1, self.player2]:
                return

            result = random.choices(['win', 'lose', 'draw'], weights=[0.5, 0.25, 0.25])[0]
            
            if interaction.user == self.player1:
                self.p1_choice = 'special'
                if self.p2_choice is None:
                    await interaction.response.defer()
                    return
            else:
                self.p2_choice = 'special'
                if self.p1_choice is None:
                    await interaction.response.defer()
                    return

            self.special_move_available = False
            await self.resolve_round(interaction, special_result=result)

    class WordScrambleView(discord.ui.View):
        def __init__(self, word: str, category: str, difficulty: str, ctx, cog):  
            super().__init__(timeout=120)
            
            self.word = word
            self.category = category
            self.difficulty = difficulty
            self.hints_remaining = 3 if difficulty == 'hard' else 2
            self.start_time = time.time()
            self.scrambled = self.scramble_word(word)
            self.guesses = []
            self.ctx = ctx
            self.cog = cog  
            self.setup_buttons()
            self.message = None
            
        def scramble_word(self, word):
            while True:
                scrambled = ''.join(random.sample(word, len(word)))
                if scrambled != word:
                    return scrambled

        def setup_buttons(self):
            hint = discord.ui.Button(
                emoji='💡',
                label=f'Hint ({self.hints_remaining})',
                custom_id='hint',
                row=0
            )
            hint.callback = self.give_hint
            self.add_item(hint)

            give_up = discord.ui.Button(
                emoji='🏳️',
                label='Give Up',
                style=discord.ButtonStyle.danger,
                row=0
            )
            give_up.callback = self.give_up
            self.add_item(give_up)

        async def give_hint(self, interaction: discord.Interaction):
            if self.hints_remaining <= 0:
                return

            revealed_positions = []
            hint_text = list('_' * len(self.word))
            
            for i, letter in enumerate(self.word):
                if random.random() < 0.3:
                    hint_text[i] = letter
                    revealed_positions.append(i)

            self.hints_remaining -= 1
            
            hint_embed = discord.Embed(
                title="💡 Hint",
                description=f"Here's a hint for the word:\n`{''.join(hint_text)}`\n"
                        f"Hints remaining: {self.hints_remaining}",
                color=discord.Color.gold()
            )

            await interaction.response.send_message(embed=hint_embed, ephemeral=True)

        async def give_up(self, interaction: discord.Interaction):
            embed = discord.Embed(
                title="Game Over!",
                description=f"The word was: **{self.word}**\n"
                        f"Category: {self.category.title()}\n"
                        f"Difficulty: {self.difficulty.title()}",
                color=discord.Color.red()
            )
            
            embed.add_field(
                name="Keep practicing!",
                value=f"Try another word with `!wordscramble {self.category} {self.difficulty}`"
            )
            
            await interaction.response.edit_message(embed=embed, view=None)
            self.stop()

        async def on_message(self, message):
            if message.author == self.ctx.author and message.channel == self.ctx.channel:
                guess = message.content.lower()
                self.guesses.append(guess)
               
                if guess == self.word.lower():
                    time_taken = int(time.time() - self.start_time)
                    embed = discord.Embed(
                        title="🎉 Correct!",
                        description=f"You solved it in {time_taken} seconds!\n"
                                f"Word: **{self.word}**\n"
                                f"Attempts: {len(self.guesses)}",
                        color=discord.Color.green()
                    )
                    await self.message.edit(embed=embed, view=None)
                    self.stop()

                    await self.cog.update_player_stats(
                        message.author.id,
                        'wordscramble',
                        won=True,
                        extra_data={
                            'time': time_taken,
                            'score': len(self.guesses)
                        }
                    )
                else:
                    hint_message = await message.channel.send("That's not correct! Try again!", delete_after=3)

    @commands.command(name='wordscramble')
    async def wordscramble(self, ctx, category: str = "random", difficulty: str = "normal"):
        if category == "random":
            category = random.choice(list(self.word_categories.keys()))
        
        word = random.choice(self.word_categories[category][difficulty])
        game_view = self.WordScrambleView(word, category, difficulty, ctx, self)  
        
        embed = discord.Embed(
            title="🔤 Word Scramble",
            description=f"Category: {category.title()}\n"
                        f"Difficulty: {difficulty.title()}\n\n"
                        f"Unscramble this word: **{game_view.scrambled}**\n"
                        f"Type your answer in this channel!",
            color=discord.Color.blue()
        )
        
        game_view.message = await ctx.send(embed=embed, view=game_view)
            
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
            
        while not game_view.is_finished():
            try:
                message = await self.bot.wait_for('message', timeout=120.0, check=check)
                await game_view.on_message(message)
            except asyncio.TimeoutError:
                timeout_embed = discord.Embed(
                    title="⏰ Time's Up!",
                    description=f"The word was **{word}**",
                    color=discord.Color.red()
                )
                await game_view.message.edit(embed=timeout_embed, view=None)
                break





    class MemoryView(discord.ui.View):
        def __init__(self, size=4, party_players=None):
            super().__init__(timeout=180)
            self.size = size
            self.board = []
            self.revealed = set()
            self.first_choice = None
            self.moves = 0
            self.start_time = None
            self.party_players = party_players or []
            self.current_player_index = 0
            self.player_scores = {player.id: 0 for player in self.party_players} if self.party_players else {}
            self.setup_board()

        def setup_board(self):
            valid_sizes = [2, 4]
            self.size = min(valid_sizes, key=lambda x: abs(x - self.size))
            
            emojis = ['🎮', '🎲', '🎯', '🎪', '🎨', '🎭', '🎫', '🎟️',
                    '🎸', '🎺', '🎻', '🎹', '🎼', '🎧', '🎤', '🎬']
            
            needed_pairs = (self.size * self.size) // 2
            emoji_pairs = (emojis[:needed_pairs] * 2)
            random.shuffle(emoji_pairs)
            
            self.board = [emoji_pairs[i:i+self.size] for i in range(0, self.size * self.size, self.size)]
            
            for i in range(self.size):
                for j in range(self.size):
                    button = discord.ui.Button(
                        style=discord.ButtonStyle.secondary,
                        label='❓',
                        custom_id=f'cell_{i}_{j}',
                        row=i
                    )
                    button.callback = self.make_move
                    self.add_item(button)





        async def make_move(self, interaction: discord.Interaction):
            if not self.start_time:
                self.start_time = time.time()

            if self.party_players:
                current_player = self.party_players[self.current_player_index]
                if interaction.user != current_player:
                    await interaction.response.send_message(f"It's {current_player.mention}'s turn!", ephemeral=True)
                    return

            pos = interaction.data['custom_id'].split('_')[1:]
            i, j = map(int, pos)
            
            if (i, j) in self.revealed:
                return

            self.moves += 1
            current_button = None
            
            for child in self.children:
                if child.custom_id == f'cell_{i}_{j}':
                    child.label = self.board[i][j]
                    child.disabled = True
                    current_button = child
                    break

            if not self.first_choice:
                self.first_choice = (i, j, current_button)
                await interaction.response.edit_message(view=self)
            else:
                prev_i, prev_j, prev_button = self.first_choice
                
                if self.board[i][j] == self.board[prev_i][prev_j]:
                    
                    self.revealed.add((i, j))
                    self.revealed.add((prev_i, prev_j))
                    
                    if self.party_players:
                        self.player_scores[interaction.user.id] += 1
                        await interaction.followup.send(f"{interaction.user.mention} found a pair! They get another turn!", ephemeral=False)
                    
                    if len(self.revealed) == self.size**2:
                        await self.game_won(interaction)
                    else:
                        await interaction.response.edit_message(view=self)
                else:
                   
                    await interaction.response.edit_message(view=self)
                    await asyncio.sleep(1)
                    
                    current_button.label = '❓'
                    current_button.disabled = False
                    prev_button.label = '❓'
                    prev_button.disabled = False
                    
                    await interaction.message.edit(view=self)
                    
                    if self.party_players:
                        self.current_player_index = (self.current_player_index + 1) % len(self.party_players)
                        next_player = self.party_players[self.current_player_index]
                        await interaction.followup.send(f"No match! It's now {next_player.mention}'s turn!", ephemeral=False)
                
                self.first_choice = None

        async def game_won(self, interaction):
            time_taken = int(time.time() - self.start_time)
            
            if self.party_players:
                winner = max(self.player_scores.items(), key=lambda x: x[1])
                winner_user = discord.utils.get(self.party_players, id=winner[0])
                
                embed = discord.Embed(
                    title="🎉 Memory Game Complete!",
                    description=f"Game Over!\n"
                            f"Winner: {winner_user.mention} with {winner[1]} pairs!\n"
                            f"Time taken: {time_taken} seconds\n"
                            f"Total moves: {self.moves}",
                    color=discord.Color.green()
                )
                
                scores_text = "\n".join(f"{discord.utils.get(self.party_players, id=pid).name}: {score} pairs" 
                                    for pid, score in self.player_scores.items())
                embed.add_field(name="Final Scores", value=scores_text)
            else:
                embed = discord.Embed(
                    title="🎉 Memory Game Complete!",
                    description=f"Congratulations! You matched all pairs!\n"
                            f"Time taken: {time_taken} seconds\n"
                            f"Total moves: {self.moves}",
                    color=discord.Color.green()
                )
                
                if time_taken < 30:
                    embed.add_field(name="Rating", value="⭐⭐⭐ Perfect!")
                elif time_taken < 60:
                    embed.add_field(name="Rating", value="⭐⭐ Great!")
                else:
                    embed.add_field(name="Rating", value="⭐ Good!")

            await interaction.response.edit_message(embed=embed, view=None)
            self.stop()

            await self.cog.update_player_stats(
                interaction.user.id,
                'memory',
                won=True,
                extra_data={
                    'time': time_taken,
                    'score': self.moves
                }
            )


    class TriviaView(discord.ui.View):
        def __init__(self, questions, category, difficulty, starter: discord.Member, cog=None):
            super().__init__(timeout=180)
            self.questions = questions
            self.category = category
            self.difficulty = difficulty
            self.starter = starter
            self.current_question = 0
            self.score = 0
            self.streak = 0
            self.multiplier = 1.0
            self.total_questions = len(questions)
            self.message = None
            self.cog = cog
            self.setup_question()

        def setup_question(self):
            self.clear_items()
            question = self.questions[self.current_question]
            
            answers = list(enumerate(question['answers']))
            random.shuffle(answers)
            for new_idx, (old_idx, answer) in enumerate(answers):
                if old_idx == question['correct']:
                    question['correct'] = new_idx
                
                button = discord.ui.Button(
                    label=answer,
                    custom_id=f'answer_{new_idx}',
                    style=discord.ButtonStyle.primary,
                    row=new_idx//2
                )
                button.callback = self.check_answer
                self.add_item(button)

        def create_status_embed(self, title, description):
            embed = discord.Embed(
                title=title,
                description=description,
                color=discord.Color.blue()
            )
            
            progress = "🟦" * self.current_question + "⬜" * (self.total_questions - self.current_question)
            embed.add_field(
                name=f"Progress: {self.current_question}/{self.total_questions}",
                value=progress,
                inline=False
            )
            
            if self.current_question < self.total_questions:
                embed.add_field(
                    name=f"Question {self.current_question + 1}",
                    value=self.questions[self.current_question]['question'],
                    inline=False
                )
            
            embed.add_field(
                name="Stats",
                value=f"Score: {self.score} | Streak: {self.streak}🔥 | Multiplier: x{self.multiplier:.1f}",
                inline=False
            )
            
            return embed

        async def check_answer(self, interaction: discord.Interaction):
            if interaction.user != self.starter:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return

            question = self.questions[self.current_question]
            choice = int(interaction.data['custom_id'].split('_')[1])
            
            if choice == question['correct']:
                self.streak += 1
                self.multiplier = min(2.0, 1.0 + (self.streak * 0.1))
                points = int(question['points'] * self.multiplier)
                self.score += points
                
                embed = self.create_status_embed(
                    "✅ Correct!",
                    f"You earned {points} points! (x{self.multiplier:.1f} multiplier)"
                )
            else:
                self.streak = 0
                self.multiplier = 1.0
                embed = self.create_status_embed(
                    "❌ Incorrect!",
                    f"The correct answer was: {question['answers'][question['correct']]}"
                )

            self.current_question += 1
            
            if self.current_question >= self.total_questions:
                embed.description += f"\n\n🎮 Game Over! Final Score: {self.score}"
                
                if self.score > 1000:
                    embed.add_field(name="🏆 Achievement", value="Score Master!")
                if self.streak >= 5:
                    embed.add_field(name="🔥 Achievement", value="Hot Streak!")
                
                same_category = discord.ui.Button(
                    label="Same Category",
                    style=discord.ButtonStyle.success,
                    custom_id="same_category",
                    row=4
                )
                same_category.callback = self.start_new_game

                random_category = discord.ui.Button(
                    label="Random Category",
                    style=discord.ButtonStyle.primary,
                    custom_id="random_category",
                    row=4
                )
                random_category.callback = self.start_random_category

                random_difficulty = discord.ui.Button(
                    label="Random Difficulty",
                    style=discord.ButtonStyle.secondary,
                    custom_id="random_difficulty",
                    row=4
                )
                random_difficulty.callback = self.start_random_difficulty

                self.clear_items()
                self.add_item(same_category)
                self.add_item(random_category)
                self.add_item(random_difficulty)
            else:
                self.setup_question()

            await interaction.response.edit_message(embed=embed, view=self)

        async def start_random_category(self, interaction: discord.Interaction):
            if interaction.user != self.starter:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return

            categories = ['general', 'science', 'history', 'geography', 'entertainment']
            available_categories = [c for c in categories if c != self.category]
            new_category = random.choice(available_categories)
            
            default_questions = [
                {
                    'question': 'What is the capital of France?',
                    'answers': ['Paris', 'London', 'Berlin', 'Madrid'],
                    'correct': 0,
                    'points': 100
                },
                {
                    'question': 'Which planet is known as the Red Planet?',
                    'answers': ['Mars', 'Venus', 'Jupiter', 'Saturn'],
                    'correct': 0,
                    'points': 100
                }
            ]

            if hasattr(self.cog, 'get_filtered_questions'):
                new_questions = self.cog.get_filtered_questions(new_category, self.difficulty)
            else:
                new_questions = default_questions

            new_view = self.__class__(new_questions, new_category, self.difficulty, self.starter, self.cog)
            embed = new_view.create_status_embed(
                f"New Game - {new_category.title()}!",
                f"Category: {new_category.title()}\nDifficulty: {self.difficulty.title()}\nGood luck! 🎮"
            )
            await interaction.response.edit_message(embed=embed, view=new_view)

        async def start_random_difficulty(self, interaction: discord.Interaction):
            if interaction.user != self.starter:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return

            difficulties = ['easy', 'normal', 'hard']
            available_difficulties = [d for d in difficulties if d != self.difficulty]
            new_difficulty = random.choice(available_difficulties)
            
            default_questions = {
                'easy': [
                    {
                        'question': 'What color is the sky on a clear day?',
                        'answers': ['Blue', 'Red', 'Green', 'Yellow'],
                        'correct': 0,
                        'points': 100
                    }
                ],
                'normal': [
                    {
                        'question': 'Which element has the chemical symbol Au?',
                        'answers': ['Gold', 'Silver', 'Copper', 'Iron'],
                        'correct': 0,
                        'points': 200
                    }
                ],
                'hard': [
                    {
                        'question': 'What is the speed of light in meters per second?',
                        'answers': ['299,792,458', '199,792,458', '399,792,458', '499,792,458'],
                        'correct': 0,
                        'points': 300
                    }
                ]
            }

            new_questions = default_questions[new_difficulty] if not hasattr(self.cog, 'get_filtered_questions') else self.cog.get_filtered_questions(self.category, new_difficulty)

            new_view = self.__class__(new_questions, self.category, new_difficulty, self.starter, self.cog)
            embed = new_view.create_status_embed(
                f"New Game - {new_difficulty.title()} Mode!",
                f"Difficulty increased to {new_difficulty.title()}!\nCategory: {self.category.title()}\nGood luck! 🎮"
            )
            await interaction.response.edit_message(embed=embed, view=new_view)

        async def start_new_game(self, interaction: discord.Interaction):
            if interaction.user != self.starter:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return

            if hasattr(self.cog, 'get_filtered_questions'):
                new_questions = self.cog.get_filtered_questions(self.category, self.difficulty)
            else:
                new_questions = self.questions  

            new_view = self.__class__(new_questions, self.category, self.difficulty, self.starter, self.cog)
            embed = new_view.create_status_embed("New Game Started!", "Good luck! 🎮")
                
            await interaction.response.edit_message(embed=embed, view=new_view)

        async def next_question(self, interaction: discord.Interaction):
            if interaction.user != self.starter:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return
                
            self.setup_question()
            embed = self.create_status_embed("Next Question", "Choose your answer!")
            await interaction.response.edit_message(embed=embed, view=self)

        async def upgrade_difficulty(self, interaction: discord.Interaction):
            if interaction.user != self.starter:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return
                
            difficulties = ['easy', 'normal', 'hard']
            current_index = difficulties.index(self.difficulty)
            if current_index < len(difficulties) - 1:
                self.difficulty = difficulties[current_index + 1]
                self.multiplier *= 1.5  
                
                if hasattr(self.cog, 'get_filtered_questions'):
                    new_questions = self.cog.get_filtered_questions(self.category, self.difficulty)
                    self.questions.extend(new_questions)
                    self.total_questions = len(self.questions)
                
                embed = self.create_status_embed(
                    "Difficulty Increased!",
                    f"Now playing on {self.difficulty.title()} mode! (x1.5 points)"
                )
                await interaction.response.edit_message(embed=embed, view=self)

    @commands.command()
    async def reactiontest(self, ctx, mode: str = "classic"):
        
        modes = ["classic", "pattern", "chain"]
        if mode not in modes:
            mode = "classic"
            
        embed = discord.Embed(
            title="⚡ Ultimate Reaction Test",
            description=(
                f"**Mode:** {mode.title()}\n"
                f"**Players:** {ctx.author.mention}\n\n"
                "🎮 Get ready to test your reactions!\n"
                "⚡ Wait for the button to turn green\n"
                "🏆 Compete for the fastest time!"
            ),
            color=discord.Color.blue()
        )
        
        game_view = self.ReactionTestView(mode, ctx.author)
        message = await ctx.send(embed=embed, view=game_view)
        game_view.message = message

    class ReactionTestView(discord.ui.View):
        def __init__(self, mode='classic', starter=None, party_players=None):
            super().__init__(timeout=180)
            self.mode = mode
            self.starter = starter
            self.party_players = party_players or []
            self.current_player_index = 0
            self.start_time = None
            self.scores = {}
            self.round = 0
            self.max_rounds = 5
            self.message = None
            self.streaks = {}
            self.achievements = {}
            self.setup_game()

        def setup_game(self):
            self.clear_items()
            
            if self.mode == 'classic':
                button = discord.ui.Button(
                    label='Wait for green...',
                    style=discord.ButtonStyle.danger,
                    custom_id='reaction'
                )
                button.callback = self.handle_reaction
                self.add_item(button)
                
            elif self.mode == 'pattern':
                colors = ['🔴', '🟡', '🟢', '🔵']
                self.pattern = [random.randint(0, 3) for _ in range(3)]
                self.current_pattern_index = 0
                
                for i, color in enumerate(colors):
                    button = discord.ui.Button(
                        emoji=color,
                        custom_id=f'pattern_{i}',
                        row=0
                    )
                    button.callback = self.handle_pattern
                    self.add_item(button)
                    
            elif self.mode == 'chain':
                self.chain_sequence = []
                self.current_chain_index = 0
                button = discord.ui.Button(
                    label='Start Chain',
                    style=discord.ButtonStyle.primary,
                    custom_id='chain_start'
                )
                button.callback = self.handle_chain
                self.add_item(button)

            asyncio.create_task(self.start_waiting())


        async def start_waiting(self):
            await asyncio.sleep(random.uniform(2.0, 5.0))
            if not self.is_finished():
                self.start_time = time.time()
                if self.mode == 'classic':
                    self.children[0].style = discord.ButtonStyle.success
                    self.children[0].label = 'Click Now!'
                elif self.mode == 'pattern':
                    await self.show_pattern()
                elif self.mode == 'chain':
                    await self.start_chain()
                await self.message.edit(view=self)

        async def handle_reaction(self, interaction: discord.Interaction):
            current_player = self.party_players[self.current_player_index] if self.party_players else self.starter
            
            if self.party_players and interaction.user != current_player:
                await interaction.response.send_message(
                    f"🎮 It's {current_player.mention}'s turn!", 
                    ephemeral=True
                )
                return

            if not self.start_time:
                embed = discord.Embed(
                    title="⚠️ Too Early!",
                    description="Wait for the button to turn green!",
                    color=discord.Color.red()
                )
                await interaction.response.edit_message(embed=embed, view=self)
                return

            reaction_time = (time.time() - self.start_time) * 1000
            player_id = str(interaction.user.id)
            
            if player_id not in self.scores:
                self.scores[player_id] = []
            self.scores[player_id].append(reaction_time)
            
            if reaction_time < 200:
                self.streaks[player_id] = self.streaks.get(player_id, 0) + 1
                if self.streaks[player_id] >= 3:
                    self.achievements[player_id] = self.achievements.get(player_id, [])
                    if "Speed Demon" not in self.achievements[player_id]:
                        self.achievements[player_id].append("Speed Demon")

            self.round += 1
            
            if self.party_players:
                self.current_player_index = (self.current_player_index + 1) % len(self.party_players)

            embed = discord.Embed(
                title=f"Round {self.round}/{self.max_rounds}",
                description=(
                    f"⚡ Reaction Time: {reaction_time:.1f}ms\n"
                    f"🎯 Accuracy Rating: {self.get_accuracy_rating(reaction_time)}\n"
                    f"🔥 Current Streak: {self.streaks.get(player_id, 0)}"
                ),
                color=self.get_color_for_time(reaction_time)
            )

            if self.round >= self.max_rounds:
                await self.show_final_results(interaction, embed)
            else:
                self.start_time = None
                self.setup_game()
                await interaction.response.edit_message(embed=embed, view=self)

            await self.cog.update_player_stats(
                interaction.user.id,
                'reaction',
                won=reaction_time < 300,
                extra_data={
                    'time': reaction_time,
                    'streak': self.streaks.get(str(interaction.user.id), 0)
                }
            )

        def get_accuracy_rating(self, time):
            if time < 150: return "Perfect! 🌟"
            if time < 200: return "Amazing! ⭐"
            if time < 250: return "Great! ✨"
            if time < 300: return "Good! 👍"
            return "Keep practicing! 💪"

        def get_color_for_time(self, time):
            if time < 150: return discord.Color.gold()
            if time < 200: return discord.Color.green()
            if time < 250: return discord.Color.blue()
            return discord.Color.purple()

        async def show_final_results(self, interaction, embed):
            results = []
            for pid, times in self.scores.items():
                user = interaction.guild.get_member(int(pid))
                avg_time = sum(times) / len(times)
                best_time = min(times)
                results.append((user, avg_time, best_time))
            
            results.sort(key=lambda x: x[1])
            
            leaderboard = "\n".join(
                f"{'🥇' if i==0 else '🥈' if i==1 else '🥉' if i==2 else f'#{i+1}'} "
                f"{user.mention}: Avg {avg:.1f}ms | Best {best:.1f}ms"
                for i, (user, avg, best) in enumerate(results)
            )
            
            embed.add_field(
                name="🏆 Final Leaderboard",
                value=leaderboard,
                inline=False
            )
            
            achievements_text = ""
            for pid, achievs in self.achievements.items():
                user = interaction.guild.get_member(int(pid))
                if achievs:
                    achievements_text += f"\n{user.mention}: {', '.join(achievs)}"
            
            if achievements_text:
                embed.add_field(
                    name="🌟 Achievements Earned",
                    value=achievements_text,
                    inline=False
                )
            
            await interaction.response.edit_message(embed=embed, view=None)
            self.stop()


    @commands.command()
    async def aimtrainer(self, ctx, duration: int = 30):
        
        duration = max(30, min(90, duration))
        
        embed = discord.Embed(
            title="🎯 Ultimate Aim Trainer",
            description=(
                f"**Duration:** {duration} seconds\n"
                f"**Player:** {ctx.author.mention}\n\n"
                "🎯 Click the targets as fast as you can!\n"
                "⚡ Avoid missing for better accuracy\n"
                "🏆 Compete for the highest score!\n\n"
                "Game starting in 3 seconds..."
            ),
            color=discord.Color.blue()
        )
        
        game_view = self.AimTrainerView(duration, ctx.author)
        message = await ctx.send(embed=embed, view=None)
        game_view.message = message
        
        for i in range(3, 0, -1):
            embed.description = embed.description.replace(f"{i} seconds", f"{i-1} seconds")
            await asyncio.sleep(1)
            await message.edit(embed=embed)
        
        await message.edit(view=game_view)
        game_view.start_game()

    class AimTrainerView(discord.ui.View):
        def __init__(self, duration=30, starter=None, party_players=None):
            super().__init__(timeout=None)
            self.duration = duration
            self.starter = starter
            self.party_players = party_players or []
            self.current_player_index = 0
            self.scores = {}
            self.start_time = None
            self.end_time = None
            self.message = None
            self.game_active = False
            self.setup_initial_scores()
            self.setup_targets()

        def start_game(self):
            self.start_time = time.time()
            self.end_time = self.start_time + self.duration
            self.game_active = True
            asyncio.create_task(self.game_timer())

        async def game_timer(self):
            await asyncio.sleep(self.duration)
            if self.game_active:
                self.game_active = False
                await self.show_final_results(self.message)

        def get_color_for_accuracy(self, accuracy):
            if accuracy >= 90: return discord.Color.gold()
            if accuracy >= 75: return discord.Color.green()
            if accuracy >= 60: return discord.Color.blue()
            return discord.Color.purple()

        def setup_initial_scores(self):
            players = self.party_players if self.party_players else [self.starter]
            for player in players:
                self.scores[player.id] = {
                    'targets_hit': 0,
                    'misses': 0,
                    'best_streak': 0,
                    'current_streak': 0,
                    'clicks_per_second': [],
                    'reaction_times': []
                }

        def setup_targets(self):
            self.clear_items()
            
            base_target_count = random.randint(4, 8)
            grid_size = 5
            grid_positions = [(i, j) for i in range(grid_size) for j in range(grid_size)]
            
            target_positions = set()
            pattern_type = random.choice(['random', 'cluster', 'diagonal', 'corners'])
            
            if pattern_type == 'cluster':
                
                for _ in range(random.randint(1, 2)):
                    center = random.choice(grid_positions)
                    target_positions.add(center)
                    for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
                        new_x, new_y = center[0] + dx, center[1] + dy
                        if 0 <= new_x < grid_size and 0 <= new_y < grid_size:
                            if random.random() < 0.7:  
                                target_positions.add((new_x, new_y))
            
            elif pattern_type == 'diagonal':
                
                direction = random.choice([(1,1), (1,-1), (-1,1), (-1,-1)])
                start_x = 0 if direction[0] > 0 else grid_size-1
                start_y = 0 if direction[1] > 0 else grid_size-1
                for i in range(grid_size):
                    if random.random() < 0.7:
                        x, y = start_x + (i * direction[0]), start_y + (i * direction[1])
                        if 0 <= x < grid_size and 0 <= y < grid_size:
                            target_positions.add((x, y))
            
            elif pattern_type == 'corners':
               
                corners = [(0,0), (0,grid_size-1), (grid_size-1,0), (grid_size-1,grid_size-1)]
                target_positions.update(random.sample(corners, random.randint(2, 4)))
                if random.random() < 0.5:  
                    target_positions.add((grid_size//2, grid_size//2))
            
            else: 
                target_positions = set(random.sample(grid_positions, base_target_count))
            
            while len(target_positions) < base_target_count:
                target_positions.add(random.choice(grid_positions))
            
            target_emojis = ['🎯', '🎪', '⭐', '🔥', '💫']  
            for i, j in grid_positions:
                is_target = (i, j) in target_positions
                style = random.choice([
                    discord.ButtonStyle.success,
                    discord.ButtonStyle.primary
                ]) if is_target else discord.ButtonStyle.secondary
                
                button = discord.ui.Button(
                    emoji=random.choice(target_emojis) if is_target else '⬛',
                    custom_id=f'target_{i}_{j}_{is_target}',
                    row=i,
                    style=style
                )
                button.callback = self.handle_click
                self.add_item(button)


        async def handle_click(self, interaction: discord.Interaction):
            if not self.game_active:
                await interaction.response.edit_message(view=None)
                return

            current_player = self.party_players[self.current_player_index] if self.party_players else self.starter
            if interaction.user != current_player:
                await interaction.response.send_message(
                    f"🎮 It's {current_player.mention}'s turn!", 
                    ephemeral=True
                )
                return

            current_time = time.time()
            time_remaining = max(0, self.end_time - current_time)
            
            if time_remaining <= 0:
                self.game_active = False
                await self.show_final_results(interaction)
                return

            _, _, _, is_target = interaction.data['custom_id'].split('_')
            is_target = is_target == 'True'
            player_stats = self.scores[interaction.user.id]
            
            player_stats['clicks_per_second'].append(current_time)
            
            if is_target:
                player_stats['targets_hit'] += 1
                player_stats['current_streak'] += 1
                player_stats['best_streak'] = max(
                    player_stats['best_streak'], 
                    player_stats['current_streak']
                )
            else:
                player_stats['misses'] += 1
                player_stats['current_streak'] = 0

            if self.party_players:
                self.current_player_index = (self.current_player_index + 1) % len(self.party_players)

            recent_clicks = [t for t in player_stats['clicks_per_second'] 
                           if current_time - t <= 1.0]
            cps = len(recent_clicks)

            accuracy = (player_stats['targets_hit'] / 
                       (player_stats['targets_hit'] + player_stats['misses']) * 100 
                       if (player_stats['targets_hit'] + player_stats['misses']) > 0 else 0)

            embed = discord.Embed(
                title="🎯 Aim Trainer",
                description=(
                    f"**Player:** {interaction.user.mention}\n"
                    f"**Targets Hit:** {player_stats['targets_hit']} 🎯\n"
                    f"**Accuracy:** {accuracy:.1f}% ⚡\n"
                    f"**Current Streak:** {player_stats['current_streak']} 🔥\n"
                    f"**Best Streak:** {player_stats['best_streak']} ⭐\n"
                    f"**CPS:** {cps} 👆\n"
                    f"**Time Remaining:** {time_remaining:.1f}s ⏱️"
                ),
                color=self.get_color_for_accuracy(accuracy)
            )

            self.setup_targets()
            await interaction.response.edit_message(embed=embed, view=self)

        async def show_final_results(self, interaction):
            results = []
            for player_id, stats in self.scores.items():
                user = self.message.guild.get_member(player_id)
                total_clicks = stats['targets_hit'] + stats['misses']
                accuracy = (stats['targets_hit'] / total_clicks * 100 
                           if total_clicks > 0 else 0)
                avg_cps = (len(stats['clicks_per_second']) / self.duration 
                          if stats['clicks_per_second'] else 0)
                
                results.append((
                    user, 
                    stats['targets_hit'], 
                    accuracy, 
                    stats['best_streak'],
                    avg_cps
                ))

            results.sort(key=lambda x: (x[1], x[2]), reverse=True)
            
            leaderboard = "\n".join(
                f"{'🥇' if i==0 else '🥈' if i==1 else '🥉' if i==2 else f'#{i+1}'} "
                f"{user.mention}:\n"
                f"➟ {targets} hits | {acc:.1f}% accuracy\n"
                f"➟ Best Streak: {streak} 🔥 | Avg CPS: {cps:.1f} ⚡"
                for i, (user, targets, acc, streak, cps) in enumerate(results)
            )

            embed = discord.Embed(
                title="🏆 Game Over - Final Results",
                description=leaderboard,
                color=discord.Color.gold()
            )

            if isinstance(interaction, discord.Interaction):
                await interaction.response.edit_message(embed=embed, view=None)
            else:
                await interaction.edit(embed=embed, view=None)
            self.stop()

            await self.cog.update_player_stats(
                interaction.user.id,
                'aimtrainer',
                won=self.scores[interaction.user.id]['targets_hit'] > 0,
                extra_data={
                    'accuracy': accuracy,
                    'score': self.scores[interaction.user.id]['targets_hit'],
                    'streak': self.scores[interaction.user.id]['best_streak']
                }
            )


    def get_filtered_questions(self, category, difficulty):
        questions = {
            'general': [
                {
                    'question': 'What is the capital of France?',
                    'answers': ['Paris', 'London', 'Berlin', 'Madrid'],
                    'correct': 0,  
                    'difficulty': 'normal',
                    'points': 100
                },
                {
                    'question': 'Which planet is known as the Red Planet?',
                    'answers': ['Mars', 'Venus', 'Jupiter', 'Saturn'],
                    'correct': 0,  
                    'difficulty': 'easy',
                    'points': 50
                },
                {
                    'question': 'What is the chemical symbol for gold?',
                    'answers': ['Au', 'Ag', 'Fe', 'Cu'],
                    'correct': 0,  
                    'difficulty': 'normal',
                    'points': 100
                }
            ],
            'science': [
                {
                    'question': 'What is the hardest natural substance on Earth?',
                    'answers': ['Diamond', 'Gold', 'Iron', 'Platinum'],
                    'correct': 0,  
                    'difficulty': 'easy',
                    'points': 50
                },
                {
                    'question': 'What is the speed of light in miles per second?',
                    'answers': ['186,282', '150,000', '200,000', '170,000'],
                    'correct': 0,  
                    'difficulty': 'hard',
                    'points': 150
                }
            ],
            'history': [
                {
                    'question': 'In which year did World War II end?',
                    'answers': ['1945', '1944', '1946', '1943'],
                    'correct': 0,  
                    'difficulty': 'normal',
                    'points': 100
                },
                {
                    'question': 'Who was the first President of the United States?',
                    'answers': ['George Washington', 'John Adams', 'Thomas Jefferson', 'Benjamin Franklin'],
                    'correct': 0,  
                    'difficulty': 'easy',
                    'points': 50
                }
            ]
        }

        if category == "random":
            category = random.choice(list(questions.keys()))
        
        filtered = [q for q in questions[category] if q['difficulty'] == difficulty or difficulty == "all"]
        
        if not filtered:
            filtered = questions[category]
        
        return filtered



    @commands.command(name='trivia')
    async def trivia(self, ctx, category: str = "random", difficulty: str = "normal"):
        
        if category == "random":
            category = random.choice(list(self.trivia_questions.keys()))
                
        questions = self.get_filtered_questions(category, difficulty)
        first_question = questions[0]['question']  
        
        embed = discord.Embed(
            title="🎮 Trivia Challenge",
            description=f"Category: {category.title()}\n"
                    f"Difficulty: {difficulty.title()}\n"
                    f"Questions: {len(questions)}\n\n"
                    f"Question 1: {first_question}",  
            color=discord.Color.blue()
        )
        
        game_view = self.TriviaView(questions, category, difficulty, ctx.author)
        message = await ctx.send(embed=embed, view=game_view)
        game_view.message = message

    @commands.command()
    async def party(self, ctx):
        
        embed = EmbedBuilder(
            "🎪 Party Game Session",
            f"{ctx.author.mention} is starting a party game session!\n"
            "Join to play multiple minigames in succession."
        ).set_color(discord.Color.blue())

        view = discord.ui.View(timeout=60)
        
        async def join_callback(interaction):
            if len(self.active_games.get(ctx.channel.id, [])) >= 8:
                await interaction.response.send_message("Party is full!", ephemeral=True)
                return
                
            if ctx.channel.id not in self.active_games:
                self.active_games[ctx.channel.id] = []
            
            if interaction.user not in self.active_games[ctx.channel.id]:
                self.active_games[ctx.channel.id].append(interaction.user)
                await interaction.response.send_message(f"Joined the party! ({len(self.active_games[ctx.channel.id])}/8)", ephemeral=True)
                
                if len(self.active_games[ctx.channel.id]) >= 2:
                    start_button.disabled = False
                    await interaction.message.edit(view=view)

        async def start_callback(interaction):
            if interaction.user != ctx.author:
                return
                
            await self.start_party_session(ctx, self.active_games[ctx.channel.id])
            await interaction.message.delete()

        join_button = discord.ui.Button(label="Join Party", style=discord.ButtonStyle.green, emoji="🎮")
        start_button = discord.ui.Button(label="Start Games", style=discord.ButtonStyle.primary, emoji="▶️", disabled=True)
        
        join_button.callback = join_callback
        start_button.callback = start_callback
        
        view.add_item(join_button)
        view.add_item(start_button)
        
        await ctx.send(embed=embed.build(), view=view)

    async def start_party_session(self, ctx, players):
        
        games = ['trivia', 'reactiontest', 'aimtrainer', 'wordscramble']
        scores = {player.id: 0 for player in players}
        
        for round_num in range(4):
            game = random.choice(games)
            games.remove(game)
            
            round_embed = EmbedBuilder(
                f"🎪 Round {round_num + 1}",
                f"Next game: {game.title()}!\n"
                "Starting in 5 seconds..."
            ).set_color(discord.Color.blue())
            
            await ctx.send(embed=round_embed.build())
            await asyncio.sleep(5)
            
            if game == 'trivia':
                await self.trivia(ctx, "random", "normal")
            elif game == 'reactiontest':
                await self.reactiontest(ctx, "classic")
            elif game == 'aimtrainer':
                await self.aimtrainer(ctx)
            elif game == 'wordscramble':
                await self.wordscramble(ctx, "random", "normal")
            
            await asyncio.sleep(30)  

    @commands.command(name='gameleaderboard')
    async def game_leaderboard(self, ctx, game_type: str = "all"):
        
        valid_types = ["all", "trivia", "reaction", "aim", "memory", "rps", "wordscramble"]
        if game_type not in valid_types:
            game_type = "all"

        embed = EmbedBuilder(
            "🏆 Game Leaderboards",
            f"Top players in {game_type.title()}"
        ).set_color(discord.Color.gold())

        if game_type == "all":
            sorted_scores = sorted(
                self.scores.items(),
                key=lambda x: x[1]['wins'],
                reverse=True
            )[:10]

            for i, (user_id, stats) in enumerate(sorted_scores, 1):
                user = self.bot.get_user(user_id)
                if user:
                    embed.add_field(
                        name=f"#{i} {user.name}",
                        value=f"Wins: {stats['wins']}\n"
                              f"Games: {stats['total_games']}\n"
                              f"Win Rate: {(stats['wins']/stats['total_games']*100):.1f}%",
                        inline=True
                    )
        else:
            
            game_scores = {
                user_id: stats['game_specific'].get(game_type, {'score': 0})
                for user_id, stats in self.scores.items()
                if game_type in stats['game_specific']
            }
            sorted_scores = sorted(
                game_scores.items(),
                key=lambda x: x[1]['score'],
                reverse=True
            )[:10]

            for i, (user_id, stats) in enumerate(sorted_scores, 1):
                user = self.bot.get_user(user_id)
                if user:
                    embed.add_field(
                        name=f"#{i} {user.name}",
                        value=f"Score: {stats['score']}\n"
                              f"Best Streak: {stats.get('best_streak', 0)}",
                        inline=True
                    )

        await ctx.send(embed=embed.build())

    @commands.command()
    async def profile(self, ctx, user: discord.Member = None):
        
        user = user or ctx.author
        
        if user.id not in self.scores:
            embed = discord.Embed(
                title="🎮 Gaming Profile",
                description=f"{user.name} hasn't played any games yet!\nUse `!games` to see available games!",
                color=discord.Color.blue()
            )
            await ctx.send(embed=embed)
            return

        stats = self.scores[user.id]
        achievements = self.achievements.get(user.id, [])
        
        win_rate = (stats.get('wins', 0) / stats.get('total_games', 1) * 100) if stats.get('total_games', 0) > 0 else 0
        
        embed = discord.Embed(
            title=f"🎮 {user.name}'s Gaming Profile",
            description=(
                f"**Total Games:** {stats.get('total_games', 0)} 🎲\n"
                f"**Wins:** {stats.get('wins', 0)} 🏆\n"
                f"**Win Rate:** {win_rate:.1f}% ⚡\n"
                f"**Current Streak:** {self.streaks.get(user.id, 0)} 🔥"
            ),
            color=discord.Color.blue()
        )

        if 'reaction' in stats.get('game_specific', {}):
            reaction_stats = stats['game_specific']['reaction']
            embed.add_field(
                name="⚡ Reaction Test",
                value=(
                    f"Games: {reaction_stats.get('games', 0)}\n"
                    f"Best Time: {reaction_stats.get('best_time', 0):.1f}ms\n"
                    f"Avg Time: {reaction_stats.get('avg_time', 0):.1f}ms"
                ),
                inline=True
            )

        if 'aimtrainer' in stats.get('game_specific', {}):
            aim_stats = stats['game_specific']['aimtrainer']
            embed.add_field(
                name="🎯 Aim Trainer",
                value=(
                    f"Games: {aim_stats.get('games', 0)}\n"
                    f"Best Score: {aim_stats.get('best_score', 0)}\n"
                    f"Best Accuracy: {aim_stats.get('best_accuracy', 0)}%"
                ),
                inline=True
            )

        if 'memory' in stats.get('game_specific', {}):
            memory_stats = stats['game_specific']['memory']
            embed.add_field(
                name="🧩 Memory Game",
                value=(
                    f"Games: {memory_stats.get('games', 0)}\n"
                    f"Best Time: {memory_stats.get('best_time', 0)}s\n"
                    f"Perfect Matches: {memory_stats.get('perfect_matches', 0)}"
                ),
                inline=True
            )

        if 'wordscramble' in stats.get('game_specific', {}):
            word_stats = stats['game_specific']['wordscramble']
            embed.add_field(
                name="🔤 Word Scramble",
                value=(
                    f"Games: {word_stats.get('games', 0)}\n"
                    f"Words Solved: {word_stats.get('solved', 0)}\n"
                    f"Best Time: {word_stats.get('best_time', 0)}s"
                ),
                inline=True
            )

        if 'hangman' in stats.get('game_specific', {}):
            hangman_stats = stats['game_specific']['hangman']
            embed.add_field(
                name="👻 Hangman",
                value=(
                    f"Games: {hangman_stats.get('games', 0)}\n"
                    f"Words Guessed: {hangman_stats.get('wins', 0)}\n"
                    f"Best Streak: {hangman_stats.get('best_streak', 0)}"
                ),
                inline=True
            )

        if 'rps' in stats.get('game_specific', {}):
            rps_stats = stats['game_specific']['rps']
            embed.add_field(
                name="✂️ Rock Paper Scissors",
                value=(
                    f"Games: {rps_stats.get('games', 0)}\n"
                    f"Wins: {rps_stats.get('wins', 0)}\n"
                    f"Best Streak: {rps_stats.get('best_streak', 0)}"
                ),
                inline=True
            )

        if 'trivia' in stats.get('game_specific', {}):
            trivia_stats = stats['game_specific']['trivia']
            embed.add_field(
                name="❓ Trivia",
                value=(
                    f"Games: {trivia_stats.get('games', 0)}\n"
                    f"Correct Answers: {trivia_stats.get('correct', 0)}\n"
                    f"Best Score: {trivia_stats.get('best_score', 0)}"
                ),
                inline=True
            )

        if achievements:
            embed.add_field(
                name="🏆 Achievements",
                value="\n".join(f"• {achievement}" for achievement in achievements),
                inline=False
            )

        if 'recent_games' in stats:
            recent = stats['recent_games'][-3:]  
            embed.add_field(
                name="🕒 Recent Activity",
                value="\n".join(f"• {game}" for game in recent),
                inline=False
            )

        await ctx.send(embed=embed)


    @commands.command()
    async def daily(self, ctx):
        
        today = datetime.now().strftime("%Y-%m-%d")
        user_id = ctx.author.id

        if user_id not in self.daily_challenges:
            self.daily_challenges[user_id] = {
                'last_claim': None,
                'completed': []
            }

        if self.daily_challenges[user_id]['last_claim'] == today:
            embed = EmbedBuilder(
                "📅 Daily Challenges",
                "You've already claimed today's challenges!\n"
                "Come back tomorrow for new ones!"
            ).set_color(discord.Color.blue())
        else:
           
            challenges = [
                "Win 3 games of any type",
                "Achieve a 5-streak in Trivia",
                "Score 95% accuracy in Aim Trainer",
                "Complete a Hard difficulty Word Scramble"
            ]
            
            self.daily_challenges[user_id] = {
                'last_claim': today,
                'completed': [],
                'challenges': challenges
            }

            embed = EmbedBuilder(
                "📅 Daily Challenges",
                "Here are your daily challenges:"
            ).set_color(discord.Color.blue())

            for i, challenge in enumerate(challenges, 1):
                embed.add_field(
                    name=f"Challenge {i}",
                    value=f"• {challenge}\nReward: 100 points",
                    inline=False
                )

        await ctx.send(embed=embed.build())
    @commands.command()
    async def tournament(self, ctx, game_type: str = "random", players: int = 8):
        
        valid_games = ["rps", "trivia", "aimtrainer", "wordscramble"]
        if game_type not in valid_games:
            game_type = random.choice(valid_games)
            
        embed = EmbedBuilder(
            "🏆 Tournament Mode",
            f"Game: {game_type.title()}\n"
            f"Players needed: {players}\n\n"
            "React to join! Tournament starts in 60 seconds."
        ).set_color(discord.Color.gold())

        view = TournamentView(self, game_type, players)
        message = await ctx.send(embed=embed.build(), view=view)
        view.message = message

    class TournamentView(discord.ui.View):
        def __init__(self, cog, game_type, max_players):
            super().__init__(timeout=60)
            self.cog = cog
            self.game_type = game_type
            self.max_players = max_players
            self.players = []
            self.brackets = []
            self.setup_buttons()

        def setup_buttons(self):
            join = discord.ui.Button(
                label=f"Join Tournament (0/{self.max_players})", 
                style=discord.ButtonStyle.green,
                emoji="🎮"
            )
            join.callback = self.join_tournament
            self.add_item(join)

        async def join_tournament(self, interaction: discord.Interaction):
            if interaction.user in self.players:
                await interaction.response.send_message("You're already in the tournament!", ephemeral=True)
                return

            self.players.append(interaction.user)
            self.children[0].label = f"Join Tournament ({len(self.players)}/{self.max_players})"

            if len(self.players) >= self.max_players:
                await self.start_tournament(interaction)
            else:
                await interaction.response.edit_message(view=self)

        async def start_tournament(self, interaction):
            random.shuffle(self.players)
            self.brackets = self.create_brackets()
            
            bracket_embed = self.create_bracket_embed()
            await interaction.message.edit(embed=bracket_embed, view=None)
            
            await self.run_matches()

        def create_brackets(self):
            brackets = []
            for i in range(0, len(self.players), 2):
                if i + 1 < len(self.players):
                    brackets.append([self.players[i], self.players[i+1]])
                else:
                    brackets.append([self.players[i], None])  
            return brackets

        def create_bracket_embed(self):
            embed = EmbedBuilder(
                "🏆 Tournament Brackets",
                "Current matchups:"
            ).set_color(discord.Color.gold())

            for i, match in enumerate(self.brackets, 1):
                if match[1]:
                    embed.add_field(
                        name=f"Match {i}",
                        value=f"{match[0].name} vs {match[1].name}",
                        inline=False
                    )
                else:
                    embed.add_field(
                        name=f"Match {i}",
                        value=f"{match[0].name} (Bye round)",
                        inline=False
                    )

            return embed.build()

        async def run_matches(self):
            winners = []
            for match in self.brackets:
                if not match[1]:  
                    winners.append(match[0])
                    continue

                overwrites = {
                    self.message.guild.default_role: discord.PermissionOverwrite(read_messages=False),
                    match[0]: discord.PermissionOverwrite(read_messages=True),
                    match[1]: discord.PermissionOverwrite(read_messages=True)
                }
                
                channel = await self.message.guild.create_text_channel(
                    f"tournament-match-{match[0].name}-{match[1].name}",
                    overwrites=overwrites
                )

                winner = await self.run_game(channel, match[0], match[1])
                winners.append(winner)
                
                await channel.delete()

            if len(winners) > 1:
                self.players = winners
                self.brackets = self.create_brackets()
                await self.message.channel.send("Next round starting!")
                await self.run_matches()
            else:
                await self.end_tournament(winners[0])

        async def end_tournament(self, winner):
            embed = EmbedBuilder(
                "🎉 Tournament Complete!",
                f"Winner: {winner.mention}\n"
                "Congratulations!"
            ).set_color(discord.Color.gold())
            
            await self.message.channel.send(embed=embed.build())
class TournamentView(discord.ui.View):
    def __init__(self, cog, game_type, max_players):
        super().__init__(timeout=60)
        self.cog = cog
        self.game_type = game_type
        self.max_players = max_players
        self.players = []
        self.brackets = []
        self.message = None
        self.setup_buttons()

    def setup_buttons(self):
        join = discord.ui.Button(
            label=f"Join Tournament (0/{self.max_players})", 
            style=discord.ButtonStyle.green,
            emoji="🎮"
        )
        join.callback = self.join_tournament
        self.add_item(join)

        start = discord.ui.Button(
            label="Start Tournament", 
            style=discord.ButtonStyle.primary,
            emoji="▶️",
            disabled=True
        )
        start.callback = self.start_tournament
        self.add_item(start)

    async def join_tournament(self, interaction: discord.Interaction):
        if interaction.user in self.players:
            await interaction.response.send_message("You're already in the tournament!", ephemeral=True)
            return

        self.players.append(interaction.user)
        self.children[0].label = f"Join Tournament ({len(self.players)}/{self.max_players})"

        if len(self.players) >= 2:
            self.children[1].disabled = False

        if len(self.players) >= self.max_players:
            self.children[0].disabled = True

        await interaction.response.edit_message(view=self)

    async def start_tournament(self, interaction: discord.Interaction):
        if len(self.players) < 2:
            return

        random.shuffle(self.players)
        self.brackets = self.create_brackets()
        
        bracket_embed = self.create_bracket_embed()
        await interaction.response.edit_message(embed=bracket_embed, view=None)
        
        await self.run_matches()

    def create_brackets(self):
        brackets = []
        for i in range(0, len(self.players), 2):
            if i + 1 < len(self.players):
                brackets.append([self.players[i], self.players[i+1]])
            else:
                brackets.append([self.players[i], None])
        return brackets

    def create_bracket_embed(self):
        embed = EmbedBuilder(
            "🏆 Tournament Brackets",
            "Current matchups:"
        ).set_color(discord.Color.gold())

        for i, match in enumerate(self.brackets, 1):
            if match[1]:
                embed.add_field(
                    name=f"Match {i}",
                    value=f"{match[0].name} vs {match[1].name}",
                    inline=False
                )
            else:
                embed.add_field(
                    name=f"Match {i}",
                    value=f"{match[0].name} (Bye round)",
                    inline=False
                )

        return embed.build()

    async def run_matches(self):
        winners = []
        for match in self.brackets:
            if not match[1]:
                winners.append(match[0])
                continue

            match_channel = await self.create_match_channel(match[0], match[1])
            winner = await self.run_game(match_channel, match[0], match[1])
            winners.append(winner)
            await match_channel.delete()

        if len(winners) > 1:
            self.players = winners
            self.brackets = self.create_brackets()
            await self.message.channel.send("Next round starting!")
            await self.run_matches()
        else:
            await self.end_tournament(winners[0])

    async def create_match_channel(self, player1, player2):
        overwrites = {
            self.message.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            player1: discord.PermissionOverwrite(read_messages=True),
            player2: discord.PermissionOverwrite(read_messages=True),
            self.message.guild.me: discord.PermissionOverwrite(read_messages=True)
        }
        
        return await self.message.guild.create_text_channel(
            f"tournament-{player1.name}-vs-{player2.name}",
            overwrites=overwrites
        )

    async def run_game(self, channel, player1, player2):
        game_embed = EmbedBuilder(
            f"🎮 Tournament Match: {self.game_type}",
            f"{player1.mention} vs {player2.mention}"
        ).set_color(discord.Color.blue())
        
        await channel.send(embed=game_embed.build())
        
        if self.game_type == "rps":
            return await self.cog.rps_tournament_match(channel, player1, player2)
        elif self.game_type == "trivia":
            return await self.cog.trivia_tournament_match(channel, player1, player2)
       
        return player1  

    async def end_tournament(self, winner):
        embed = EmbedBuilder(
            "🎉 Tournament Complete!",
            f"Winner: {winner.mention}\n"
            "Congratulations!"
        ).set_color(discord.Color.gold())
        
        await self.message.channel.send(embed=embed.build())

    async def rps_tournament_match(self, channel, player1, player2):
        game_view = self.RPSView(player1, player2, rounds=5)  
        game_embed = EmbedBuilder(
            "🎮 Tournament Match: Rock Paper Scissors",
            f"{player1.mention} vs {player2.mention}\n"
            "First to 3 wins! Choose your move!"
        ).set_color(discord.Color.blue())
        
        message = await channel.send(embed=game_embed.build(), view=game_view)
        game_view.message = message
        
        await game_view.wait()
        return player1 if game_view.p1_score > game_view.p2_score else player2

    async def trivia_tournament_match(self, channel, player1, player2):
        questions = self.get_filtered_questions("random", "tournament")
        game_view = self.TriviaView(questions, "tournament", "tournament")
        game_view.tournament_players = {player1: 0, player2: 0}
        
        await channel.send(embed=game_view.create_question_embed())
        await game_view.wait()
        
        return max(game_view.tournament_players.items(), key=lambda x: x[1])[0]

    def create_rematch_view(self):
        view = discord.ui.View(timeout=60)
        
        async def rematch_callback(interaction):
            if interaction.user not in [self.player1, self.player2]:
                return
                
            if interaction.user == self.requesting_rematch:
                return
                
            if self.requesting_rematch:
                
                self.reset_game()
                await interaction.response.edit_message(view=self)
            else:
                self.requesting_rematch = interaction.user
                await interaction.response.send_message(f"{interaction.user.name} wants a rematch! Click rematch to accept!", ephemeral=True)

        rematch = discord.ui.Button(label="Rematch", style=discord.ButtonStyle.green, emoji="🔄")
        rematch.callback = rematch_callback
        view.add_item(rematch)
        
        return view

    async def handle_pattern(self, interaction):
        if not self.pattern_sequence:
            self.generate_pattern()
            await self.show_pattern(interaction)
            return

        button_id = int(interaction.data['custom_id'].split('_')[1])
        if button_id != self.pattern_sequence[self.current_step]:
            await self.pattern_failed(interaction)
            return

        self.current_step += 1
        if self.current_step >= len(self.pattern_sequence):
            await self.pattern_complete(interaction)
        else:
            await interaction.response.defer()

    async def handle_chain(self, interaction):
        if not self.start_time:
            await self.start_chain(interaction)
            return

        reaction_time = (time.time() - self.last_click) * 1000
        self.chain_times.append(reaction_time)
        
        if len(self.chain_times) >= 5:
            await self.end_chain(interaction)
        else:
            self.last_click = time.time()
            await self.update_chain_button(interaction)

    async def update_tournament_stats(self, winner, loser, game_type):
        if winner.id not in self.scores:
            self.scores[winner.id] = {'tournament_wins': 0, 'games': {}}
        
        self.scores[winner.id]['tournament_wins'] = self.scores[winner.id].get('tournament_wins', 0) + 1
        
        if game_type not in self.scores[winner.id]['games']:
            self.scores[winner.id]['games'][game_type] = {'wins': 0, 'matches': 0}
            
        self.scores[winner.id]['games'][game_type]['wins'] += 1
        self.scores[winner.id]['games'][game_type]['matches'] += 1
        
        if self.scores[winner.id]['tournament_wins'] == 5:
            await self.award_achievement(winner, "Tournament Master", "Win 5 tournaments")


class EnhancedAI:
    def __init__(self):
        self.context_memory = {}
        self.conversation_history = {}
        self.user_preferences = {}
        self.usage_stats = {}
        self.model_configs = {
            "creative": "gpt-4",
            "balanced": "gpt-3.5-turbo",
            "fast": "gpt-3.5-turbo-instruct"
        }
        
    async def process_with_context(self, user_id: int, input_text: str, context: str) -> str:
        if user_id not in self.context_memory:
            self.context_memory[user_id] = []
        self.context_memory[user_id].append((datetime.now(), input_text))
        return f"{context}\n{input_text}"

class AIControlPanel(discord.ui.View):
    def __init__(self, ai_commands):
        super().__init__(timeout=60)
        self.ai_commands = ai_commands

    @discord.ui.button(label="Model", style=ButtonStyle.primary)
    async def model_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(title="🤖 Model Selection")
        await interaction.response.edit_message(embed=embed, view=AiModelSelectView(self.ai_commands))

    @discord.ui.button(label="Personality", style=ButtonStyle.success)
    async def personality_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(title="🎭 Personality Settings")
        await interaction.response.edit_message(embed=embed, view=AiPersonalitySelectView(self.ai_commands))

    @discord.ui.button(label="Response", style=ButtonStyle.secondary)
    async def response_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(title="📝 Response Style")
        await interaction.response.edit_message(embed=embed, view=AiResponseSelectView(self.ai_commands))

class AiModelSelectView(discord.ui.View):
    def __init__(self, ai_commands):
        super().__init__(timeout=60)
        self.ai_commands = ai_commands

    @discord.ui.button(label="GPT-4", style=discord.ButtonStyle.primary)
    async def gpt4_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.ai_commands.ai_engine.model_configs['current'] = 'gpt-4'
        await interaction.response.send_message("Model set to GPT-4!", ephemeral=True)

    @discord.ui.button(label="GPT-3.5", style=discord.ButtonStyle.primary)
    async def gpt35_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.ai_commands.ai_engine.model_configs['current'] = 'gpt-3.5-turbo'
        await interaction.response.send_message("Model set to GPT-3.5!", ephemeral=True)

    @discord.ui.button(label="GPT-3.5 Instruct", style=discord.ButtonStyle.primary)
    async def gpt35_instruct_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.ai_commands.ai_engine.model_configs['current'] = 'gpt-3.5-turbo-instruct'
        await interaction.response.send_message("Model set to GPT-3.5 Instruct!", ephemeral=True)

    @discord.ui.button(label="Back", style=discord.ButtonStyle.danger)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.edit_message(
            embed=self.ai_commands.get_settings_embed(),
            view=AIControlPanel(self.ai_commands)
        )


class AiPersonalitySelectView(discord.ui.View):
    def __init__(self, ai_commands):
        super().__init__(timeout=60)
        self.ai_commands = ai_commands

    @discord.ui.button(label="Professional", style=discord.ButtonStyle.primary)
    async def professional_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Personality set to Professional!", ephemeral=True)

    @discord.ui.button(label="Casual", style=discord.ButtonStyle.primary)
    async def casual_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Personality set to Casual!", ephemeral=True)

    @discord.ui.button(label="Back", style=discord.ButtonStyle.danger)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.edit_message(
            embed=self.ai_commands.get_settings_embed(),
            view=AIControlPanel(self.ai_commands)
        )


class AiResponseSelectView(discord.ui.View):
    def __init__(self, ai_commands):
        super().__init__(timeout=60)
        self.ai_commands = ai_commands

    @discord.ui.button(label="Detailed", style=discord.ButtonStyle.primary)
    async def detailed_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Response style set to Detailed!", ephemeral=True)

    @discord.ui.button(label="Concise", style=discord.ButtonStyle.primary)
    async def concise_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("Response style set to Concise!", ephemeral=True)

    @discord.ui.button(label="Back", style=discord.ButtonStyle.danger)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.edit_message(
            embed=self.ai_commands.get_settings_embed(),
            view=AIControlPanel(self.ai_commands)
        )


class AiCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.client = openai(api_key=os.getenv('OPENAI_API_KEY'))
        self.ai_engine = EnhancedAI()
        self.cooldowns = {}
        self.load_custom_prompts()
        
    def load_custom_prompts(self):
        try:
            with open('config/ai_prompts.json', 'r') as f:
                self.custom_prompts = json.load(f)
        except FileNotFoundError:
            self.custom_prompts = {}

    @commands.group(invoke_without_command=True)
    async def ai(self, ctx):
        
        embed = discord.Embed(
            title="🤖 AI Command Center",
            description="Advanced AI Interaction Suite",
            color=discord.Color.blue()
        )
        embed.add_field(name="🗣️ Chat", value="`!ai chat <message>` - Interactive chat with context memory")
        embed.add_field(name="🎨 Create", value="`!ai create <prompt>` - Generate images with style control")
        embed.add_field(name="💭 Analyze", value="`!ai analyze <text>` - Deep content analysis")
        embed.add_field(name="🔮 Predict", value="`!ai predict <scenario>` - AI-powered predictions")
        embed.add_field(name="⚙️ Settings", value="`!ai settings` - Customize AI behavior")
        await ctx.send(embed=embed)

    @ai.command(name="chat")
    async def chat(self, ctx, *, message):
        
        async with ctx.typing():
            user_id = ctx.author.id
            
            enhanced_prompt = await self.ai_engine.process_with_context(
                user_id, 
                message,
                self.custom_prompts.get('chat_context', '')
            )
            
            try:
                response = self.client.chat.completions.create(
                    model=self.ai_engine.model_configs['balanced'],
                    messages=[
                        {"role": "system", "content": "You are a highly intelligent and witty AI assistant with deep knowledge and creative thinking capabilities."},
                        {"role": "user", "content": enhanced_prompt}
                    ],
                    temperature=0.8,
                    max_tokens=2000
                )
                
                answer = response.choices[0].message.content
                
                embed = discord.Embed(
                    title="💡 AI Response",
                    description=answer,
                    color=self.get_dynamic_color(answer)
                )
                embed.set_footer(text=f"Chatting with {ctx.author.name} | Context Memory: {len(self.ai_engine.context_memory.get(user_id, []))} messages")
                
                message = await ctx.send(embed=embed)
                await message.add_reaction("🔄")  
                await message.add_reaction("📝")  
                await message.add_reaction("💾")  
                
            except Exception as e:
                await self.handle_error(ctx, e)

    @ai.command(name="create")
    async def create(self, ctx, *, prompt):
        
        async with ctx.typing():
            try:
                style_match = re.match(r'\[(.*?)\](.*)', prompt)
                style = style_match.group(1) if style_match else "realistic"
                actual_prompt = style_match.group(2) if style_match else prompt
                
                enhanced_prompt = f"Create a {style} style image of {actual_prompt}"
                
                response = self.client.images.generate(
                    prompt=enhanced_prompt,
                    n=1,
                    size="1024x1024",
                    quality="hd"
                )
                
                embed = discord.Embed(
                    title="🎨 AI Creation",
                    description=f"**Style:** {style}\n**Prompt:** {actual_prompt}",
                    color=discord.Color.purple()
                )
                embed.set_image(url=response.data[0].url)
                
                message = await ctx.send(embed=embed)
                await message.add_reaction("🎨") 
                await message.add_reaction("✨")  
                await message.add_reaction("💾")  
                
            except Exception as e:
                await self.handle_error(ctx, e)

    @ai.command(name="analyze")
    async def analyze(self, ctx, *, content):
       
        async with ctx.typing():
            try:
                analyses = await asyncio.gather(
                    self.get_sentiment_analysis(content),
                    self.get_topic_analysis(content),
                    self.get_style_analysis(content)
                )
                
                embed = discord.Embed(
                    title="🔍 Content Analysis",
                    color=discord.Color.gold()
                )
                
                for analysis_type, result in zip(
                    ["Sentiment", "Topics", "Style"],
                    analyses
                ):
                    embed.add_field(
                        name=f"{analysis_type} Analysis",
                        value=result,
                        inline=False
                    )
                
                await ctx.send(embed=embed)
                
            except Exception as e:
                await self.handle_error(ctx, e)

    @ai.command(name="settings")
    async def ai_settings(self, ctx):
        embed = self.get_settings_embed()
        await ctx.send(embed=embed, view=AIControlPanel(self))

    def get_settings_embed(self):
        embed = discord.Embed(
            title="⚙️ AI Settings",
            description="Customize your AI experience",
            color=discord.Color.gold()
        )
        embed.add_field(
            name="🤖 Model Selection",
            value="• Creative (GPT-4)\n• Balanced (GPT-3.5)\n• Fast (GPT-3.5 Instruct)",
            inline=False
        )
        embed.add_field(
            name="🎭 AI Personality",
            value="• Professional\n• Casual\n• Humorous",
            inline=True
        )
        embed.add_field(
            name="📝 Response Style",
            value="• Detailed\n• Concise\n• Technical",
            inline=True
        )
        return embed

    async def get_sentiment_analysis(self, text):
        response = self.client.chat.completions.create(
            model=self.ai_engine.model_configs['fast'],
            messages=[
                {"role": "system", "content": "Analyze the sentiment and emotional tone of the following text."},
                {"role": "user", "content": text}
            ]
        )
        return response.choices[0].message.content

    async def get_topic_analysis(self, text):
        response = self.client.chat.completions.create(
            model=self.ai_engine.model_configs['fast'],
            messages=[
                {"role": "system", "content": "Identify main topics and themes in the following text."},
                {"role": "user", "content": text}
            ]
        )
        return response.choices[0].message.content

    async def get_style_analysis(self, text):
        response = self.client.chat.completions.create(
            model=self.ai_engine.model_configs['fast'],
            messages=[
                {"role": "system", "content": "Analyze the writing style and linguistic patterns."},
                {"role": "user", "content": text}
            ]
        )
        return response.choices[0].message.content

    def get_dynamic_color(self, text: str) -> discord.Color:
        
        sentiment_words = {
            'positive': ['good', 'great', 'awesome', 'excellent'],
            'negative': ['bad', 'poor', 'terrible', 'awful'],
            'neutral': ['okay', 'fine', 'normal', 'average']
        }
        
        text = text.lower()
        if any(word in text for word in sentiment_words['positive']):
            return discord.Color.green()
        elif any(word in text for word in sentiment_words['negative']):
            return discord.Color.red()
        return discord.Color.blue()

    async def handle_error(self, ctx, error):
        error_embed = discord.Embed(
            title="⚠️ Error Occurred",
            description=f"```{str(error)}```",
            color=discord.Color.red()
        )
        await ctx.send(embed=error_embed)



class ChannelManager(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def copychannel(self, ctx, channel_id: int):
        channel = ctx.guild.get_channel(channel_id)
        if not channel:
            await ctx.send("Channel not found!")
            return

        await ctx.send("Starting channel backup process... This may take a while.")

        channel_dir = f"channel_backup_{channel.id}"
        os.makedirs(channel_dir, exist_ok=True)

        channel_data = {
            "name": channel.name,
            "topic": channel.topic,
            "category": channel.category.id if channel.category else None,
            "position": channel.position,
            "slowmode_delay": channel.slowmode_delay,
            "nsfw": channel.nsfw,
            "permissions": []
        }

        for target, overwrite in channel.overwrites.items():
            perm_dict = {
                "id": target.id,
                "type": "role" if isinstance(target, discord.Role) else "member",
                "allow": overwrite.pair()[0].value,
                "deny": overwrite.pair()[1].value
            }
            channel_data["permissions"].append(perm_dict)

        with open(f"{channel_dir}/metadata.json", "w") as f:
            json.dump(channel_data, f)

        messages_data = []
        async for message in channel.history(limit=None, oldest_first=True):
            msg_data = {
                "content": message.content,
                "author": str(message.author),
                "author_id": message.author.id,
                "timestamp": message.created_at.isoformat(),
                "attachments": [],
                "embeds": [{
                    "title": embed.title,
                    "description": embed.description,
                    "color": embed.color.value if embed.color else None
                } for embed in message.embeds if embed.type == 'rich']
            }
            
            for attachment in message.attachments:
                file_path = f"{channel_dir}/{attachment.id}_{attachment.filename}"
                await attachment.save(file_path)
                msg_data["attachments"].append({
                    "filename": attachment.filename,
                    "backup_path": f"{attachment.id}_{attachment.filename}"
                })
            
            messages_data.append(msg_data)

        with open(f"{channel_dir}/messages.json", "w", encoding='utf-8') as f:
            json.dump(messages_data, f, ensure_ascii=False, indent=4)

        zip_filename = f"channel_backup_{channel.id}.zip"
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(channel_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, channel_dir)
                    zipf.write(file_path, arcname)

        await ctx.send("Channel backup complete!", file=discord.File(zip_filename))
        
        os.remove(zip_filename)
        for root, dirs, files in os.walk(channel_dir, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            os.rmdir(root)

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def pastechannel(self, ctx):
        if not ctx.message.attachments:
            await ctx.send("Please attach the channel backup ZIP file!")
            return

        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.zip'):
            await ctx.send("Please provide a valid channel backup ZIP file!")
            return

        await ctx.send("Starting channel restoration process... This may take a while.")

        await attachment.save("temp_backup.zip")
        temp_dir = "temp_channel_restore"
        os.makedirs(temp_dir, exist_ok=True)
        
        with zipfile.ZipFile("temp_backup.zip", 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        with open(f"{temp_dir}/metadata.json", "r") as f:
            channel_data = json.load(f)

        new_channel = await ctx.guild.create_text_channel(
            name=channel_data["name"],
            topic=channel_data["topic"],
            nsfw=channel_data["nsfw"],
            slowmode_delay=channel_data["slowmode_delay"]
        )

        for perm in channel_data["permissions"]:
            target = None
            if perm["type"] == "role":
                target = ctx.guild.get_role(perm["id"])
            else:
                target = ctx.guild.get_member(perm["id"])

            if target:
                allow = discord.Permissions(perm["allow"])
                deny = discord.Permissions(perm["deny"])
                overwrite = discord.PermissionOverwrite.from_pair(allow, deny)
                await new_channel.set_permissions(target, overwrite=overwrite)

        with open(f"{temp_dir}/messages.json", "r", encoding='utf-8') as f:
            messages_data = json.load(f)

        webhook = await new_channel.create_webhook(name="Channel Restore")
        
        for msg in messages_data:
            files = []
            for attachment in msg["attachments"]:
                file_path = f"{temp_dir}/{attachment['backup_path']}"
                if os.path.exists(file_path):
                    files.append(discord.File(file_path, filename=attachment["filename"]))
            
            try:
                await webhook.send(
                    content=msg["content"],
                    username=msg["author"],
                    files=files,
                    embeds=[discord.Embed.from_dict(embed) for embed in msg["embeds"]]
                )
            except Exception as e:
                print(f"Error restoring message: {e}")
                continue

        await webhook.delete()
        
        os.remove("temp_backup.zip")
        for root, dirs, files in os.walk(temp_dir, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            os.rmdir(root)

        await ctx.send(f"Channel has been restored: {new_channel.mention}")


class RoleBackup(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    @commands.has_permissions(manage_roles=True)
    async def copyrole(self, ctx, role_id: int):
        role = ctx.guild.get_role(role_id)
        if not role:
            await ctx.send("Role not found!")
            return

        await ctx.send("Starting role backup process...")

        role_data = {
            "name": role.name,
            "color": role.color.value,
            "hoist": role.hoist,
            "position": role.position,
            "mentionable": role.mentionable,
            "permissions": role.permissions.value,
            "icon": role.icon.url if role.icon else None,
            "members": [member.id for member in role.members]
        }

        backup_path = f"role_backup_{role.id}"
        os.makedirs(backup_path, exist_ok=True)

        if role.icon:
            async with aiohttp.ClientSession() as session:
                async with session.get(role.icon.url) as resp:
                    if resp.status == 200:
                        with open(f"{backup_path}/icon.png", 'wb') as f:
                            f.write(await resp.read())

        with open(f"{backup_path}/role_data.json", 'w') as f:
            json.dump(role_data, f, indent=4)

        zip_name = f"role_backup_{role.id}.zip"
        with zipfile.ZipFile(zip_name, 'w') as zipf:
            for root, dirs, files in os.walk(backup_path):
                for file in files:
                    zipf.write(os.path.join(root, file), file)

        await ctx.send("Role backup complete!", file=discord.File(zip_name))

        os.remove(zip_name)
        for root, dirs, files in os.walk(backup_path, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            os.rmdir(root)

    @commands.command()
    @commands.has_permissions(manage_roles=True)
    async def pasterole(self, ctx):
        if not ctx.message.attachments:
            await ctx.send("Please attach the role backup ZIP file!")
            return

        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.zip'):
            await ctx.send("Please provide a valid role backup ZIP file!")
            return

        await ctx.send("Starting role restoration process...")

        await attachment.save("temp_role.zip")
        temp_dir = "temp_role_restore"
        os.makedirs(temp_dir, exist_ok=True)

        with zipfile.ZipFile("temp_role.zip", 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        with open(f"{temp_dir}/role_data.json", 'r') as f:
            role_data = json.load(f)

        icon = None
        if os.path.exists(f"{temp_dir}/icon.png"):
            with open(f"{temp_dir}/icon.png", 'rb') as f:
                icon = f.read()

        new_role = await ctx.guild.create_role(
            name=role_data["name"],
            permissions=discord.Permissions(role_data["permissions"]),
            color=discord.Color(role_data["color"]),
            hoist=role_data["hoist"],
            mentionable=role_data["mentionable"]
        )

        if icon:
            await new_role.edit(display_icon=icon)

        restored_members = 0
        for member_id in role_data["members"]:
            member = ctx.guild.get_member(member_id)
            if member:
                try:
                    await member.add_roles(new_role)
                    restored_members += 1
                except:
                    continue

        await ctx.send(f"Role restored successfully!\n"
                      f"Role: {new_role.mention}\n"
                      f"Restored members: {restored_members}")

        
        os.remove("temp_role.zip")
        for root, dirs, files in os.walk(temp_dir, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            os.rmdir(root)


class QueueView(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=None)
        self.cog = cog

    @discord.ui.button(label="➕ Add to Queue", style=ButtonStyle.green)
    async def add_to_queue(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(QueueSearchModal(self.cog))

class QueueSearchModal(discord.ui.Modal):
    def __init__(self, cog):
        super().__init__(title="Add to Queue")
        self.cog = cog
        self.query = discord.ui.TextInput(
            label="Search for a song",
            placeholder="Enter song name or URL...",
            min_length=2,
            max_length=100
        )
        self.add_item(self.query)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        ctx = await interaction.client.get_context(interaction.message)
        
        song_info = await self.cog.get_song_info(str(self.query))
        if song_info:
            if ctx.guild.id not in self.cog.queues:
                self.cog.queues[ctx.guild.id] = []
            
            self.cog.queues[ctx.guild.id].append(song_info)
            await interaction.followup.send(f"Added to queue: {song_info['title']}", ephemeral=True)


class MusicControls(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=None)
        self.bot = bot

    @discord.ui.button(label="Join Voice", style=ButtonStyle.green)
    async def join_voice(self, interaction: discord.Interaction, button: discord.ui.Button):
        member = interaction.guild.get_member(interaction.user.id)
        if member and member.voice and member.voice.channel:
            await member.voice.channel.connect()
            await interaction.response.send_message(f"✅ Joined {member.voice.channel.name}")
            button.disabled = True
            await interaction.message.edit(view=self)
        else:
            await interaction.response.send_message("You need to be in a voice channel!", ephemeral=True)

    @discord.ui.button(label="Play Music", style=ButtonStyle.blurple)
    async def play_music(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(SearchModal(self.bot.get_cog("MusicPlayer")))

@commands.command()
async def music(self, ctx):
    
    embed = discord.Embed(title="🎵 Music Controls", color=discord.Color.blue())
    view = MusicControls(self.bot)
    await ctx.send(embed=embed, view=view)



class MusicPlayerView(discord.ui.View):
    def __init__(self, cog, ctx):
        super().__init__(timeout=None)
        self.cog = cog
        self.ctx = ctx
        self.current_page = 0

    @discord.ui.button(label="🔍", style=ButtonStyle.primary, custom_id="search", row=0)
    async def search(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(SearchModal(self.cog))

    @discord.ui.button(label="▶️", style=ButtonStyle.green, custom_id="play_pause", row=0)
    async def play_pause(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.guild.voice_client:
            await interaction.response.send_message("I'm not connected to a voice channel!", ephemeral=True)
            return
        
        if interaction.guild.voice_client.is_playing():
            interaction.guild.voice_client.pause()
            button.label = "⏸️"
            await interaction.response.edit_message(view=self)
        else:
            if not self.cog.now_playing.get(self.ctx.guild.id) and not interaction.guild.voice_client.is_paused() and self.cog.queues.get(self.ctx.guild.id):
                first_song = self.cog.queues[self.ctx.guild.id][0]
                try:
                    source = await discord.FFmpegOpusAudio.from_probe(
                        first_song['url'], 
                        **self.cog.FFMPEG_OPTIONS
                    )
                    interaction.guild.voice_client.play(
                        source, 
                        after=lambda e: asyncio.run_coroutine_threadsafe(
                            self.cog.play_next(self.ctx), 
                            self.cog.bot.loop
                        )
                    )
                    self.cog.now_playing[self.ctx.guild.id] = first_song['title']
                    button.label = "⏸️"
                except Exception as e:
                    print(f"Playback error: {e}")
                    await interaction.response.send_message("Failed to play the song.", ephemeral=True)
                    return
            else:
                interaction.guild.voice_client.resume()
                button.label = "⏸️"
            
            await interaction.response.edit_message(view=self)

    @discord.ui.button(label="⏭️", style=ButtonStyle.blurple, custom_id="skip", row=0)
    async def skip(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.guild.voice_client:
            await interaction.response.send_message("Not connected to a voice channel!", ephemeral=True)
            return

        if not self.cog.queues.get(interaction.guild.id):
            await interaction.response.send_message("No songs in queue!", ephemeral=True)
            return

        interaction.guild.voice_client.stop()
        
        next_song = self.cog.queues[interaction.guild.id][0]
        source = await discord.FFmpegOpusAudio.from_probe(next_song['url'], **self.cog.FFMPEG_OPTIONS)
        interaction.guild.voice_client.play(
            source,
            after=lambda e: asyncio.run_coroutine_threadsafe(
                self.cog.play_next(interaction.channel),
                self.cog.bot.loop
            )
        )
        self.cog.now_playing[interaction.guild.id] = next_song['title']
        
        await interaction.response.send_message(f"Skipped! Now playing: {next_song['title']}", ephemeral=True)

    @discord.ui.button(label="⚙️", style=ButtonStyle.gray, custom_id="settings", row=0)
    async def settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        settings_embed = discord.Embed(title="Settings Panel", color=discord.Color.blue())
        view = SettingsView(self.cog)
        await interaction.response.send_message(embed=settings_embed, view=view, ephemeral=True)

    @discord.ui.button(label="🎵 Queue", style=ButtonStyle.secondary, custom_id="view_queue", row=1)
    async def view_queue(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.cog.queues.get(self.ctx.guild.id):
            await interaction.response.send_message("Queue is empty!", ephemeral=True)
            return
            
        queue = self.cog.queues[self.ctx.guild.id]
        embed = discord.Embed(title="Current Queue", color=discord.Color.blue())
        
        for i, song in enumerate(queue, start=1):
            embed.add_field(
                name=f"{i}. {song['title']}", 
                value=f"Duration: {song['duration']}", 
                inline=False
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)


    @discord.ui.button(label="⏹️", style=ButtonStyle.red, custom_id="stop", row=0)
    async def stop(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.cog.leave(self.ctx)
        await interaction.message.delete()

    async def update_player_message(self, interaction: discord.Interaction):
        embed = discord.Embed(
            title="🎵 Music Player",
            description="Control your music experience!",
            color=discord.Color.brand_green()
        )
        if self.cog.now_playing.get(self.ctx.guild.id):
            embed.add_field(name="Now Playing", value=self.cog.now_playing[self.ctx.guild.id])
        await interaction.message.edit(embed=embed, view=self)


class SearchModal(discord.ui.Modal):
    def __init__(self, cog):
        super().__init__(title="Search Music")
        self.cog = cog
        self.query = discord.ui.TextInput(
            label="Search for a song",
            placeholder="Enter song name or URL...",
            min_length=2,
            max_length=100
        )
        self.add_item(self.query)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        ctx = await interaction.client.get_context(interaction.message)
        await self.cog.play(ctx, query=str(self.query))

class VolumeModal(discord.ui.Modal):
    def __init__(self, cog):
        super().__init__(title="Adjust Volume")
        self.cog = cog
        self.volume_input = discord.ui.TextInput(
            label="Volume (0-100)",
            placeholder="Enter a number between 0 and 100",
            min_length=1,
            max_length=3
        )
        self.add_item(self.volume_input)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            vol = float(self.volume_input.value)
            if 0 <= vol <= 100:
                if interaction.guild.voice_client:
                    
                    self.cog.volume = vol / 100
                    self.cog.FFMPEG_OPTIONS = {
                        'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
                        'options': f'-vn -filter:a volume={vol/100} -b:a 384k -bufsize 2048k'
                    }
                    
                    guild_id = interaction.guild.id
                    if interaction.guild.voice_client.is_playing() and self.cog.queues.get(guild_id):
                        current_song = self.cog.queues[guild_id][0]
                        
                        interaction.guild.voice_client.stop()
                        
                        source = await discord.FFmpegOpusAudio.from_probe(
                            current_song['url'],
                            **self.cog.FFMPEG_OPTIONS
                        )
                        
                        interaction.guild.voice_client.play(
                            source,
                            after=lambda e: self.cog.bot.loop.create_task(self.cog.play_next(interaction.channel))
                        )
                    
                    await interaction.response.send_message(f"🔊 Volume is now {vol}%", ephemeral=True)
                else:
                    await interaction.response.send_message("Join a voice channel first!", ephemeral=True)
            else:
                await interaction.response.send_message("Volume must be between 0 and 100", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Enter a valid number!", ephemeral=True)


class MusicPlayer(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.queues = {}
        self.now_playing = {}
        self.FFMPEG_OPTIONS = {
            'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
            'options': '-vn -b:a 384k -bufsize 2048k -ar 48000'
        }


        self.YDL_OPTIONS = {
            'format': 'bestaudio/best',
            'noplaylist': True,
            'nocheckcertificate': True,
            'ignoreerrors': False,
            'logtostderr': False,
            'quiet': True,
            'no_warnings': True,
            'default_search': 'auto',
            'source_address': '0.0.0.0'
        }
        self.volume = 1.0
        self.loop = False

    @commands.command()
    async def player(self, ctx):
        
        
        current_dir = os.path.dirname(os.path.abspath(__file__))
        
        try:
            subprocess.run(['ffmpeg', '-version'], capture_output=True)
        except FileNotFoundError:
            status_msg = await ctx.send("🎵 First-time setup: Installing FFmpeg...")
            if platform.system() == "Windows":
                url = "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip"
                zip_path = os.path.join(current_dir, "ffmpeg.zip")
                wget.download(url, zip_path)
                
                ffmpeg_dir = os.path.join(current_dir, "ffmpeg")
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                    zip_ref.extractall(ffmpeg_dir)
                
                for root, dirs, files in os.walk(ffmpeg_dir):
                    if 'ffmpeg.exe' in files:
                        ffmpeg_bin = root
                        break
                
                os.environ["PATH"] = ffmpeg_bin + os.pathsep + os.environ["PATH"]
                await status_msg.edit(content="✅ FFmpeg installed successfully! Starting music player...")

        embed = discord.Embed(
            title="🎵 Music Player",
            description="Control your music experience!",
            color=discord.Color.brand_green()
        )
        if self.now_playing.get(ctx.guild.id):
            embed.add_field(name="Now Playing", value=self.now_playing[ctx.guild.id])
        view = MusicPlayerView(self, ctx)
        await ctx.send(embed=embed, view=view)


    async def get_song_info(self, query):
        try:
            with yt_dlp.YoutubeDL(self.YDL_OPTIONS) as ydl:
                if not query.startswith('http'):
                    query = f"ytsearch:{query}"
                info = ydl.extract_info(query, download=False)
                if 'entries' in info:
                    info = info['entries'][0]
                
                return {
                    'title': info['title'],
                    'url': info['url'],
                    'thumbnail': info['thumbnail'],
                    'duration': str(timedelta(seconds=info['duration'])),
                    'webpage_url': info['webpage_url']
                }
        except Exception as e:
            print(f"Error in get_song_info: {e}")
            return None


    @commands.command()
    async def play(self, ctx, *, query):
        print("\n=== MUSIC PLAYER DEBUG ===")
        print(f"Command received from: {ctx.author}")
        print(f"Query: {query}")

        voice_state = ctx.author.voice
        if not voice_state or not voice_state.channel:
            return await ctx.send("🎵 Please join a voice channel first!")

        voice_channel = voice_state.channel
        print(f"Found Voice Channel: {voice_channel.name}")

        try:
            if not ctx.voice_client:
                await voice_channel.connect()
                print(f"✅ Connected to {voice_channel.name}")
            elif ctx.voice_client.channel != voice_channel:
                await ctx.voice_client.move_to(voice_channel)
                print(f"✅ Moved to {voice_channel.name}")

            print("\n=== SONG SEARCH ===")

            async with ctx.typing():
                try:
                    
                    search_query = f"ytsearch:{query}"
                    with yt_dlp.YoutubeDL(self.YDL_OPTIONS) as ydl:
                        info = ydl.extract_info(search_query, download=False)
                        if 'entries' in info and info['entries']:
                            video = info['entries'][0]
                            url = video['webpage_url']
                            title = video['title']
                            thumbnail = video['thumbnail']
                            duration = str(timedelta(seconds=video['duration']))
                            
                            print(f"Found: {title}")
                            url2 = video['url']
                            source = await discord.FFmpegOpusAudio.from_probe(url2, **self.FFMPEG_OPTIONS)

                    with yt_dlp.YoutubeDL(self.YDL_OPTIONS) as ydl:
                        info = ydl.extract_info(url, download=False)
                        url2 = info['url']
                        source = await discord.FFmpegOpusAudio.from_probe(url2, **self.FFMPEG_OPTIONS)

                        if ctx.guild.id not in self.queues:
                            self.queues[ctx.guild.id] = []

                        song_info = {
                            'title': title,
                            'url': url2,
                            'thumbnail': thumbnail,
                            'requester': ctx.author.name,
                            'duration': duration,
                            'requested_at': datetime.now().strftime("%H:%M:%S"),
                            'channel': ctx.channel.id
                        }

                        self.queues[ctx.guild.id].append(song_info)

                        if not ctx.voice_client.is_playing():
                            print("\n=== PLAYING SONG ===")
                            ctx.voice_client.play(source, after=lambda e: self.bot.loop.create_task(self.play_next(ctx)))
                            self.now_playing[ctx.guild.id] = title

                            embed = discord.Embed(
                                title="Now Playing 🎵",
                                description=title,
                                color=discord.Color.green()
                            )
                            embed.set_thumbnail(url=thumbnail)
                            embed.add_field(name="Duration", value=duration, inline=True)
                            embed.add_field(name="Requested by", value=ctx.author.name, inline=True)
                            embed.add_field(name="Time", value=song_info['requested_at'], inline=True)
                            embed.set_footer(text=f"Voice Channel: {voice_channel.name}")
                            
                            await ctx.send(embed=embed)
                        else:
                            print("\n=== ADDED TO QUEUE ===")
                            embed = discord.Embed(
                                title="Added to Queue 📝",
                                description=title,
                                color=discord.Color.blue()
                            )
                            embed.set_thumbnail(url=thumbnail)
                            embed.add_field(name="Duration", value=duration, inline=True)
                            embed.add_field(name="Requested by", value=ctx.author.name, inline=True)
                            embed.add_field(name="Position", value=str(len(self.queues[ctx.guild.id])), inline=True)
                            embed.set_footer(text=f"Queue Length: {len(self.queues[ctx.guild.id])}")
                            
                            await ctx.send(embed=embed)

                except Exception as e:
                    print(f"\n❌ Search Error: {str(e)}")
                    if 'youtube.com' in query or 'youtu.be' in query:
                        with yt_dlp.YoutubeDL(self.YDL_OPTIONS) as ydl:
                            info = ydl.extract_info(query, download=False)
                            url = info['url']
                            title = info['title']
                            thumbnail = info['thumbnail']
                            duration = str(datetime.timedelta(seconds=info['duration']))
                    else:
                        return await ctx.send("🔍 No results found! Try a different search term.")

        except Exception as e:
            print(f"\n❌ ERROR: {str(e)}")
            await ctx.send(f"⚠️ An error occurred while playing the song")
        
        finally:
            print("\n=== END OF COMMAND ===")


    async def play_next(self, ctx):
        if not self.queues.get(ctx.guild.id) or not self.queues[ctx.guild.id]:
            self.now_playing[ctx.guild.id] = None
            return

        if ctx.voice_client and ctx.voice_client.is_playing():
            ctx.voice_client.stop()

        try:
            next_song = self.queues[ctx.guild.id].pop(0)
            source = await discord.FFmpegOpusAudio.from_probe(next_song['url'], **self.FFMPEG_OPTIONS)
            
            def after_callback(error):
                if error:
                    print(f"Playback error: {error}")
                self.bot.loop.create_task(self.play_next(ctx))
                
            ctx.voice_client.play(source, after=after_callback)
            self.now_playing[ctx.guild.id] = next_song['title']
            
            embed = discord.Embed(title="Now Playing 🎵", description=next_song['title'], color=discord.Color.green())
            embed.set_thumbnail(url=next_song['thumbnail'])
            await ctx.send(embed=embed)
            
        except Exception as e:
            print(f"Error in play_next: {e}")


    @commands.command()
    async def skip(self, ctx):
        if not ctx.voice_client or not ctx.voice_client.is_playing():
            return await ctx.send("Nothing is playing!")
        ctx.voice_client.stop()
        await ctx.send("⏭️ Skipped!")

    @commands.command()
    async def leave(self, ctx):
        if ctx.voice_client:
            await ctx.voice_client.disconnect()
            self.queues[ctx.guild.id] = []
            self.now_playing[ctx.guild.id] = None
            await ctx.send("👋 Bye!")

class IdeaSubmissionConfig:
    def __init__(self):
        
        self.is_anonymous = True
        self.require_approval = True
        self.submission_channel_id = None  
        self.button_channel_id = None      
        self.min_chars = 20
        self.max_chars = 1000
        self.cooldown_minutes = 5
        self.max_submissions_per_day = 5
        
        self.button_color = ButtonStyle.green
        self.button_label = "Submit Idea"
        self.button_emoji = "💡"
        self.embed_color = discord.Color.blue()
        self.embed_title = "Submit Your Idea"
        self.embed_description = "Click below to submit your idea"
        self.modal_title = "New Idea Submission"
        
        self.idea_title_prefix = ""
        self.title_prefix = ""

        self.auto_thread = True
        self.thread_duration = 1440
        self.allow_voting = True
        self.categories = ["Feature", "Bug Fix", "Enhancement", "Other"]
        self.available_tags = ["Urgent", "QoL", "Technical", "Design"]
        self.max_tags = 3


class MainControlPanel(discord.ui.View):
    def __init__(self, configs):
        super().__init__(timeout=None)
        
        self.configs = {} if not isinstance(configs, dict) else configs
        self.current_system = "default"

    @discord.ui.select(
        placeholder="Select System Type",
        options=[
            discord.SelectOption(label="Bug Reports", value="bugs", emoji="🐛"),
            discord.SelectOption(label="Feature Requests", value="features", emoji="✨"),
            discord.SelectOption(label="Feedback", value="feedback", emoji="📝")
        ],
        row=0
    )
    async def select_system(self, interaction, select):
        self.current_system = select.values[0]
       
        if self.current_system not in self.configs:
            self.configs[self.current_system] = IdeaSubmissionConfig()
        await interaction.response.send_message(f"Now configuring: {self.current_system}", ephemeral=True)


    @discord.ui.button(label="Channel Setup", style=ButtonStyle.blurple, row=1)
    async def setup_channels(self, interaction, button):
        modal = ChannelSetupModal(self.configs[self.current_system])
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Appearance", style=ButtonStyle.primary, row=1)
    async def appearance(self, interaction, button):
        modal = AppearanceModal(self.configs[self.current_system])
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Submission Settings", style=ButtonStyle.primary, row=2)
    async def submission_settings(self, interaction, button):
        modal = SubmissionSettingsModal(self.configs[self.current_system])
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Categories & Tags", style=ButtonStyle.primary, row=2)
    async def categories(self, interaction, button):
        modal = CategoryModal(self.configs[self.current_system])
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Create Submit Button", style=ButtonStyle.success, row=3)
    async def create_button(self, interaction, button):
        config = self.configs[self.current_system]
        if not config.button_channel_id:
            await interaction.response.send_message("Please set up channels first!", ephemeral=True)
            return
            
        channel = interaction.guild.get_channel(config.button_channel_id)
        if channel:
            
            embed = discord.Embed(
                title=config.embed_title,
                description=config.embed_description,
                color=config.embed_color
            )
            
            class CustomSubmissionView(discord.ui.View):
                def __init__(self, config, cooldowns):
                    super().__init__(timeout=None)
                    self.config = config
                    self.cooldowns = cooldowns

                @discord.ui.button(
                    label=config.button_label,
                    emoji=config.button_emoji,
                    style=config.button_color
                )
                async def submit_idea(self, interaction, button):
                    modal = IdeaSubmissionModal(self.config)
                    await interaction.response.send_modal(modal)

            view = CustomSubmissionView(config, {})
            await channel.send(embed=embed, view=view)
            await interaction.response.send_message(f"Submit button created in {channel.mention}!", ephemeral=True)


class AppearanceModal(discord.ui.Modal):
    def __init__(self, config):
        super().__init__(title="Customize Appearance")
        self.config = config
        
        self.add_item(discord.ui.TextInput(
            label="Button Label",
            default=config.button_label
        ))
        self.add_item(discord.ui.TextInput(
            label="Button Emoji",
            default=config.button_emoji
        ))
        self.add_item(discord.ui.TextInput(
            label="Embed Title",
            default=config.embed_title
        ))
        self.add_item(discord.ui.TextInput(
            label="Embed Description",
            default=config.embed_description,
            style=discord.TextStyle.paragraph
        ))
        self.add_item(discord.ui.TextInput(
            label="Title Prefix & Color",
            placeholder="Prefix | #HexColor",
            default=f"{config.title_prefix} | {config.embed_color}",
            required=False
        ))

    async def on_submit(self, interaction):
        self.config.button_label = self.children[0].value
        self.config.button_emoji = self.children[1].value
        self.config.embed_title = self.children[2].value
        self.config.embed_description = self.children[3].value
        
        prefix_color = self.children[4].value.split("|")
        self.config.title_prefix = prefix_color[0].strip()
        if len(prefix_color) > 1:
            try:
                self.config.embed_color = discord.Color.from_str(prefix_color[1].strip())
            except:
                pass
                
        await interaction.response.send_message("Appearance updated!", ephemeral=True)

class SubmissionSettingsModal(discord.ui.Modal):
    def __init__(self, config):
        super().__init__(title="Submission Settings")
        self.config = config
        self.add_item(discord.ui.TextInput(
            label="Min Characters",
            default=str(config.min_chars)
        ))
        self.add_item(discord.ui.TextInput(
            label="Max Characters", 
            default=str(config.max_chars)
        ))
        self.add_item(discord.ui.TextInput(
            label="Cooldown (minutes)",
            default=str(config.cooldown_minutes)
        ))
        self.add_item(discord.ui.TextInput(
            label="Daily Submission Limit",
            default=str(config.max_submissions_per_day)
        ))

    async def on_submit(self, interaction):
        try:
            self.config.min_chars = int(self.children[0].value)
            self.config.max_chars = int(self.children[1].value)
            self.config.cooldown_minutes = int(self.children[2].value)
            self.config.max_submissions_per_day = int(self.children[3].value)
            await interaction.response.send_message("✨ Settings updated successfully!", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ Please enter valid numbers for all fields!", ephemeral=True)

class IdeaSubmissionView(discord.ui.View):
    def __init__(self, config, cooldowns):
        super().__init__(timeout=None)
        self.config = config
        self.cooldowns = cooldowns
        self.system_type = config.system_type if hasattr(config, 'system_type') else "default"

    @discord.ui.button(label="Submit Idea", emoji="💡", style=ButtonStyle.green)
    async def submit_idea(self, interaction, button):
        user_id = interaction.user.id
        current_time = datetime.now(timezone.utc)
        
        if user_id in self.cooldowns:
            time_diff = current_time - self.cooldowns[user_id]
            if time_diff.total_seconds() < self.config.cooldown_minutes * 60:
                remaining = self.config.cooldown_minutes * 60 - time_diff.total_seconds()
                await interaction.response.send_message(
                    f"Please wait {int(remaining)} seconds before submitting again!",
                    ephemeral=True
                )
                return

        self.cooldowns[user_id] = current_time
        modal = IdeaSubmissionModal(self.config)
        await interaction.response.send_modal(modal)


class IdeaSubmissionModal(discord.ui.Modal):
    def __init__(self, config):
        super().__init__(title="Submit Your Idea")
        self.config = config
        
        self.add_item(discord.ui.TextInput(
            label="Title",
            placeholder="Brief title for your idea",
            max_length=100,
            required=True
        ))
        self.add_item(discord.ui.TextInput(
            label="Description",
            placeholder="Detailed description...",
            style=discord.TextStyle.paragraph,
            min_length=self.config.min_chars,
            max_length=self.config.max_chars,
            required=True
        ))
        if self.config.categories:
            self.add_item(discord.ui.TextInput(
                label="Category",
                placeholder=f"Choose from: {', '.join(self.config.categories)}",
                required=True
            ))

    async def on_submit(self, interaction):
    
        await interaction.response.defer(ephemeral=True)
        
        try:
            if not self.config.submission_channel_id:
                await interaction.followup.send("Submission channel not configured!", ephemeral=True)
                return

            channel = interaction.guild.get_channel(self.config.submission_channel_id)
            if not channel:
                await interaction.followup.send("Cannot find submission channel!", ephemeral=True)
                return

            title = self.children[0].value
            if self.config.title_prefix and self.config.title_prefix.strip():
                title = f"{self.config.title_prefix}: {title}"

            embed = discord.Embed(
                title=title,
                description=self.children[1].value,
                color=self.config.embed_color,
                timestamp=datetime.now(timezone.utc)
            )
            
            if not self.config.is_anonymous:
                embed.set_author(name=interaction.user.display_name, icon_url=interaction.user.avatar.url)
            
            if len(self.children) > 2:
                embed.add_field(name="Category", value=self.children[2].value)
            
            msg = await channel.send(embed=embed)
            
            if self.config.allow_voting:
                await msg.add_reaction("👍")
                await msg.add_reaction("👎")
                
            if self.config.auto_thread:
                await msg.create_thread(
                    name=f"Discussion: {self.children[0].value[:50]}",
                    auto_archive_duration=self.config.thread_duration
                )
                
            await interaction.followup.send("Your idea has been submitted successfully! ✨", ephemeral=True)
            
        except Exception as e:
            await interaction.followup.send("There was an error submitting your idea. Please try again.", ephemeral=True)


class ChannelSetupModal(discord.ui.Modal):
    def __init__(self, config):
        super().__init__(title="Channel Setup")
        self.config = config
        self.add_item(discord.ui.TextInput(
            label="Click Submit to continue",
            placeholder="Click Submit to proceed to channel selection",
            required=False,
            style=discord.TextStyle.short
        ))

    async def on_submit(self, interaction):
        class ChannelSelect(discord.ui.View):
            def __init__(self, config, all_channels):
                super().__init__(timeout=300)
                self.config = config
                self.all_channels = all_channels
                self.button_selected = False
                self.ideas_selected = False
                self.current_search_button = ""
                self.current_search_ideas = ""
                self.button_options = []
                self.ideas_options = []
                self.selections = {
                    "button": {"id": None, "option": None},
                    "ideas": {"id": None, "option": None}
                }

                initial_options = [
                    discord.SelectOption(label=f"#{channel.name}", value=str(channel.id))
                    for channel in self.all_channels[:25]
                ]

                self.button_options = initial_options.copy()
                self.ideas_options = initial_options.copy()

                self.button_search.options = [discord.SelectOption(label="🔍 Search button channel...", value="search_button")]
                self.ideas_search.options = [discord.SelectOption(label="🔍 Search ideas channel...", value="search_ideas")]

                self.button_channel.options = self.button_options
                self.ideas_channel.options = self.ideas_options


            @discord.ui.button(label="Save Settings", style=ButtonStyle.green, row=4)
            async def save_button(self, interaction, button):
                if not self.button_selected or not self.ideas_selected:
                    embed = discord.Embed(
                        description = "⚠️ Please follow these steps:\n1. Search for the button and ideas channels FIRST\n2. Once both are found, select the button channel\n3. Then, select the ideas channel",
                        color=discord.Color.yellow()
                    )
                    await interaction.response.send_message(embed=embed, ephemeral=True)
                    return

                button_channel = interaction.guild.get_channel(self.config.button_channel_id)
                ideas_channel = interaction.guild.get_channel(self.config.submission_channel_id)
                embed = discord.Embed(
                    title="✨ Channel Setup Complete",
                    description=f"Submit Button Channel: #{button_channel.name}\nIdeas Channel: #{ideas_channel.name}",
                    color=discord.Color.green()
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)
                self.stop()

            @discord.ui.button(label="Cancel", style=ButtonStyle.red, row=4)
            async def cancel_button(self, interaction, button):
                embed = discord.Embed(
                    description="❌ Setup cancelled!",
                    color=discord.Color.red()
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)
                self.stop()

            def update_channel_options(self, search_term, for_button=True):
                filtered_channels = [
                    channel for channel in self.all_channels
                    if search_term.lower() in channel.name.lower()
                ][:25]
                
                options = [discord.SelectOption(label=f"#{channel.name}", value=str(channel.id))
                        for channel in filtered_channels]
                
                if for_button:
                    self.button_options = options
                else:
                    self.ideas_options = options
                return options

            @discord.ui.select(
                placeholder="🔍 Search Button Channel",
                min_values=0,
                max_values=1,
                options=[discord.SelectOption(label="Click to search...", value="search_button")],
                row=0
            )
            async def button_search(self, interaction, select):
                modal = SearchModal(self, True)
                await interaction.response.send_modal(modal)

            @discord.ui.select(
                placeholder="🔍 Search Ideas Channel",
                min_values=0,
                max_values=1,
                options=[discord.SelectOption(label="Click to search...", value="search_ideas")],
                row=2
            )
            async def ideas_search(self, interaction, select):
                modal = SearchModal(self, False)
                await interaction.response.send_modal(modal)

            @discord.ui.select(
                placeholder="1️⃣ Select Submit Button Channel",
                options=[],
                row=1
            )
            async def button_channel(self, interaction, select):
                channel_id = int(select.values[0])
                channel = interaction.guild.get_channel(channel_id)
                self.config.button_channel_id = channel_id
                self.button_selected = True
                
                self.selections["button"] = {
                    "id": channel_id,
                    "option": discord.SelectOption(
                        label=f"#{channel.name}",
                        value=str(channel_id)
                    )
                }
                
                embed = discord.Embed(
                    description=f"✅ Submit button channel set to: #{channel.name}",
                    color=discord.Color.green()
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)

            @discord.ui.select(
                placeholder="2️⃣ Select Ideas Channel",
                options=[],
                row=3
            )
            async def ideas_channel(self, interaction, select):
                channel_id = int(select.values[0])
                channel = interaction.guild.get_channel(channel_id)
                self.config.submission_channel_id = channel_id
                self.ideas_selected = True
                
                self.selections["ideas"] = {
                    "id": channel_id,
                    "option": discord.SelectOption(
                        label=f"#{channel.name}",
                        value=str(channel_id)
                    )
                }
                
                embed = discord.Embed(
                    description=f"✅ Ideas channel set to: #{channel.name}",
                    color=discord.Color.green()
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)

            async def update_view(self, interaction, search_term, for_button=True):
                if for_button:
                    self.current_search_button = search_term
                    button_options = self.update_channel_options(search_term, True)
                    
                    if self.selections["button"]["option"]:
                        button_options = [self.selections["button"]["option"]] + [
                            opt for opt in button_options 
                            if opt.value != str(self.selections["button"]["id"])
                        ]
                    self.button_channel.options = button_options
                    
                    if self.selections["ideas"]["option"]:
                        self.ideas_channel.options = [self.selections["ideas"]["option"]] + [
                            opt for opt in self.ideas_channel.options 
                            if opt.value != str(self.selections["ideas"]["id"])
                        ]
                else:
                    self.current_search_ideas = search_term
                    ideas_options = self.update_channel_options(search_term, False)
                    
                    if self.selections["ideas"]["option"]:
                        ideas_options = [self.selections["ideas"]["option"]] + [
                            opt for opt in ideas_options 
                            if opt.value != str(self.selections["ideas"]["id"])
                        ]
                    self.ideas_channel.options = ideas_options
                    
                    if self.selections["button"]["option"]:
                        self.button_channel.options = [self.selections["button"]["option"]] + [
                            opt for opt in self.button_channel.options 
                            if opt.value != str(self.selections["button"]["id"])
                        ]

                await interaction.response.edit_message(view=self)

        view = ChannelSelect(self.config, interaction.guild.text_channels)
        embed = discord.Embed(
            title="🔧 Channel Setup",
            description = "1. First, search for both the button and ideas channels using the search options\n2. Once both are found, select the button channel and the ideas channel\n3. Save your settings when done",

            color=discord.Color.blue()
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)


        class SearchModal(discord.ui.Modal):
            def __init__(self, view, for_button=True):
                super().__init__(title="Search Channels")
                self.view = view
                self.for_button = for_button
                self.add_item(discord.ui.TextInput(
                    label="Search Term",
                    placeholder="Enter channel name to search",
                    required=True,
                    max_length=100
                ))

            async def on_submit(self, interaction):
                await self.view.update_view(interaction, self.children[0].value, self.for_button)


class IdeaSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.configs = {}
        self.cooldowns = {}
        self.guild_configs = {} 

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ideasystem(self, ctx):
        if ctx.guild.id not in self.configs:
            self.configs[ctx.guild.id] = IdeaSubmissionConfig()
            
        embed = discord.Embed(
            title="Idea System Control Panel",
            description="Configure your idea submission system",
            color=self.configs[ctx.guild.id].embed_color
        )
        view = MainControlPanel(self.configs[ctx.guild.id])
        await ctx.send(embed=embed, view=view)

class CategoryModal(discord.ui.Modal):
    def __init__(self, config):
        super().__init__(title="Categories & Tags Configuration")
        self.config = config
        
        self.add_item(discord.ui.TextInput(
            label="Categories (comma-separated)",
            placeholder="Feature, Bug Fix, Enhancement, Other",
            default=", ".join(config.categories),
            style=discord.TextStyle.paragraph
        ))
        
        self.add_item(discord.ui.TextInput(
            label="Available Tags (comma-separated)",
            placeholder="Urgent, QoL, Technical, Design",
            default=", ".join(config.available_tags),
            style=discord.TextStyle.paragraph
        ))
        
        self.add_item(discord.ui.TextInput(
            label="Max Tags Per Submission",
            placeholder="Enter a number (1-10)",
            default=str(config.max_tags)
        ))

    async def on_submit(self, interaction):
        self.config.categories = [cat.strip() for cat in self.children[0].value.split(",")]
        self.config.available_tags = [tag.strip() for tag in self.children[1].value.split(",")]
        try:
            self.config.max_tags = int(self.children[2].value)
        except ValueError:
            self.config.max_tags = 3
        
        await interaction.response.send_message("Categories and tags updated!", ephemeral=True)

class ChannelSelectModal(discord.ui.Modal):
    def __init__(self, config):
        super().__init__(title="Select Channel")
        self.config = config
        self.add_item(discord.ui.TextInput(
            label="Channel ID",
            placeholder="Enter the channel ID where to create the submit button",
            required=True
        ))

    async def on_submit(self, interaction):
        channel_id = int(self.children[0].value)
        channel = interaction.guild.get_channel(channel_id)
        if channel:
            embed = discord.Embed(
                title=self.config.embed_title,
                description=self.config.embed_description,
                color=self.config.embed_color
            )
            view = IdeaSubmissionView(self.config, {})
            await channel.send(embed=embed, view=view)
            await interaction.response.send_message(f"Submit button created in {channel.mention}!", ephemeral=True)
        else:
            await interaction.response.send_message("Invalid channel ID!", ephemeral=True)




class MoodTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.mood_data = {}
        self.opted_users = {}
        self.mood_configs = {}
        self.anonymous_users = set()
        self.mood_role_name = "Mood Tracker"
        self.mood_streaks = {}
        self.custom_moods = {}
        self.load_mood_data()
        
        self.check_moods_task = tasks.loop(seconds=20)(self.check_moods)
        self.update_analytics_task = tasks.loop(hours=24)(self.update_analytics)
        
        self.check_moods_task.start()
        self.update_analytics_task.start()

    @commands.group(name="setup_mood")
    @commands.has_permissions(administrator=True)
    async def setup_mood(self, ctx):
        
        embed = discord.Embed(
            title="🎯 Quick Setup Guide",
            description=(
                "**1. Role Setup**\n"
                "→ `!set_mood_role @Role`\n"
                "• Everyone with this role gets mood prompts\n"
                "• Members can still opt-in/out individually\n\n"
                "**2. Channel Setup**\n"
                "→ `!set_mood_channel #channel`\n"
                "• All mood responses get logged here\n"
                "• Anonymous responses hide usernames\n\n"
                "**3. Timing Setup**\n"
                "→ `!mood config`\n"
                "• Choose how often prompts are sent\n"
                "• Options: Daily, Twice Daily, Weekly, Test Mode\n\n"
                "**4. Testing**\n"
                "→ `!test_mood @Role`\n"
                "• Sends immediate test prompt to role members\n"
                "• Verify everything works correctly\n\n"
                "**5. Monitor**\n"
                "→ `!analyze_moods`\n"
                "• View all recorded moods\n"
                "• Track participation and trends"
            ),
            color=discord.Color.green()
        )
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def set_mood_channel(self, ctx, channel: discord.TextChannel):
        
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.mood_configs:
            self.mood_configs[guild_id] = {}
        
        self.mood_configs[guild_id]['log_channel'] = channel.id
        self.save_mood_data()
        
        embed = discord.Embed(
            title="✅ Mood Channel Set",
            description=f"Mood logs will be sent to {channel.mention}\n\n" \
                    f"• Anonymous users: Only mood will be shown\n" \
                    f"• Non-anonymous users: Name and mood will be shown",
            color=discord.Color.green()
        )
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def export_mood_data(self, ctx):
        
        buffer = io.StringIO()
        json.dump({
            'moods': self.mood_data,
            'configs': self.mood_configs,
            'anonymous': list(self.anonymous_users)
        }, buffer, indent=4)
        buffer.seek(0)
        
        file = discord.File(fp=buffer, filename='mood_data_backup.json')
        await ctx.send("Here's your mood tracking data backup:", file=file)
        buffer.close()

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def import_mood_data(self, ctx):
        
        if not ctx.message.attachments:
            return await ctx.send("Please attach a mood_data_backup.json file!")
            
        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.json'):
            return await ctx.send("Please provide a valid JSON file!")
            
        try:
            data = json.loads(await attachment.read())
            self.mood_data = data.get('moods', {})
            self.mood_configs = data.get('configs', {})
            self.anonymous_users = set(data.get('anonymous', []))
            self.save_mood_data()
            await ctx.send("✅ Mood tracking data imported successfully!")
        except Exception as e:
            await ctx.send(f"❌ Error importing data: {str(e)}")


    async def button_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user_id:
            return
            
        custom_id = interaction.data["custom_id"]
        guild_id = str(interaction.guild.id)
        user_id = str(interaction.user.id)

        if custom_id == "toggle_anon":
            if interaction.user.id in self.cog.anonymous_users:
                self.cog.anonymous_users.remove(interaction.user.id)
                await interaction.response.send_message("Anonymous mode disabled!", ephemeral=True)
            else:
                self.cog.anonymous_users.add(interaction.user.id)
                await interaction.response.send_message("Anonymous mode enabled!", ephemeral=True)
            return

        if guild_id not in self.cog.mood_data:
            self.cog.mood_data[guild_id] = {}
        if user_id not in self.cog.mood_data[guild_id]:
            self.cog.mood_data[guild_id][user_id] = []
        
        mood_entry = {
            'mood': custom_id,
            'timestamp': datetime.now().isoformat(),
            'anonymous': interaction.user.id in self.cog.anonymous_users
        }
        
        self.cog.mood_data[guild_id][user_id].append(mood_entry)
        self.cog.save_mood_data()
        
        await interaction.response.send_message(f"Mood recorded: {custom_id.title()}!", ephemeral=True)
        
        if guild_id in self.cog.mood_configs and 'log_channel' in self.cog.mood_configs[guild_id]:
            channel_id = self.cog.mood_configs[guild_id]['log_channel']
            channel = self.cog.bot.get_channel(channel_id)

            
            if channel:
                is_anonymous = interaction.user.id in self.cog.anonymous_users
                user_display = "Anonymous User" if is_anonymous else interaction.user.display_name
                
                embed = discord.Embed(
                    title="🌟 New Mood Entry",
                    description=f"**User:** {user_display}\n**Mood:** {custom_id.title()}",
                    color=discord.Color.blue(),
                    timestamp=datetime.now()
                )
                try:
                    await channel.send(embed=embed)
                except discord.HTTPException:
                    pass


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def analyze_moods(self, ctx):
        
        guild_id = str(ctx.guild.id)
        
        mood_data = self.mood_data.get(guild_id, {})
        
        if not mood_data:
            await ctx.send("No mood data recorded yet!")
            return
            
        embed = discord.Embed(
            title="🔍 Mood Analysis",
            description="Recent mood records:",
            color=discord.Color.blue()
        )
        
        total_entries = 0
        for user_id, moods in mood_data.items():
            if not moods:
                continue
                
            member = ctx.guild.get_member(int(user_id))
            if not member:
                continue
                
            user_moods = {}  
            for mood in moods[-5:]:
                is_anonymous = mood.get('anonymous', False)
                if is_anonymous not in user_moods:
                    user_moods[is_anonymous] = []
                timestamp = datetime.fromisoformat(mood['timestamp']).strftime("%Y-%m-%d %H:%M")
                user_moods[is_anonymous].append(f"• {mood['mood']} ({timestamp})")
            
            for is_anonymous, mood_list in user_moods.items():
                name = "Anonymous User" if is_anonymous else member.display_name
                embed.add_field(
                    name=f"{name}'s Moods",
                    value="\n".join(mood_list),
                    inline=False
                )
                total_entries += 1
        
        if total_entries == 0:
            await ctx.send("No mood data to display!")
            return
            
        await ctx.send(embed=embed)


    async def update_analytics(self):
        
        for guild_id, config in self.mood_configs.items():
            if not config.get('analytics_channel'):
                continue
                
            guild = self.bot.get_guild(int(guild_id))
            if not guild:
                continue
                
            channel = guild.get_channel(config['analytics_channel'])
            if channel:
                total_moods = len(self.mood_data.get(guild_id, {}))
                active_users = len(self.opted_users.get(guild_id, []))
                
                embed = discord.Embed(
                    title="📊 Mood Tracking Analytics",
                    description=f"Total Moods: {total_moods}\nActive Users: {active_users}",
                    color=discord.Color.blue()
                )
                await channel.send(embed=embed)


    class MoodSelectionView(discord.ui.View):
        def __init__(self, cog, user_id):
            super().__init__()
            self.cog = cog
            self.user_id = user_id
            
            moods = [
                ("🎭 Toggle Anonymous", "toggle_anon", discord.ButtonStyle.secondary),
                ("😊 Happy", "happy", discord.ButtonStyle.success),
                ("😐 Neutral", "neutral", discord.ButtonStyle.secondary),
                ("☹️ Sad", "sad", discord.ButtonStyle.danger),
                ("😴 Tired", "tired", discord.ButtonStyle.primary),
                ("😤 Stressed", "stressed", discord.ButtonStyle.danger)
            ]
            
            for label, custom_id, style in moods:
                button = discord.ui.Button(
                    label=label,
                    custom_id=custom_id,
                    style=style
                )
                button.callback = self.button_callback
                self.add_item(button)

        async def button_callback(self, interaction: discord.Interaction):
            print("Button callback started")
            if interaction.user.id != self.user_id:
                print(f"User ID mismatch: {interaction.user.id} vs {self.user_id}")
                return
                    
            custom_id = interaction.data["custom_id"]
            
            guild_id = next(iter(self.cog.mood_configs.keys()))
            user_id = str(interaction.user.id)
            print(f"Processing: Custom ID: {custom_id}, Guild ID: {guild_id}, User ID: {user_id}")

            if custom_id == "toggle_anon":
                print("Toggle anonymous mode")
                if interaction.user.id in self.cog.anonymous_users:
                    self.cog.anonymous_users.remove(interaction.user.id)
                    print(f"Disabled anonymous mode for user {user_id}")
                    await interaction.response.send_message("Anonymous mode disabled!", ephemeral=True)
                else:
                    self.cog.anonymous_users.add(interaction.user.id)
                    print(f"Enabled anonymous mode for user {user_id}")
                    await interaction.response.send_message("Anonymous mode enabled!", ephemeral=True)
                return

            print("Processing mood selection")
            
            if guild_id not in self.cog.mood_data:
                print(f"Creating new mood data entry for guild {guild_id}")
                self.cog.mood_data[guild_id] = {}
            if user_id not in self.cog.mood_data[guild_id]:
                print(f"Creating new mood data entry for user {user_id}")
                self.cog.mood_data[guild_id][user_id] = []
            
            mood_entry = {
                'mood': custom_id,
                'timestamp': datetime.now().isoformat(),
                'anonymous': interaction.user.id in self.cog.anonymous_users
            }
            print(f"Saving mood entry: {mood_entry}")
            self.cog.mood_data[guild_id][user_id].append(mood_entry)
            self.cog.save_mood_data()
            
            await interaction.response.send_message(f"Mood recorded: {custom_id.title()}!", ephemeral=True)
            
            print(f"Checking mood configs for guild {guild_id}")
            print(f"Current mood configs: {self.cog.mood_configs}")
            
            if guild_id in self.cog.mood_configs:
                print(f"Found guild config: {self.cog.mood_configs[guild_id]}")
                if 'log_channel' in self.cog.mood_configs[guild_id]:
                    channel_id = self.cog.mood_configs[guild_id]['log_channel']
                    print(f"Found log channel ID: {channel_id}")
                    channel = self.cog.bot.get_channel(channel_id)
                    try:
                        channel = self.cog.bot.get_channel(channel_id)
                        if not channel:
                            print(f"Could not find channel with ID {channel_id}")
                            return
                    except Exception as e:
                        print(f"Error getting channel: {e}")
                        return
                    
                    if channel:
                        print(f"Successfully got channel: {channel.name}")
                        is_anonymous = interaction.user.id in self.cog.anonymous_users
                        user_name = "Anonymous User" if is_anonymous else interaction.user.display_name
                        print(f"Sending mood entry for {'anonymous' if is_anonymous else 'named'} user")
                        
                        embed = discord.Embed(
                            title="🌟 New Mood Entry",
                            description=f"**User:** {user_name}\n**Mood:** {custom_id.title()}",
                            color=discord.Color.blue(),
                            timestamp=datetime.now()
                        )
                        try:
                            await channel.send(embed=embed)
                            print("Successfully sent mood entry to channel")
                        except discord.HTTPException as e:
                            print(f"Failed to send to channel: {e}")
                    else:
                        print(f"Could not find channel with ID {channel_id}")
                else:
                    print("No log_channel configured for this guild")
            else:
                print(f"Guild {guild_id} not found in mood configs")


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def set_mood_role(self, ctx, role: discord.Role):
        
        guild_id = str(ctx.guild.id)
        
        if guild_id not in self.mood_configs:
            self.mood_configs[guild_id] = {}
        
        self.mood_configs[guild_id]['mood_role'] = role.id
        self.mood_configs[guild_id]['enabled'] = True
        self.save_mood_data()
        
        embed = discord.Embed(
            title="✅ Mood Role Set",
            description=f"Members with {role.mention} will receive mood prompts",
            color=discord.Color.green()
        )
        await ctx.send(embed=embed)

    @commands.group(name="mood", invoke_without_command=True)
    async def mood(self, ctx):
        
        embed = discord.Embed(
            title="🌟 Mood Tracking System",
            description=(
                "**User Commands:**\n"
                "`!mood optin` - Join mood tracking\n"
                "`!mood streak` - Check your streak\n"
                "`!mood anon` - Toggle anonymous mode\n\n"
                "**Admin Commands:**\n"
                "`!set_mood_role @Role` - Set role for notifications\n"
                "`!set_mood_channel #channel` - Set mood logging channel\n"
                "`!mood config` - Configure notification timing\n"
                "`!analyze_moods` - View all mood entries\n"
                "`!test_mood @Role` - Test notifications"
            ),
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def test_mood(self, ctx, role: discord.Role):
        
        members = [member for member in ctx.guild.members if role in member.roles]
        for member in members:
            await self.send_mood_prompt(member)
        await ctx.send(f"✅ Sent test prompts to {len(members)} members!")

    async def send_mood_prompt(self, member):
        
        embed = discord.Embed(
            title="🌟 Mood Check",
            description="How are you feeling?",
            color=discord.Color.blue()
        )
        view = self.MoodSelectionView(self, member.id)
        try:
            await member.send(embed=embed, view=view)
        except discord.Forbidden:
            pass

    async def check_moods(self):
        
        current_time = time.time()
        
        for guild_id, config in self.mood_configs.items():
            if not config.get('enabled', False):
                continue
                
            last_check = config.get('last_check', 0)
            interval = config.get('notification_interval', 24)  
            if current_time - last_check < (interval * 3600):  
                continue
                
            guild = self.bot.get_guild(int(guild_id))
            if not guild:
                continue
                
            role_id = config.get('mood_role')
            if not role_id:
                continue
                
            role = guild.get_role(role_id)
            if not role:
                continue
                
            for member in role.members:
                try:
                    await self.send_mood_prompt(member)
                except discord.Forbidden:
                    continue
                    
            self.mood_configs[guild_id]['last_check'] = current_time
            self.save_mood_data()

    def load_mood_data(self):
        
        try:
            with open('data/mood_data.json', 'r') as f:
                data = json.load(f)
                self.mood_data = data.get('moods', {})
                self.opted_users = data.get('users', {})
                self.mood_configs = data.get('configs', {})
                self.anonymous_users = set(data.get('anonymous', []))
                self.mood_streaks = data.get('streaks', {})
                self.custom_moods = data.get('custom_moods', {})
        except FileNotFoundError:
            self.save_mood_data()

    def save_mood_data(self):
        
        data = {
            'moods': self.mood_data,
            'users': self.opted_users,
            'configs': self.mood_configs,
            'anonymous': list(self.anonymous_users),
            'streaks': self.mood_streaks,
            'custom_moods': self.custom_moods
        }
        with open('data/mood_data.json', 'w') as f:
            json.dump(data, f, indent=4)



    @mood.command(name="config")
    @commands.has_permissions(administrator=True)
    async def config(self, ctx):
        
        class ConfigView(discord.ui.View):
            def __init__(self, original_self):
                super().__init__()
                self.original_self = original_self
                
            @discord.ui.select(
                placeholder="Select frequency",
                options=[
                    discord.SelectOption(label="Daily", value="24"),
                    discord.SelectOption(label="Twice Daily", value="12"),
                    discord.SelectOption(label="Weekly", value="168"),
                    discord.SelectOption(label="Test Mode (20s)", value="0.006")
                ]
            )
            async def select_callback(self, interaction: discord.Interaction, select: discord.ui.Select):
                hours = float(select.values[0])
                guild_id = str(interaction.guild_id)
                if guild_id not in self.original_self.mood_configs:
                    self.original_self.mood_configs[guild_id] = {}
                self.original_self.mood_configs[guild_id]['notification_interval'] = hours
                self.original_self.save_mood_data()
                await interaction.response.send_message(
                    f"Notification interval set to {hours} hours!", 
                    ephemeral=True
                )

        embed = discord.Embed(
            title="⚙️ Mood Tracking Configuration",
            description="Select notification frequency:",
            color=discord.Color.blue()
        )
        
        view = ConfigView(self)
        await ctx.send(embed=embed, view=view)


class RatingSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.ratings_data = {}  
        self.load_ratings()

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def exportrating(self, ctx):
        await ctx.message.delete()
        try:
            export_data = json.dumps(self.ratings_data, indent=4)
            with open('rating_backup.json', 'w') as f:
                f.write(export_data)
            await ctx.send("✨ Here's your rating system backup!", file=discord.File('rating_backup.json'), ephemeral=True)
            os.remove('rating_backup.json')
        except Exception as e:
            await ctx.send(f"✨ Export failed: {str(e)}", ephemeral=True)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def importrating(self, ctx):
        await ctx.message.delete()
        if not ctx.message.attachments:
            return await ctx.send("✨ Please attach a rating backup file!", ephemeral=True)
        try:
            attachment = ctx.message.attachments[0]
            if not attachment.filename.endswith('.json'):
                return await ctx.send("✨ Please provide a JSON file!", ephemeral=True)
            content = await attachment.read()
            import_data = json.loads(content)
            self.ratings_data = import_data
            self.save_ratings()
            await ctx.send("✨ Rating system data imported successfully!", ephemeral=True)
        except json.JSONDecodeError:
            await ctx.send("✨ Invalid JSON file format!", ephemeral=True)
        except Exception as e:
            await ctx.send(f"✨ Import failed: {str(e)}", ephemeral=True)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ratingsetup(self, ctx):
        
        button = discord.ui.Button(label="Setup Rating System", style=discord.ButtonStyle.primary, emoji="✨")
            
        async def button_callback(interaction):
            modal = self.RatingSetup(self)
            await interaction.response.send_modal(modal)
            
        button.callback = button_callback
        view = discord.ui.View()
        view.add_item(button)
            
        await ctx.message.delete()  
        await ctx.send("Click below to create your rating panel! ✨", view=view, ephemeral=True)

    def load_ratings(self):
        try:
            with open('ratings.json', 'r') as f:
                self.ratings_data = json.load(f)
        except FileNotFoundError:
            self.ratings_data = {}

    def save_ratings(self):
        with open('ratings.json', 'w') as f:
            json.dump(self.ratings_data, f, indent=4)


    class DeleteRatingModal(discord.ui.Modal):
        def __init__(self, cog):
            super().__init__(title="Delete Rating Panel")
            self.cog = cog
            self.add_item(discord.ui.TextInput(
                label="Panel ID",
                placeholder="Enter the panel ID to delete"
            ))

        async def on_submit(self, interaction):
            panel_id = self.children[0].value
            if panel_id in self.cog.ratings_data:
             
                for channel in interaction.guild.text_channels:
                    try:
                        message = await channel.fetch_message(int(panel_id))
                        if message:
                            await message.delete()
                            break
                    except:
                        continue
                        
                del self.cog.ratings_data[panel_id]
                self.cog.save_ratings()
                await interaction.response.send_message(f"✨ Rating panel {panel_id} deleted!", ephemeral=True)
            else:
                await interaction.response.send_message("✨ Panel ID not found!", ephemeral=True)

    class EditRatingModal(discord.ui.Modal):
        def __init__(self, cog):
            super().__init__(title="Edit Rating Panel")
            self.cog = cog
            self.add_item(discord.ui.TextInput(
                label="Panel ID",
                placeholder="Enter the panel ID to edit"
            ))
            self.add_item(discord.ui.TextInput(
                label="New Title",
                placeholder="Enter new title (leave empty to keep current)",
                required=False
            ))
            self.add_item(discord.ui.TextInput(
                label="New Description",
                placeholder="Enter new description (leave empty to keep current)",
                required=False
            ))

        async def on_submit(self, interaction):
            panel_id = self.children[0].value
            new_title = self.children[1].value
            new_desc = self.children[2].value

            if panel_id not in self.cog.ratings_data:
                return await interaction.response.send_message("✨ Panel ID not found!", ephemeral=True)

            try:
                channel_id = None
                message = None
                for channel in interaction.guild.text_channels:
                    try:
                        message = await channel.fetch_message(int(panel_id))
                        if message:
                            break
                    except:
                        continue

                if message:
                    embed = message.embeds[0]
                    if new_title:
                        embed.title = new_title
                    if new_desc:
                        current_desc = embed.description.split("**Stats:**")
                        embed.description = f"{new_desc}\n\n**Stats:**{current_desc[1]}"
                    
                    await message.edit(embed=embed)
                    await interaction.response.send_message("✨ Rating panel updated!", ephemeral=True)
                else:
                    await interaction.response.send_message("✨ Couldn't find the rating panel message!", ephemeral=True)
            except Exception as e:
                await interaction.response.send_message(f"✨ Error updating panel: {str(e)}", ephemeral=True)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def seerating(self, ctx):
        await ctx.message.delete()
        if not self.ratings_data:
            return await ctx.send("✨ No rating panels exist yet!", ephemeral=True)

        embed = discord.Embed(
            title="📊 Rating Panels Overview",
            color=discord.Color.blue()
        )

        for message_id, ratings in self.ratings_data.items():
            total_votes = len(ratings)
            avg_rating = sum(float(r) for r in ratings.values()) / total_votes if total_votes > 0 else 0
            embed.add_field(
                name=f"ID: {message_id}",
                value=f"Votes: {total_votes} | Average: {avg_rating:.2f}",
                inline=False
            )

        view = discord.ui.View()
        delete_btn = discord.ui.Button(label="Delete Panel", style=discord.ButtonStyle.danger, emoji="🗑️")
        edit_btn = discord.ui.Button(label="Edit Panel", style=discord.ButtonStyle.primary, emoji="✏️")
        
        async def delete_callback(interaction):
            modal = self.DeleteRatingModal(self)
            await interaction.response.send_modal(modal)
            
        async def edit_callback(interaction):
            modal = self.EditRatingModal(self)
            await interaction.response.send_modal(modal)
            
        delete_btn.callback = delete_callback
        edit_btn.callback = edit_callback
        view.add_item(delete_btn)
        view.add_item(edit_btn)
        
        await ctx.send(embed=embed, view=view)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ratingrefresh(self, ctx, panel_id: str):
        await ctx.message.delete()
        if panel_id not in self.ratings_data:
            return await ctx.send("✨ Rating panel not found!", ephemeral=True)

        channel_id = None
        message = None
        
        for channel in ctx.guild.text_channels:
            try:
                message = await channel.fetch_message(int(panel_id))
                if message:
                    break
            except:
                continue

        if not message:
            return await ctx.send("✨ Couldn't find the rating panel message!")

        ratings = self.ratings_data[panel_id]
        avg_rating = sum(float(r) for r in ratings.values()) / len(ratings)
        
        embed = message.embeds[0]
        embed.description = f"{embed.description.split('**Stats:**')[0]}\n\n**Stats:**\n• Average: {avg_rating:.2f}\n• Total Ratings: {len(ratings)}"
        
        await message.edit(embed=embed)
        await ctx.send("✨ Rating panel refreshed successfully!")


    class RatingView(discord.ui.View):
        def __init__(self, title, description, button_color, embed_color, rating_type, channel_id, cog):
            super().__init__(timeout=None)
            self.title = title
            self.description = description
            
            color_map = {
                'red': discord.ButtonStyle.danger,
                'green': discord.ButtonStyle.success,
                'blue': discord.ButtonStyle.primary,
                'gray': discord.ButtonStyle.secondary,
                'blurple': discord.ButtonStyle.primary,
                'danger': discord.ButtonStyle.danger,
                'success': discord.ButtonStyle.success,
                'primary': discord.ButtonStyle.primary,
                'secondary': discord.ButtonStyle.secondary
            }
            self.button_color = color_map.get(button_color.lower(), discord.ButtonStyle.secondary)
            self.embed_color = embed_color
            self.rating_type = rating_type
            self.channel_id = channel_id
            self.cog = cog

            if self.rating_type == "stars":
                star_emojis = ["⭐", "🌟", "✨", "💫", "⚡"]
                for i, emoji in enumerate(star_emojis, 1):
                    btn = discord.ui.Button(
                        label=f"{i}",
                        emoji=emoji,
                        style=self.button_color,
                        custom_id=f"rate_{i}",
                        row=0
                    )
                    btn.callback = self.rate_callback
                    self.add_item(btn)
            
            elif self.rating_type == "numbers":
                for i in range(1, 11):
                    btn = discord.ui.Button(
                        label=f"{i}",
                        style=self.button_color,
                        custom_id=f"rate_{i}",
                        row=(i-1) // 5
                    )
                    btn.callback = self.rate_callback
                    self.add_item(btn)
            
            elif self.rating_type == "percent":
                emojis = ["💔", "❤️‍🩹", "💝", "💖", "💗"]
                for p, emoji in zip([0, 25, 50, 75, 100], emojis):
                    btn = discord.ui.Button(
                        label=f"{p}%",
                        emoji=emoji,
                        style=self.button_color,
                        custom_id=f"rate_{p}",
                        row=0
                    )
                    btn.callback = self.rate_callback
                    self.add_item(btn)

            view_ratings = discord.ui.Button(
                label="Statistics",
                emoji="📊",
                style=discord.ButtonStyle.secondary,
                custom_id="view_ratings",
                row=2
            )
            view_ratings.callback = self.view_ratings_callback
            
            refresh = discord.ui.Button(
                label="Refresh",
                emoji="🔄",
                style=discord.ButtonStyle.secondary,
                custom_id="refresh",
                row=2
            )
            refresh.callback = self.refresh_callback
            
            self.add_item(view_ratings)
            self.add_item(refresh)


        async def create_stats_embed(self, ratings, title="📊 Rating Statistics"):
            avg_rating = sum(float(r) for r in ratings) / len(ratings)
            rating_counts = {}
            for r in ratings:
                rating_counts[float(r)] = rating_counts.get(float(r), 0) + 1
            
            max_count = max(rating_counts.values())
            distribution = []
            for r, count in sorted(rating_counts.items()):
                bar_length = int((count / max_count) * 10)
                bar = "█" * bar_length + "░" * (10 - bar_length)
                percentage = (count/len(ratings))*100
                
                if self.rating_type == "stars":
                    rating_display = "⭐" * int(r)
                elif self.rating_type == "percent":
                    rating_display = f"{int(r)}% {'💖' if r == 100 else '💝' if r >= 75 else '❤️' if r >= 50 else '💔'}"
                else:
                    rating_display = f"Rating {r}"
                    
                distribution.append(f"{rating_display}\n`{bar}` {count} votes ({percentage:.1f}%)")

            embed = discord.Embed(
                title=title,
                description="\n\n".join(distribution),
                color=self.embed_color
            )
            embed.add_field(name="Average Rating", value=f"📊 {avg_rating:.2f}", inline=True)
            embed.add_field(name="Total Votes", value=f"📈 {len(ratings)}", inline=True)
            return embed

        async def rate_callback(self, interaction: discord.Interaction):
            rating = interaction.data['custom_id'].split("_")[1]
            message_id = str(interaction.message.id)
            user_id = str(interaction.user.id)
            
            if message_id in self.cog.ratings_data and user_id in self.cog.ratings_data[message_id]:
                return await interaction.response.send_message("You've already rated this! ✨", ephemeral=True)
            
            if message_id not in self.cog.ratings_data:
                self.cog.ratings_data[message_id] = {}
            
            self.cog.ratings_data[message_id][user_id] = rating
            self.cog.save_ratings()

            embed = discord.Embed(
                title=self.title,
                description=f"{self.description}\n\n**Stats:**",
                color=self.embed_color
            )
            
            ratings = self.cog.ratings_data[message_id].values()
            avg_rating = sum(float(r) for r in ratings) / len(ratings)
            
            rating_counts = {}
            for r in ratings:
                rating_counts[float(r)] = rating_counts.get(float(r), 0) + 1
            
            embed.add_field(name="Average Rating", value=f"📊 {avg_rating:.2f}", inline=True)
            embed.add_field(name="Total Votes", value=f"📈 {len(ratings)}", inline=True)
            
            await interaction.message.edit(embed=embed, view=self)
            
            rating_display = f"{'⭐' * int(rating)}" if self.rating_type == "stars" else f"{rating}{'%' if self.rating_type == 'percent' else ''}"
            await interaction.response.send_message(f"Rating submitted: {rating_display} ✨", ephemeral=True)


        async def view_ratings_callback(self, interaction: discord.Interaction):
            message_id = str(interaction.message.id)
            if message_id not in self.cog.ratings_data:
                return await interaction.response.send_message("No ratings yet! Be the first to rate! ✨", ephemeral=True)
            
            embed = await self.create_stats_embed(self.cog.ratings_data[message_id].values(), "📊 Detailed Rating Distribution")
            await interaction.response.send_message(embed=embed, ephemeral=True)

        async def refresh_callback(self, interaction: discord.Interaction):
            if not interaction.user.guild_permissions.administrator:
                return await interaction.response.send_message("Only administrators can refresh! ✨", ephemeral=True)
            
            message_id = str(interaction.message.id)
            if message_id not in self.cog.ratings_data:
                return await interaction.response.send_message("No ratings to refresh! ✨", ephemeral=True)
            
            embed = await self.create_stats_embed(self.cog.ratings_data[message_id].values())
            await interaction.message.edit(embed=embed, view=self)
            await interaction.response.send_message("Rating panel refreshed! ✨", ephemeral=True)

    class RatingSetup(discord.ui.Modal):
        def __init__(self, cog, **defaults):
            super().__init__(title="✨ Rating System Setup")
            self.cog = cog
            self.add_item(discord.ui.TextInput(
                label="Title",
                placeholder="Enter your rating title",
                default=defaults.get('default_title', '')
            ))
            self.add_item(discord.ui.TextInput(
                label="Description",
                placeholder="Enter rating description",
                default=defaults.get('default_desc', '')
            ))
            self.add_item(discord.ui.TextInput(
                label="Button Color",
                placeholder="red/green/blue/blurple",
                default=defaults.get('default_color', '')
            ))
            self.add_item(discord.ui.TextInput(
                label="Embed Color (hex)",
                placeholder="#ff0000",
                default=defaults.get('default_embed', '')
            ))
            self.add_item(discord.ui.TextInput(
                label="Rating Type & Channel",
                placeholder="stars/numbers/percent #channel",
                default=f"{defaults.get('default_type', '')} {defaults.get('default_channel', '')}"
            ))

        async def on_submit(self, interaction: discord.Interaction):
            title = self.children[0].value
            description = self.children[1].value
            button_color = self.children[2].value.lower()
            embed_color = int(self.children[3].value.strip("#"), 16)
            
            rating_info = self.children[4].value.split()
            rating_type = rating_info[0].lower()
            channel_mention = rating_info[1] if len(rating_info) > 1 else None
            
            channel_id = int(channel_mention.strip('<#>')) if channel_mention else interaction.channel.id
            channel = interaction.guild.get_channel(channel_id)
            
            if not channel:
                return await interaction.response.send_message("Invalid channel! ❌", ephemeral=True)

            embed = discord.Embed(title=title, description=description, color=embed_color)
            view = self.cog.RatingView(title, description, button_color, embed_color, rating_type, channel_id, self.cog)
            
            await channel.send(embed=embed, view=view)
            if channel.id != interaction.channel.id:
                await interaction.response.send_message(f"Rating panel created in {channel.mention}! ✨", ephemeral=True)
            else:
                await interaction.response.send_message("Rating panel created! ✨", ephemeral=True)


class BotVerificationSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.whitelist_file = "data/whitelisted_bots.json"
        
        os.makedirs(os.path.dirname(self.whitelist_file), exist_ok=True)
        
        self.bot_whitelist = self.load_whitelist()
        
        owner_id_str = os.getenv('BOT_OWNER_ID', '0')
        try:
            self.owner_id = int(owner_id_str)
        except ValueError:
            print(f"Invalid BOT_OWNER_ID in environment: {owner_id_str}")
            self.owner_id = 0
        
        self.log_channel_id = os.getenv("BOT_JOIN_LOG_CHANNEL")
        self.monitor_joins = os.getenv("MONITOR_BOT_JOINS", "True").lower() == "true"
        
        self.bot_log_channels = {}
        
        self.whitelist_attempts = {}
        self.MAX_ATTEMPTS = 5
        self.ATTEMPT_RESET = 300  

    def load_whitelist(self):
        
        whitelist = set()
        
        env_bots = os.getenv('WHITELISTED_BOTS', '')
        for bot_id in env_bots.split(','):
            if bot_id.strip():
                try:
                    whitelist.add(int(bot_id.strip()))
                except ValueError:
                    pass
        
        try:
            if os.path.exists(self.whitelist_file):
                with open(self.whitelist_file, 'r') as f:
                    file_whitelist = json.load(f)
                    for bot_id in file_whitelist:
                        whitelist.add(int(bot_id))
        except Exception as e:
            print(f"Error loading whitelist file: {e}")
        
        self.save_whitelist(whitelist)
        return whitelist

    def save_whitelist(self, whitelist=None):
        
        try:
            if whitelist is None:
                whitelist = self.bot_whitelist
            with open(self.whitelist_file, 'w') as f:
                json.dump(list(whitelist), f)
        except Exception as e:
            print(f"Error saving whitelist: {e}")

    def validate_bot_id(self, bot_id: int) -> bool:
        
        if not (17 <= len(str(bot_id)) <= 20):
            return False
        
        discord_epoch = 1420070400000
        timestamp = ((bot_id >> 22) + discord_epoch) / 1000
        return discord_epoch/1000 <= timestamp <= time.time() and bot_id != 0

    @commands.Cog.listener()
    async def on_member_join(self, member):
        if not member.bot:
            return
            
        if member.id in self.bot_whitelist:
            return  
        
        try:
            
            await member.kick(reason="Bot not in whitelist")
            
            embed = discord.Embed(
                title="🤖 Unauthorized Bot Detected",
                description=(
                    f"**Bot:** {member.name} (`{member.id}`)\n"
                    f"**Action:** Kicked\n"
                    f"**Reason:** Not in whitelist\n"
                    f"**Guild:** {member.guild.name}\n"
                    f"**Time:** <t:{int(time.time())}:F>"
                ),
                color=discord.Color.red(),
                timestamp=datetime.now(timezone.utc)
            )
            embed.set_footer(text=f"Security Event ID: {hex(member.id)}")
            
            if str(member.guild.id) in self.bot_log_channels:
                channel_id = self.bot_log_channels[str(member.guild.id)]
                channel = member.guild.get_channel(channel_id)
                if channel:
                    await channel.send(embed=embed)
            
            if self.monitor_joins:
                await self.send_bot_join_notification(member)
                
        except discord.Forbidden:
            
            if str(member.guild.id) in self.bot_log_channels:
                channel = member.guild.get_channel(self.bot_log_channels[str(member.guild.id)])
                if channel:
                    await channel.send(
                        embed=discord.Embed(
                            title="⚠️ Permission Error",
                            description="Failed to kick unauthorized bot due to missing permissions",
                            color=discord.Color.orange()
                        )
                    )

    async def send_bot_join_notification(self, member):
       
        if not self.monitor_joins:
            return
            
        if not self.log_channel_id or self.log_channel_id.lower() == "none":
            
            private_channels = []
            public_channels = []
            
            for channel in member.guild.text_channels:
                
                if not channel.permissions_for(member.guild.me).send_messages:
                    continue
                    
                everyone_role = member.guild.default_role
                if not channel.permissions_for(everyone_role).view_channel:
                    private_channels.append(channel)
                else:
                    public_channels.append(channel)
            
            if private_channels:
                log_channel = random.choice(private_channels)
            elif member.guild.system_channel:
                log_channel = member.guild.system_channel
            elif public_channels:
                log_channel = random.choice(public_channels)
            else:
              
                return
        else:
            try:
                log_channel = self.bot.get_channel(int(self.log_channel_id))
                if not log_channel:
                   
                    if member.guild.system_channel:
                        log_channel = member.guild.system_channel
                    else:
                        
                        for channel in member.guild.text_channels:
                            if channel.permissions_for(member.guild.me).send_messages:
                                log_channel = channel
                                break
                        else:
                            return 
            except ValueError:
            
                if member.guild.system_channel:
                    log_channel = member.guild.system_channel
                else:
                   
                    for channel in member.guild.text_channels:
                        if channel.permissions_for(member.guild.me).send_messages:
                            log_channel = channel
                            break
                    else:
                        return  
        
        try:
            cmd_prefix = self.bot.command_prefix
            if callable(cmd_prefix):
                cmd_prefix = cmd_prefix(self.bot, None)
            if isinstance(cmd_prefix, list):
                cmd_prefix = cmd_prefix[0]
        except:
            cmd_prefix = "!" 
        
        embed = discord.Embed(
            title="🤖 Bot Joined Server",
            description=f"A new bot has joined the server: **{member.name}**",
            color=discord.Color.orange()
        )
        
        embed.add_field(
            name="Bot Information",
            value=f"**Name:** {member.name}\n**ID:** {member.id}\n**Created:** {member.created_at.strftime('%Y-%m-%d')}"
        )
        
        embed.add_field(
            name="Whitelist Instructions",
            value=f"If you added this bot, please whitelist it using:\n```{cmd_prefix}whitelist_bot {member.id}```",
            inline=False
        )
        
        avatar_url = member.avatar.url if hasattr(member, 'avatar') else member.avatar_url
        embed.set_thumbnail(url=avatar_url)
        embed.set_footer(text="Unwhitelisted bots may be removed for security")
        
        await log_channel.send(embed=embed)

    @commands.command(name="whitelist_bot")
    async def whitelist_bot(self, ctx, bot_id: int):
        
        if ctx.author.id != self.owner_id:
            return await ctx.send(
                embed=discord.Embed(
                    title="❌ Access Denied",
                    description=f"Only the bot owner can use this command.",
                    color=discord.Color.red()
                )
            )

        current_time = time.time()
        if ctx.author.id in self.whitelist_attempts:
            attempts, last_attempt = self.whitelist_attempts[ctx.author.id]
            if current_time - last_attempt < self.ATTEMPT_RESET:
                if attempts >= self.MAX_ATTEMPTS:
                    return await ctx.send(
                        embed=discord.Embed(
                            title="🚫 Rate Limited",
                            description=f"Please wait {int(self.ATTEMPT_RESET - (current_time - last_attempt))} seconds",
                            color=discord.Color.red()
                        )
                    )
                self.whitelist_attempts[ctx.author.id] = (attempts + 1, current_time)
            else:
                self.whitelist_attempts[ctx.author.id] = (1, current_time)
        else:
            self.whitelist_attempts[ctx.author.id] = (1, current_time)

        if not self.validate_bot_id(bot_id):
            return await ctx.send(
                embed=discord.Embed(
                    title="❌ Invalid Bot ID",
                    description="The provided ID is not a valid Discord bot ID",
                    color=discord.Color.red()
                )
            )

        try:
           
            bot_user = await self.bot.fetch_user(bot_id)
            if not bot_user.bot:
                raise ValueError("Provided ID belongs to a user, not a bot")
            
            self.bot_whitelist.add(bot_id)
            self.save_whitelist()
            
            await ctx.send(
                embed=discord.Embed(
                    title="✅ Bot Whitelisted",
                    description=f"**Bot:** {bot_user.name}\n**ID:** `{bot_id}`\n**Added by:** {ctx.author.mention}",
                    color=discord.Color.green()
                ).set_thumbnail(url=bot_user.display_avatar.url)
            )
            
        except (discord.NotFound, discord.HTTPException, ValueError) as e:
            await ctx.send(
                embed=discord.Embed(
                    title="❌ Verification Failed",
                    description=str(e),
                    color=discord.Color.red()
                )
            )

    @commands.command(name="botlogs")
    @commands.has_permissions(administrator=True)
    async def set_bot_logs(self, ctx, channel: discord.TextChannel = None):
      
        if channel is None:
            if str(ctx.guild.id) in self.bot_log_channels:
                del self.bot_log_channels[str(ctx.guild.id)]
                embed = discord.Embed(
                    title="🤖 Bot Logs Disabled",
                    description="Bot join logging has been turned off.",
                    color=discord.Color.red()
                )
            else:
                embed = discord.Embed(
                    title="ℹ️ No Channel Set",
                    description="Please specify a channel to enable bot join logging.",
                    color=discord.Color.blue()
                )
        else:
            self.bot_log_channels[str(ctx.guild.id)] = channel.id
            embed = discord.Embed(
                title="🤖 Bot Logs Channel Set",
                description=f"Unauthorized bot joins will be logged in {channel.mention}",
                color=discord.Color.green()
            )
        
        await ctx.send(embed=embed)

    @commands.command(name="whitelisted")
    @commands.has_permissions(administrator=True)
    async def list_whitelisted(self, ctx):
        
        if not self.bot_whitelist:
            return await ctx.send(
                embed=discord.Embed(
                    title="📝 Whitelisted Bots",
                    description="No bots are currently whitelisted",
                    color=discord.Color.blue()
                )
            )

        whitelisted_bots = []
        for bot_id in self.bot_whitelist:
            try:
                bot_user = await self.bot.fetch_user(bot_id)
                whitelisted_bots.append(f"• {bot_user.name} (`{bot_id}`)")
            except:
                whitelisted_bots.append(f"• Unknown Bot (`{bot_id}`)")

        await ctx.send(
            embed=discord.Embed(
                title="📝 Whitelisted Bots",
                description="\n".join(whitelisted_bots),
                color=discord.Color.blue()
            )
        )

class PersistentVerifyView(View):
    def __init__(self, role_id=None, button_label="Verify", button_style=discord.ButtonStyle.green):
        super().__init__(timeout=None)
        if role_id:
            button = Button(label=button_label, style=button_style, custom_id=f"verify_{role_id}")
            button.callback = self.verify_callback
            self.add_item(button)

    async def verify_callback(self, interaction: discord.Interaction):
        guild = interaction.guild
        member = interaction.user
        custom_id = interaction.data.get("custom_id", "")

        if "_" in custom_id:
            try:
                role_id = int(custom_id.split("_")[1])
                role = guild.get_role(role_id)
                
                if role:
                    if role not in member.roles:
                        await member.add_roles(role)
                        await interaction.response.send_message("✅ You have been verified!", ephemeral=True)
                    else:
                        await interaction.response.send_message("⚠️ You are already verified!", ephemeral=True)
                else:
                    await interaction.response.send_message("❌ Role not found! Please contact an admin.", ephemeral=True)
            except ValueError:
                await interaction.response.send_message("✅ Verification successful!", ephemeral=True)
        else:
            await interaction.response.send_message("✅ Verification successful!", ephemeral=True)


class VerificationSetup(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.guild_settings = {}

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def verifysetup(self, ctx):
        
        def check(msg):
            return msg.author == ctx.author and msg.channel == ctx.channel

        await ctx.send("📌 Mention the role for verification (e.g., `@Verified`):")
        role_msg = await self.bot.wait_for("message", check=check)
        
        if not role_msg.role_mentions:
            await ctx.send("❌ Please mention a valid role.")
            return

        role = role_msg.role_mentions[0] 
        role_id = role.id

        await ctx.send("📌 Enter the embed title:")
        title_msg = await self.bot.wait_for("message", check=check)
        title = title_msg.content

        await ctx.send("📌 Enter the embed description:")
        desc_msg = await self.bot.wait_for("message", check=check)
        description = desc_msg.content

        await ctx.send("📌 Enter the embed color (hex code, e.g., `#ff0000`):")
        color_msg = await self.bot.wait_for("message", check=check)
        
        try:
            color = int(color_msg.content.strip("#"), 16)
        except ValueError:
            await ctx.send("❌ Invalid hex color code. Defaulting to `#3498db` (blue).")
            color = 0x3498db  

        await ctx.send("📌 Enter the embed footer text:")
        footer_msg = await self.bot.wait_for("message", check=check)
        footer = footer_msg.content

        await ctx.send("📌 Enter the button label (e.g., `Verify Now!`):")
        button_msg = await self.bot.wait_for("message", check=check)
        button_label = button_msg.content

        await ctx.send("📌 Enter the button color (`green`, `red`, `grey`):")
        button_color_msg = await self.bot.wait_for("message", check=check)
        button_color = button_color_msg.content.lower()

        button_style_mapping = {
            "green": discord.ButtonStyle.green,
            "red": discord.ButtonStyle.red,
            "grey": discord.ButtonStyle.grey
        }
        
        button_style = button_style_mapping.get(button_color)
        if not button_style:
            await ctx.send("❌ Invalid button color. Defaulting to `grey`.")
            button_style = discord.ButtonStyle.grey

        await ctx.send("📌 (Optional) Enter an image/GIF link or type `skip`:")
        image_msg = await self.bot.wait_for("message", check=check)
        image_url = image_msg.content if image_msg.content.lower() != "skip" else None

        embed = discord.Embed(title=title, description=description, color=color)
        embed.set_footer(text=footer)
        if image_url:
            embed.set_image(url=image_url)

        self.guild_settings[ctx.guild.id] = {
            "embed": embed,
            "role_id": role_id,
            "button_label": button_label,
            "button_style": button_style
        }

        view = PersistentVerifyView(role_id, button_label, button_style)

        await ctx.send(embed=embed, view=view)





class LevelingSystem(commands.Cog):                         
    def __init__(self, bot):
        self.bot = bot
        self.owner_id = int(os.getenv('BOT_OWNER_ID'))
        self.user_data: Dict[int, Dict[int, Dict]] = {}  
        self.roles: Dict[int, Dict[int, int]] = {}       
        self.achievements: Dict[int, Dict[str, Dict]] = {}  
        self.xp_decay_rate = 0.01
        self.xp_gain_range = (15, 25)
        self.xp_multipliers: Dict[int, Dict[int, float]] = {} 
        self.data_file = "data/leveling_data.json"
        self.leaderboard_channels: Dict[int, int] = {}    
        self.announcement_channels: Dict[int, int] = {}   
        self.load_data()
        self.bot.loop.create_task(self.update_leaderboard_task())
        self.bot.loop.create_task(self.xp_decay_task())

    def load_data(self):
        
        if os.path.exists(self.data_file):
            with open(self.data_file, 'r') as f:
                data = json.load(f)
                
                self.user_data = {
                    int(guild_id): {
                        int(user_id): user_data 
                        for user_id, user_data in guild_data.items()
                    } for guild_id, guild_data in data.get('user_data', {}).items()
                }
                self.roles = data.get('roles', {})
                self.achievements = data.get('achievements', {})
                self.xp_multipliers = data.get('xp_multipliers', {})
                self.leaderboard_channels = data.get('leaderboard_channels', {})
                self.announcement_channels = data.get('announcement_channels', {})

    def save_data(self):
            
            
            cleaned_user_data = {}
            for guild_id, guild_data in self.user_data.items():
                cleaned_user_data[str(guild_id)] = {
                    str(user_id): user_data
                    for user_id, user_data in guild_data.items()
                }

            with open(self.data_file, 'w') as f:
                json.dump({
                    'user_data': cleaned_user_data,
                    'roles': self.roles,
                    'achievements': self.achievements,
                    'xp_multipliers': self.xp_multipliers,
                    'leaderboard_channels': self.leaderboard_channels,
                    'announcement_channels': self.announcement_channels
                }, f, indent=4)

    def calculate_level(self, xp: int) -> int:
        
        return int((xp / 100) ** 0.5)  

    def xp_for_next_level(self, level: int) -> int:
        
        return (level + 1) ** 2 * 100

    async def add_xp(self, user_id: int, guild_id: int):
        
        
        xp_gain = random.randint(*self.xp_gain_range)
        
        multiplier = float(self.xp_multipliers.get(guild_id, {}).get(str(user_id), 1.0))
        if isinstance(multiplier, dict):
            multiplier = 1.0
        xp_gain = int(xp_gain * multiplier)

        if guild_id not in self.user_data:
            self.user_data[guild_id] = {}
        if user_id not in self.user_data[guild_id]:
            self.user_data[guild_id][user_id] = {'xp': 0, 'last_message': datetime.now().isoformat()}

        user_data = self.user_data[guild_id][user_id]

        guild = self.bot.get_guild(guild_id)
        member = guild.get_member(user_id)
        if member:
            for role_id, role_multiplier in self.xp_multipliers.get(guild_id, {}).items():
                if isinstance(role_multiplier, (int, float)) and role_id in [role.id for role in member.roles]:
                    xp_gain = int(xp_gain * float(role_multiplier))

        user_data['xp'] += xp_gain
        user_data['last_message'] = datetime.now().isoformat()

        old_level = self.calculate_level(user_data['xp'] - xp_gain)
        new_level = self.calculate_level(user_data['xp'])

        if new_level > old_level:
            await self.handle_level_up(user_id, guild_id, new_level)

        self.save_data()


    async def handle_level_up(self, user_id: int, guild_id: int, level: int):

        if guild_id not in self.announcement_channels:
            return

        guild = self.bot.get_guild(guild_id)
        if not guild:
            print(f"Guild {guild_id} not found")
            return

        member = guild.get_member(user_id)
        if not member:
            print(f"Member {user_id} not found in guild {guild_id}")
            return

        channel = self.bot.get_channel(self.announcement_channels.get(guild_id))
        if not channel:
            print("Announcement channel not found")
            return

        embed = discord.Embed(
            title="🌟 Level Up! 🌟",
            description=f"🎉 {member.mention} has reached **Level {level}**! 🎉",
            color=discord.Color.gold()
        )
        embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
        embed.add_field(name="Next Level", value=f"**{self.xp_for_next_level(level)} XP**", inline=False)

        try:
            await channel.send(embed=embed)
            print(f"Level-up announcement sent to {channel.name}")
        except discord.Forbidden:
            print(f"Bot does not have permission to send messages in {channel.name}")
        except discord.HTTPException as e:
            print(f"Failed to send level-up announcement: {e}")

        if guild_id in self.roles and level in self.roles[guild_id]:
            role = discord.utils.get(guild.roles, id=self.roles[guild_id][level])
            if role:
                try:
                    for lvl, role_id in self.roles[guild_id].items():
                        if lvl != level and role_id in [r.id for r in member.roles]:
                            previous_role = discord.utils.get(guild.roles, id=role_id)
                            if previous_role:
                                await member.remove_roles(previous_role)
                                print(f"Removed previous level role: {previous_role.name}")

                    await member.add_roles(role)
                    print(f"Assigned role {role.name} to {member.display_name}")
                except discord.Forbidden:
                    print(f"Bot does not have permission to manage roles for {member.display_name}")
                except discord.HTTPException as e:
                    print(f"Failed to assign role: {e}")
            else:
                print(f"Role for level {level} not found")
        else:
            print(f"No role assigned for level {level}")

        await self.check_achievements(user_id, guild_id, level)

    async def check_achievements(self, user_id: int, guild_id: int, level: int):
        
        guild = self.bot.get_guild(guild_id)
        member = guild.get_member(user_id)
        if not member:
            return

        for achievement, data in self.achievements.items():
            if level >= data['required_level'] and achievement not in self.user_data[guild_id][user_id].get('achievements', []):
                self.user_data[guild_id][user_id].setdefault('achievements', []).append(achievement)
                embed = discord.Embed(
                    title="🏆 Achievement Unlocked! 🏆",
                    description=f"🎉 {member.mention} has unlocked the **{achievement}** achievement! 🎉",
                    color=discord.Color.blue()
                )
                embed.add_field(name="Reward", value=data['reward'], inline=False)
                await guild.system_channel.send(embed=embed)

    async def update_leaderboard_task(self):
        
        await self.bot.wait_until_ready()
        while not self.bot.is_closed():
            if self.leaderboard_channels:
                for guild_id, channel_id in self.leaderboard_channels.items():
                    channel = self.bot.get_channel(channel_id)
                    if channel:
                        await self.update_leaderboard(channel)
            await asyncio.sleep(1800)


    async def update_leaderboard(self, channel: discord.TextChannel):
        
        guild_id = channel.guild.id
        if guild_id not in self.leaderboard_channels:
            return
            
        if guild_id not in self.user_data or not self.user_data[guild_id]:
            return

        sorted_users = sorted(
            self.user_data[guild_id].items(),
            key=lambda x: x[1]['xp'],
            reverse=True
        )[:10]

        embed = discord.Embed(
            title="🏆 Live Leaderboard 🏆",
            description="Top 10 users by XP",
            color=discord.Color.green()
        )

        for i, (user_id, data) in enumerate(sorted_users, 1):
            member = channel.guild.get_member(user_id)
            if member:
                embed.add_field(
                    name=f"{i}. {member.display_name}",
                    value=f"Level {self.calculate_level(data['xp'])} | {data['xp']} XP",
                    inline=False
                )

        async for message in channel.history(limit=10):
            if message.author == self.bot.user and "🏆 Live Leaderboard 🏆" in message.embeds[0].title:
                await message.delete()
                break

        await channel.send(embed=embed)

    async def xp_decay_task(self):
        
        await self.bot.wait_until_ready()
        while not self.bot.is_closed():
            for guild_id, users in self.user_data.items():
                for user_id, data in users.items():
                    last_message = datetime.fromisoformat(data['last_message'])
                    if (datetime.now() - last_message).days > 7:  
                        data['xp'] = max(0, int(data['xp'] * (1 - self.xp_decay_rate)))
            self.save_data()
            await asyncio.sleep(86400)  

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        
        if message.author.bot or not message.guild:
            return
        await self.add_xp(message.author.id, message.guild.id)


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def set_level_role(self, ctx, level: int, role: discord.Role):
        
        self.roles[level] = role.id
        self.save_data()
        await ctx.send(f"✅ Role {role.name} will be assigned at level {level}.")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def set_leaderboard_channel(self, ctx, channel: discord.TextChannel):
        
        self.leaderboard_channels[ctx.guild.id] = channel.id
        self.save_data()
        await ctx.send(f"✅ Leaderboard will be updated in {channel.mention}.")
        await self.update_leaderboard(channel)


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def leaderboard(self, ctx):
        
        await self.update_leaderboard(ctx.channel)

    @commands.command()
    @commands.is_owner()
    async def set_xp(self, ctx, user: discord.Member, xp: int):
        
        guild_id = ctx.guild.id
        if guild_id not in self.user_data:
            self.user_data[guild_id] = {}
        self.user_data[guild_id][user.id] = {'xp': xp, 'last_message': datetime.now().isoformat()}
        self.save_data()
        await ctx.send(f"✅ Set {user.mention}'s XP to {xp}.")

    @commands.command()
    @commands.is_owner()
    async def reset_levels(self, ctx):
        
        guild_id = ctx.guild.id
        if guild_id in self.user_data:
            del self.user_data[guild_id]
            self.save_data()
            await ctx.send("✅ Reset all leveling data for this server.")
        else:
            await ctx.send("No leveling data found for this server.")

    @commands.command()
    async def my_level(self, ctx):
        
        guild_id = ctx.guild.id
        user_id = ctx.author.id
        if guild_id in self.user_data and user_id in self.user_data[guild_id]:
            xp = self.user_data[guild_id][user_id]['xp']
            level = self.calculate_level(xp)
            next_level_xp = self.xp_for_next_level(level)
            embed = discord.Embed(
                title=f"📊 {ctx.author.display_name}'s Level",
                description=f"Level: **{level}**\nXP: **{xp}/{next_level_xp}**",
                color=discord.Color.green()
            )
            await ctx.send(embed=embed)
        else:
            await ctx.send("You haven't earned any XP yet!")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def levelsetup(self, ctx, channel: Optional[discord.TextChannel] = None):
        guild_id = ctx.guild.id
        
        if channel:
            self.announcement_channels[guild_id] = channel.id
            self.save_data()
            await ctx.send(f"✅ Level-up announcements will now be sent to {channel.mention}.")
        else:
            guild = ctx.guild
            embed = discord.Embed(
                title="📊 Leveling System Setup",
                description="All leveling-related information for this server.",
                color=discord.Color.blue()
            )

            leaderboard_channel = self.bot.get_channel(self.leaderboard_channels.get(guild_id))
            embed.add_field(
                name="Leaderboard Channel",
                value=leaderboard_channel.mention if leaderboard_channel else "Not set",
                inline=False
            )

            announcement_channel = self.bot.get_channel(self.announcement_channels.get(guild_id))
            embed.add_field(
                name="Announcement Channel",
                value=announcement_channel.mention if announcement_channel else "Not set",
                inline=False
            )

            roles_info = "\n".join(
                f"Level {level}: <@&{role_id}>"
                for level, role_id in self.roles.get(guild_id, {}).items()
            ) if guild_id in self.roles else "No roles assigned to levels."
            embed.add_field(name="Level Roles", value=roles_info, inline=False)

            multipliers_info = "\n".join(
                f"<@&{role_id}>: {multiplier}x"
                for role_id, multiplier in self.xp_multipliers.get(guild_id, {}).items()
            ) if guild_id in self.xp_multipliers else "No XP multipliers set."
            embed.add_field(name="XP Multipliers", value=multipliers_info, inline=False)

            achievements_info = "\n".join(
                f"{name}: Level {data['required_level']} (Reward: {data['reward']})"
                for name, data in self.achievements.get(guild_id, {}).items()
            ) if guild_id in self.achievements else "No achievements set."
            embed.add_field(name="Achievements", value=achievements_info, inline=False)

            embed.add_field(
                name="XP Decay Rate",
                value=f"{self.xp_decay_rate * 100}% per day after 7 days of inactivity",
                inline=False
            )

            embed.add_field(
                name="XP Gain Range",
                value=f"{self.xp_gain_range[0]} to {self.xp_gain_range[1]} XP per message",
                inline=False
            )

            total_users = len(self.user_data.get(guild_id, {}))
            embed.add_field(
                name="Total Users with XP",
                value=f"{total_users} users",
                inline=False
            )

            await ctx.send(embed=embed)


class CustomLogging(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.logging_config = {}  

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def togglelog(self, ctx, action: str, channel: discord.TextChannel = None):

        action = action.lower()
        valid_actions = ["ban", "mute", "kick"]

        if action not in valid_actions:
            await ctx.send(f"❌ Invalid action. Use one of: {', '.join(valid_actions)}")
            return

        guild_id = ctx.guild.id
        if guild_id not in self.logging_config:
            self.logging_config[guild_id] = {}

        if channel:
            self.logging_config[guild_id][action] = channel.id
            await ctx.send(f"✅ Logging for `{action}` has been enabled in {channel.mention}.")
        else:
            if action in self.logging_config[guild_id]:
                del self.logging_config[guild_id][action]
                await ctx.send(f"✅ Logging for `{action}` has been disabled.")
            else:
                await ctx.send(f"❌ Logging for `{action}` is already disabled.")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def toggleprelog(self, ctx):

        guild = ctx.guild
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }

        ban_channel = await guild.create_text_channel("ban-logs", overwrites=overwrites)
        mute_channel = await guild.create_text_channel("mute-logs", overwrites=overwrites)
        kick_channel = await guild.create_text_channel("kick-logs", overwrites=overwrites)

        guild_id = guild.id
        self.logging_config[guild_id] = {
            "ban": ban_channel.id,
            "mute": mute_channel.id,
            "kick": kick_channel.id
        }

        await ctx.send("✅ Created logging channels and enabled logging for bans, mutes, and kicks.")

    async def log_action(self, guild_id, action, moderator, user, reason, duration=None):
        print(f"Logging {action} for {user} in guild {guild_id}")  # Debug print
        if guild_id not in self.logging_config or action not in self.logging_config[guild_id]:
            print("Logging not configured for this action.")  # Debug print
            return

        channel_id = self.logging_config[guild_id][action]
        channel = self.bot.get_channel(channel_id)
        if not channel:
            print(f"Channel {channel_id} not found.")  # Debug print
            return

        embed = discord.Embed(
            title=f"🚨 {action.capitalize()} Log",
            description=f"**User:** {user.mention} (`{user.id}`)\n**Reason:** {reason}",
            color=discord.Color.red()
        )
        if duration:
            embed.add_field(name="Duration", value=duration)
        embed.add_field(name="Moderator", value=moderator.mention)
        embed.set_footer(text=f"Action performed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        await channel.send(embed=embed)


class MessagePurge(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def purge(self, ctx, condition: str, count: str = "nuke"):

        if count.lower() == "nuke":
            count = None  
        else:
            try:
                count = int(count)
                if count <= 0:
                    await ctx.send("❌ Count must be a positive number.")
                    return
            except ValueError:
                await ctx.send("❌ Invalid count. Use a number or 'nuke'.")
                return

        def check(message):
            if condition.lower() == "bots":
                return message.author.bot
            elif condition.lower() == "links":
                return "http://" in message.content or "https://" in message.content
            else:
                try:
                    user_id = int(condition)  
                    return message.author.id == user_id
                except ValueError:
                    return False

        if condition.lower() not in ["bots", "links"]:
            try:
                user_id = int(condition)  
            except ValueError:
                await ctx.send(f"❌ Invalid condition: `{condition}`. Use 'bots', 'links', or a valid user ID.", delete_after=5)
                return

        deleted = await ctx.channel.purge(limit=count, check=check)
        await ctx.send(f"✅ Deleted {len(deleted)} messages matching the condition: `{condition}`.", delete_after=5)



class ReminderSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.reminders = {}

    @commands.command(name="reminder")
    async def reminder(self, ctx):

        
        modal = discord.ui.Modal(title="Set a Reminder")
        modal.add_item(discord.ui.TextInput(
            label="Duration",
            placeholder="Enter duration (e.g., 1h, 30m, 2d)",
            required=True
        ))
        modal.add_item(discord.ui.TextInput(
            label="Color",
            placeholder="Enter color (e.g., red, #FF0000)",
            required=True
        ))
        modal.add_item(discord.ui.TextInput(
            label="Message",
            placeholder="Enter the reminder message",
            required=True
        ))
        modal.add_item(discord.ui.TextInput(
            label="Channel",
            placeholder="Mention the channel (e.g., #general)",
            required=True
        ))

        async def on_submit(interaction: discord.Interaction):
            try:
                duration = modal.children[0].value
                color = modal.children[1].value
                message = modal.children[2].value
                channel_input = modal.children[3].value

                duration_seconds = self.parse_duration(duration)
                if duration_seconds <= 0:
                    await interaction.response.send_message("❌ Invalid duration. Please specify a positive duration.", ephemeral=True)
                    return

                reminder_color = self.parse_color(color)
                if not reminder_color:
                    await interaction.response.send_message("❌ Invalid color. Please use a valid hex code or named color (e.g., red, green, blue, #FF0000).", ephemeral=True)
                    return

                channel = self.parse_channel(ctx, channel_input)
                if not channel:
                    await interaction.response.send_message("❌ Invalid channel. Please mention a valid channel or use its ID.", ephemeral=True)
                    return

                reminder_time = datetime.now(timezone.utc) + timedelta(seconds=duration_seconds)
                self.reminders[ctx.author.id] = {
                    "time": reminder_time,
                    "message": message,
                    "color": reminder_color,
                    "channel": channel.id,
                    "user_id": ctx.author.id
                }

                embed = discord.Embed(
                    title="⏰ Reminder Set",
                    description=f"I'll remind you in {duration} in {channel.mention}.",
                    color=reminder_color
                )
                embed.add_field(name="Message", value=message, inline=False)
                await interaction.response.send_message(embed=embed)

                await self.start_reminder(ctx.author.id)

            except ValueError as e:
                await interaction.response.send_message(f"❌ Error: {e}", ephemeral=True)

        modal.on_submit = on_submit

        view = discord.ui.View()
        button = discord.ui.Button(label="Set Reminder", style=discord.ButtonStyle.primary)
        async def button_callback(interaction: discord.Interaction):
            await interaction.response.send_modal(modal)
        button.callback = button_callback
        view.add_item(button)

        await ctx.send("Click the button below to set a reminder:", view=view)

    @commands.command(name="editreminder")
    async def edit_reminder(self, ctx):
        if ctx.author.id not in self.reminders:
            await ctx.send("❌ You don't have any active reminders to edit.")
            return

        reminder = self.reminders[ctx.author.id]

        view = discord.ui.View()
        select = discord.ui.Select(
            placeholder="Select a reminder to edit",
            options=[
                discord.SelectOption(
                    label=f"Reminder: {reminder['message'][:50]}...",
                    value="edit_reminder",
                    description=f"Due: {reminder['time'].strftime('%Y-%m-%d %H:%M:%S')}"
                )
            ]
        )
        select.callback = lambda interaction: self.handle_reminder_selection(interaction, reminder)
        view.add_item(select)

        await ctx.send("Select the reminder you want to edit:", view=view)

    async def handle_reminder_selection(self, interaction: discord.Interaction, reminder):

        modal = discord.ui.Modal(title="Edit Reminder")
        modal.add_item(discord.ui.TextInput(
            label="New Message",
            placeholder="Enter the new reminder message",
            default=reminder["message"],
            required=True
        ))
        modal.add_item(discord.ui.TextInput(
            label="New Duration",
            placeholder="Enter the new duration (e.g., 1h, 30m)",
            required=True
        ))
        modal.add_item(discord.ui.TextInput(
            label="New Color",
            placeholder="Enter the new color (e.g., red, #FF0000)",
            required=True
        ))

        async def on_submit(interaction: discord.Interaction):
            try:
                new_message = modal.children[0].value
                new_duration = modal.children[1].value
                new_color = modal.children[2].value

                duration_seconds = self.parse_duration(new_duration)
                if duration_seconds <= 0:
                    await interaction.response.send_message("❌ Invalid duration. Please specify a positive duration.", ephemeral=True)
                    return

                reminder_color = self.parse_color(new_color)
                if not reminder_color:
                    await interaction.response.send_message("❌ Invalid color. Please use a valid hex code or named color (e.g., red, green, blue, #FF0000).", ephemeral=True)
                    return

                reminder["message"] = new_message
                reminder["time"] = datetime.now(timezone.utc) + timedelta(seconds=duration_seconds)
                reminder["color"] = reminder_color

                embed = discord.Embed(
                    title="⏰ Reminder Updated",
                    description=f"Your reminder has been updated.",
                    color=reminder["color"]
                )
                embed.add_field(name="New Message", value=reminder["message"], inline=False)
                embed.add_field(name="New Duration", value=f"{new_duration}", inline=False)
                embed.add_field(name="New Color", value=f"{new_color}", inline=False)
                await interaction.response.send_message(embed=embed)

                await self.start_reminder(reminder["user_id"])

            except ValueError as e:
                await interaction.response.send_message(f"❌ Error: {e}", ephemeral=True)

        modal.on_submit = on_submit
        await interaction.response.send_modal(modal)

    def parse_duration(self, duration: str) -> int:

        duration = duration.lower()
        if duration.endswith("h"):
            return int(duration[:-1]) * 3600
        elif duration.endswith("m"):
            return int(duration[:-1]) * 60
        elif duration.endswith("d"):
            return int(duration[:-1]) * 86400
        elif duration.endswith("s"):
            return int(duration[:-1])
        else:
            raise ValueError("Invalid duration format. Use 'h' for hours, 'm' for minutes, 's' for seconds, or 'd' for days.")

    def parse_color(self, color: str) -> Optional[discord.Color]:

        color = color.lower()
        named_colors = {
            "red": discord.Color.red(),
            "green": discord.Color.green(),
            "blue": discord.Color.blue(),
            "purple": discord.Color.purple(),
            "orange": discord.Color.orange(),
            "gold": discord.Color.gold(),
            "teal": discord.Color.teal(),
            "dark_blue": discord.Color.dark_blue(),
            "dark_green": discord.Color.dark_green(),
            "dark_purple": discord.Color.dark_purple(),
            "dark_red": discord.Color.dark_red(),
            "dark_teal": discord.Color.dark_teal(),
            "dark_gold": discord.Color.dark_gold(),
            "dark_orange": discord.Color.dark_orange(),
            "dark_gray": discord.Color.dark_gray(),
            "light_gray": discord.Color.light_gray(),
            "blurple": discord.Color.blurple(),
            "greyple": discord.Color.greyple(),
            "fuchsia": discord.Color.fuchsia(),
            "yellow": discord.Color.yellow(),
            "black": discord.Color.default(),
        }
        if color in named_colors:
            return named_colors[color]
        try:
            return discord.Color.from_str(color)
        except ValueError:
            return None

    def parse_channel(self, ctx, channel_input: str) -> Optional[discord.TextChannel]:

        try:
            if channel_input.startswith("<#") and channel_input.endswith(">"):
                channel_id = int(channel_input[2:-1])
            else:
                channel_id = int(channel_input)
            return ctx.guild.get_channel(channel_id)
        except (ValueError, AttributeError):
            return None

    async def start_reminder(self, user_id: int):
        reminder = self.reminders.get(user_id)
        if not reminder:
            return

        reminder_time = reminder["time"]
        reminder_time = reminder["time"]
        delay = (reminder_time - datetime.now(timezone.utc)).total_seconds()

        if delay > 0:
            await asyncio.sleep(delay)

            channel = self.bot.get_channel(reminder["channel"])
            if channel:
                embed = discord.Embed(
                    title="⏰ Reminder",
                    description=reminder["message"],
                    color=reminder["color"]
                )
                await channel.send(f"<@{reminder['user_id']}>", embed=embed)

            self.reminders.pop(user_id, None)


class Snipe(commands.Cog):       
    def __init__(self, bot):
        self.bot = bot
        self.deleted_messages = {} 
        self.edited_messages = {}  
        self.snipe_cooldown = {}  
        self.snipe_duration = 300  
        self.editsnipe_duration = 300  

    @commands.Cog.listener()
    async def on_message_delete(self, message):
        
        if message.author.bot:  
            return

        self.deleted_messages[message.channel.id] = {
            "content": message.content,
            "author": message.author,
            "timestamp": message.created_at,
            "attachments": [attachment.url for attachment in message.attachments]
        }

        await asyncio.sleep(self.snipe_duration)  
        if message.channel.id in self.deleted_messages:
            del self.deleted_messages[message.channel.id]

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):
        
        if before.author.bot: 
            return

        self.edited_messages[before.channel.id] = {
            "before": before.content,
            "after": after.content,
            "author": before.author,
            "timestamp": datetime.utcnow()
        }

        await asyncio.sleep(self.editsnipe_duration)  
        if before.channel.id in self.edited_messages:
            del self.edited_messages[before.channel.id]

    @commands.command(name="configuresnipe")
    @commands.has_permissions(manage_messages=True)
    async def configuresnipe(self, ctx, duration: int):
        
        if duration < 0:
            await ctx.send("Duration cannot be negative.")
            return
        self.snipe_duration = duration
        await ctx.send(f"Deleted messages will now be stored for {duration} seconds.")

    @commands.command(name="configuresnipeedit")
    @commands.has_permissions(manage_messages=True)
    async def configuresnipeedit(self, ctx, duration: int):
        
        if duration < 0:
            await ctx.send("Duration cannot be negative.")
            return
        self.editsnipe_duration = duration
        await ctx.send(f"Edited messages will now be stored for {duration} seconds.")

    @commands.command(name="snipe_info")
    async def snipe_info(self, ctx):
        
        embed = discord.Embed(
            title="⚙️ Snipe Settings",
            color=discord.Color.green()
        )
        embed.add_field(name="Deleted Messages Duration", value=f"{self.snipe_duration} seconds", inline=False)
        embed.add_field(name="Edited Messages Duration", value=f"{self.editsnipe_duration} seconds", inline=False)
        await ctx.send(embed=embed)

    @commands.command(name="snipe")
    @commands.has_permissions(manage_messages=True)
    async def snipe(self, ctx):
        
        if ctx.author.id in self.snipe_cooldown:
            remaining = (self.snipe_cooldown[ctx.author.id] - datetime.utcnow()).total_seconds()
            if remaining > 0:
                await ctx.send(f"You're on cooldown! Try again in {int(remaining)} seconds.")
                return

        deleted_message = self.deleted_messages.get(ctx.channel.id)
        if not deleted_message:
            await ctx.send("No recently deleted messages found in this channel.")
            return

        embed = discord.Embed(
            title="🗑️ Sniped Message",
            description=deleted_message["content"],
            color=discord.Color.red()
        )
        embed.set_author(name=deleted_message["author"].display_name, icon_url=deleted_message["author"].avatar.url)
        embed.set_footer(text=f"Deleted at {deleted_message['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}")

        if deleted_message["attachments"]:
            embed.add_field(name="Attachments", value="\n".join(deleted_message["attachments"]), inline=False)

        await ctx.send(embed=embed)

        self.snipe_cooldown[ctx.author.id] = datetime.utcnow() + timedelta(seconds=30)

    @commands.command(name="editsnipe")
    @commands.has_permissions(manage_messages=True)
    async def editsnipe(self, ctx):
        
        if ctx.author.id in self.snipe_cooldown:
            remaining = (self.snipe_cooldown[ctx.author.id] - datetime.utcnow()).total_seconds()
            if remaining > 0:
                await ctx.send(f"You're on cooldown! Try again in {int(remaining)} seconds.")
                return

        edited_message = self.edited_messages.get(ctx.channel.id)
        if not edited_message:
            await ctx.send("No recently edited messages found in this channel.")
            return

        embed = discord.Embed(
            title="✏️ Edited Message",
            color=discord.Color.blue()
        )
        embed.set_author(name=edited_message["author"].display_name, icon_url=edited_message["author"].avatar.url)
        embed.add_field(name="Before", value=edited_message["before"], inline=False)
        embed.add_field(name="After", value=edited_message["after"], inline=False)
        embed.set_footer(text=f"Edited at {edited_message['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}")

        await ctx.send(embed=embed)

        self.snipe_cooldown[ctx.author.id] = datetime.utcnow() + timedelta(seconds=30)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AdvancedInviteTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.invite_cache: Dict[int, Dict[str, Dict]] = {}  
        self.known_joins: Dict[int, Dict] = {}  
        self.data_file = "data/invite_tracking_data.json"
        self.db_file = "data/invite_tracking.db"
        self.setup_database()

        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, "r") as f:
                    data = json.load(f)
                    self.invite_cache = data.get("invites", {})
                    self.known_joins = data.get("known_joins", {})
            except json.JSONDecodeError:
                logger.error("Failed to load invite tracking data: Invalid JSON format")

    def setup_database(self):
        
        self.conn = sqlite3.connect(self.db_file)
        self.cursor = self.conn.cursor()
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS invites (
                guild_id INTEGER,
                invite_code TEXT,
                uses INTEGER,
                inviter TEXT,
                created_at TEXT,
                PRIMARY KEY (guild_id, invite_code)
            )
        ''')
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS joins (
                member_id INTEGER PRIMARY KEY,
                guild_id INTEGER,
                invite_code TEXT,
                inviter TEXT,
                joined_at TEXT
            )
        ''')
        self.conn.commit()

    @commands.Cog.listener()
    async def on_ready(self):
        

        print('\033[95m' + '[+] ' + '\033[94m' + "Bot is ready. Syncing invites..." + '\033[0m')
        for guild in self.bot.guilds:
            try:
                invites = await guild.invites()
                self.invite_cache[guild.id] = {
                    invite.code: {
                        "uses": invite.uses,
                        "inviter": invite.inviter.name if invite.inviter else "Unknown",
                        "created_at": invite.created_at.isoformat() if invite.created_at else "Unknown"
                    }
                    for invite in invites
                }
                self.update_database(guild.id, invites)
            except discord.Forbidden:
                logger.warning(f"Missing permission to fetch invites for guild: {guild.name}")

        print('\033[95m' + '[√] ' + '\033[94m' + "Invite sync complete." + '\033[0m')


    def update_database(self, guild_id: int, invites: List[discord.Invite]):
        
        for invite in invites:
            self.cursor.execute('''
                INSERT OR REPLACE INTO invites (guild_id, invite_code, uses, inviter, created_at)
                VALUES (?, ?, ?, ?, ?)
            ''', (guild_id, invite.code, invite.uses, invite.inviter.name if invite.inviter else "Unknown", invite.created_at.isoformat() if invite.created_at else "Unknown"))
        self.conn.commit()

    @commands.Cog.listener()
    async def on_member_join(self, member: discord.Member):
        
        try:
            invites_before = self.invite_cache.get(member.guild.id, {})
            current_invites = await member.guild.invites()

            for invite in current_invites:
                cached_invite = invites_before.get(invite.code)
                if cached_invite and invite.uses > cached_invite["uses"]:
                    inviter = invite.inviter.name if invite.inviter else "Unknown"
                    invite_code = invite.code

                    self.known_joins[member.id] = {
                        "joined_at": member.joined_at.isoformat() if member.joined_at else "Unknown",
                        "invite_code": invite_code,
                        "inviter": inviter
                    }
                    self.cursor.execute('''
                        INSERT OR REPLACE INTO joins (member_id, guild_id, invite_code, inviter, joined_at)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (member.id, member.guild.id, invite_code, inviter, member.joined_at.isoformat() if member.joined_at else "Unknown"))
                    self.conn.commit()

                    self.invite_cache[member.guild.id][invite.code]["uses"] = invite.uses
                    await self.log_join(member, invite_code, inviter)
                    break

            self.backup_data()

        except discord.Forbidden:
            logger.warning(f"Missing permission to fetch invites for guild: {member.guild.name}")

    @commands.Cog.listener()
    async def on_member_remove(self, member: discord.Member):
        
        if member.id in self.known_joins:
            del self.known_joins[member.id]
            self.cursor.execute('DELETE FROM joins WHERE member_id = ?', (member.id,))
            self.conn.commit()
            self.backup_data()
            logger.info(f"Member {member.name} ({member.id}) left the server.")

    async def log_join(self, member: discord.Member, invite_code: str, inviter: str):
        
        log_channel = discord.utils.get(member.guild.text_channels, name='join-logs')
        if log_channel:
            embed = discord.Embed(
                title="👤 Member Joined",
                description=f"{member.mention} joined using invite `{invite_code}` created by **{inviter}**.",
                color=discord.Color.green()
            )
            embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
            await log_channel.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def view_historic(self, ctx):
        
        self.cursor.execute('SELECT * FROM joins WHERE guild_id = ?', (ctx.guild.id,))
        joins = self.cursor.fetchall()

        if not joins:
            await ctx.send("📊 No historic join data available.")
            return

        entries = []
        for join in joins:
            member_id, guild_id, invite_code, inviter, joined_at = join
            member = ctx.guild.get_member(member_id)
            member_name = member.name if member else "Unknown Member"
            entries.append(
                f"👤 **{member_name}** (ID: {member_id})\n"
                f"🎟️ Invite: `{invite_code}` by **{inviter}**\n"
                f"📅 Joined: {joined_at}\n"
            )

        page_size = 5
        pages = [entries[i:i + page_size] for i in range(0, len(entries), page_size)]

        for page_num, page_content in enumerate(pages, 1):
            embed = discord.Embed(
                title=f"📊 Historic Invite Tracking (Page {page_num}/{len(pages)})",
                description="\n\n".join(page_content),
                color=discord.Color.blue()
            )
            embed.set_footer(text=f"Tracked {len(joins)} total joins.")
            await ctx.send(embed=embed)

    def backup_data(self):
        
        data = {
            "invites": self.invite_cache,
            "known_joins": self.known_joins
        }
        with open(self.data_file, "w") as f:
            json.dump(data, f, indent=4)

    def cog_unload(self):
        
        self.conn.close()



class Analytics(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.invite_tracker = {} 
        self.join_tracker = {}    
        self.analytics_channels = {}  
        self.analytics_tasks = {}  

    async def fetch_existing_invites(self):
        for guild in self.bot.guilds:
            if guild.id not in self.invite_tracker:
                self.invite_tracker[guild.id] = {}
            try:
                invites = await guild.invites()
                for invite in invites:
                    self.invite_tracker[guild.id][invite.code] = {
                        'code': invite.code,
                        'creator': invite.inviter.name if invite.inviter else "Unknown",
                        'uses': invite.uses,
                        'max_uses': invite.max_uses,
                        'expires_at': invite.expires_at
                    }
            except Exception as e:
                print(f"Error fetching invites for guild {guild.name}: {e}")

    async def check_and_setup_analytics(self):
        while True:
            for guild_id in self.analytics_channels:
                for interval, channel in self.analytics_channels[guild_id].items():
                    if channel is None:
                        print(f"Channel for {interval} analytics not found in guild {guild_id}. Retrying in 5 minutes...")
                        await asyncio.sleep(300)
                        continue

                    task_key = f"{guild_id}_{interval}"
                    if task_key not in self.analytics_tasks or self.analytics_tasks[task_key].done():
                        self.analytics_tasks[task_key] = self.bot.loop.create_task(
                            self._send_analytics(guild_id, interval)
                        )
                        print(f"Analytics task for {interval} started in {channel.mention} (Guild: {guild_id})")
            await asyncio.sleep(300)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def analyse(self, ctx, interval: str = None, channel: discord.TextChannel = None):
        guild_id = ctx.guild.id
        
        if guild_id not in self.analytics_channels:
            self.analytics_channels[guild_id] = {}
            
        if interval:
            if interval.lower() not in ['daily', 'weekly', 'monthly']:
                await ctx.send("❌ Invalid interval. Use 'daily', 'weekly', or 'monthly'.")
                return

            self.analytics_channels[guild_id][interval.lower()] = channel or ctx.channel
            task_key = f"{guild_id}_{interval.lower()}"
            
            if task_key not in self.analytics_tasks or self.analytics_tasks[task_key].done():
                self.analytics_tasks[task_key] = self.bot.loop.create_task(
                    self._send_analytics(guild_id, interval.lower())
                )

            embed = discord.Embed(
                title="✅ Analytics Setup Complete",
                description=f"Analytics will be posted {interval.lower()} in {(channel or ctx.channel).mention}.",
                color=discord.Color.green()
            )
            await ctx.send(embed=embed)
        else:
            embed = discord.Embed(
                title="📊 Analytics Status",
                description="Current analytics configurations",
                color=discord.Color.blue()
            )

            for interval in ['daily', 'weekly', 'monthly']:
                if interval in self.analytics_channels.get(guild_id, {}) and self.analytics_channels[guild_id][interval] is not None:
                    embed.add_field(
                        name=f"{interval.capitalize()} Analytics",
                        value=f"Active in {self.analytics_channels[guild_id][interval].mention}",
                        inline=False
                    )
                else:
                    embed.add_field(
                        name=f"{interval.capitalize()} Analytics",
                        value="Not active",
                        inline=False
                    )

            await ctx.send(embed=embed)

    async def _send_analytics(self, guild_id, interval):
        while True:
            print(f"Running analytics task for {interval} in guild {guild_id}")
            try:
                if interval == 'daily':
                    await asyncio.sleep(86400)
                elif interval == 'weekly':
                    await asyncio.sleep(604800)
                elif interval == 'monthly':
                    await asyncio.sleep(2592000)

                if guild_id not in self.analytics_channels or interval not in self.analytics_channels[guild_id]:
                    continue

                embed = self._generate_analytics_report(guild_id, interval)
                await self.analytics_channels[guild_id][interval].send(embed=embed)
            except Exception as e:
                print(f"Error in _send_analytics for guild {guild_id}: {e}")
                continue

    def _generate_analytics_report(self, guild_id, interval):
        embed = discord.Embed(
            title=f"📊 Server Analytics Report ({interval.capitalize()})",
            description="Detailed server activity and statistics",
            color=discord.Color.blue()
        )

        guild_invites = self.invite_tracker.get(guild_id, {})
        active_invites = [invite for invite in guild_invites.values() if invite['uses'] > 0]
        expired_invites = [invite for invite in guild_invites.values() if invite['uses'] == 0]

        embed.add_field(
            name="🔗 Invites",
            value=f"Active: {len(active_invites)}\nExpired: {len(expired_invites)}\nTotal Uses: {sum(invite['uses'] for invite in guild_invites.values())}",
            inline=False
        )

        guild_joins = self.join_tracker.get(guild_id, {})
        total_joins = sum(guild_joins.values())
        embed.add_field(
            name="👥 Member Joins",
            value=f"Total Joins ({interval}): {total_joins}",
            inline=False
        )

        if active_invites:
            invite_details = "\n".join(
                f"• {invite['code']}: {invite['uses']} uses (Created by {invite['creator']})"
                for invite in active_invites
            )
            embed.add_field(name="Active Invites", value=invite_details, inline=False)

        return embed

    @commands.Cog.listener()
    async def on_member_join(self, member):
        guild_id = member.guild.id
        if guild_id not in self.join_tracker:
            self.join_tracker[guild_id] = {}
        today = datetime.now().date()
        self.join_tracker[guild_id][today] = self.join_tracker[guild_id].get(today, 0) + 1

    @commands.Cog.listener()
    async def on_invite_create(self, invite):
        guild_id = invite.guild.id
        if guild_id not in self.invite_tracker:
            self.invite_tracker[guild_id] = {}
        self.invite_tracker[guild_id][invite.code] = {
            'code': invite.code,
            'creator': invite.inviter.name if invite.inviter else "Unknown",
            'uses': invite.uses,
            'max_uses': invite.max_uses,
            'expires_at': invite.expires_at
        }

    @commands.Cog.listener()
    async def on_invite_delete(self, invite):
        guild_id = invite.guild.id
        if guild_id in self.invite_tracker and invite.code in self.invite_tracker[guild_id]:
            del self.invite_tracker[guild_id][invite.code]

    @commands.Cog.listener()
    async def on_member_remove(self, member):
        guild_id = member.guild.id
        invites = await member.guild.invites()
        if guild_id not in self.invite_tracker:
            self.invite_tracker[guild_id] = {}
        for invite in invites:
            if invite.code in self.invite_tracker[guild_id]:
                self.invite_tracker[guild_id][invite.code]['uses'] = invite.uses
            else:
                self.invite_tracker[guild_id][invite.code] = {
                    'code': invite.code,
                    'creator': invite.inviter.name if invite.inviter else "Unknown",
                    'uses': invite.uses,
                    'max_uses': invite.max_uses,
                    'expires_at': invite.expires_at
                }

    @commands.Cog.listener()
    async def on_ready(self):
        await self.fetch_existing_invites()
        self.bot.loop.create_task(self.check_and_setup_analytics())



class WebhookLogger:
    def __init__(self, bot):
        self.bot = bot
        webhook_url = os.getenv('LOGGING_WEBHOOK_URL')
        
        if webhook_url and webhook_url.lower() != 'none':
            self.webhook_url = webhook_url
            self.session = aiohttp.ClientSession()
            
            try:
                parts = self.webhook_url.split('/')
                self.webhook_id = int(parts[-2]) if len(parts) > 2 else None
            except (IndexError, ValueError):
                self.webhook_id = None
                
            if hasattr(bot, 'get_cog'):
                automod = bot.get_cog('AutoMod')
                if automod:
                    automod.link_whitelist.add(self.webhook_url)
                    automod.link_whitelist.add('discord.com/channels')
        else:
            self.webhook_url = None
            self.webhook_id = None
            self.session = None

    async def send_to_webhook(self, content=None, embeds=None, files=None):
        if not self.webhook_url:
            return

        webhook = discord.Webhook.from_url(self.webhook_url, session=self.session)

        try:
            
            if isinstance(embeds, list) and embeds:
                for embed in embeds:
                    if isinstance(embed, discord.Embed):
                        embed.set_footer(text=f"{embed.footer.text or ''} | Webhook ID: {self.webhook_id}")

                await webhook.send(
                    content=content,
                    embeds=embeds,
                    files=files
                )
            elif embeds and isinstance(embeds[0], discord.Embed):
                
                await webhook.send(
                    content=content,
                    embed=embeds[0],
                    files=files
                )
            else:
                
                await webhook.send(
                    content=content,
                    files=files
                )
        except Exception as e:
            print(f"Webhook send error details: {str(e)}")


    async def log_command(self, ctx):
        if not ctx.guild:
            return
        
        embed = EmbedBuilder(
            f"Command Used in {ctx.guild.name}",
            f"Command: {ctx.command}\nArgs: {ctx.args[2:]}"
        ).set_color(discord.Color.green())
        
        embed.add_field("User", f"{ctx.author} ({ctx.author.id})")
        embed.add_field("Channel", f"{ctx.channel.name} ({ctx.channel.id})")
        embed.add_field("Timestamp", ctx.message.created_at.strftime("%Y-%m-%d %H:%M:%S"), inline=False)
        
        if ctx.message.reference:
            embed.add_field("Reply to", f"Message ID: {ctx.message.reference.message_id}", inline=False)
        
        message_link = f"https://discord.com/channels/{ctx.guild.id}/{ctx.channel.id}/{ctx.message.id}"
        embed.add_field("Message Link", message_link, inline=False)
        
        files = []
        if ctx.message.attachments:
            for attachment in ctx.message.attachments:
                try:
                    file_data = await attachment.read()
                    file = discord.File(io.BytesIO(file_data), filename=attachment.filename)
                    files.append(file)
                    
                    file_info = (
                        f"📎 Name: {attachment.filename}\n"
                        f"📊 Size: {attachment.size:,} bytes\n"
                        f"📑 Type: {attachment.content_type}\n"
                        f"🔗 URL: {attachment.url}"
                    )
                    embed.add_field("File Attachment", file_info, inline=False)
                except Exception as e:
                    embed.add_field("⚠️ File Error", f"Failed to process {attachment.filename}: {str(e)}", inline=False)
        
        built_embed = embed.build()
        if built_embed:
            try:
                await self.send_to_webhook(embeds=[built_embed], files=files)
            except Exception as e:
                print(f"Failed to send command log: {str(e)}")

    async def log_message(self, message):
        if not message.guild or not self.webhook_url or self.webhook_url.lower() == 'none':
            return
            
        if message.webhook_id and message.webhook_id == int(self.webhook_url.split('/')[-2]):
            return

        embed = EmbedBuilder(
            f"Message in {message.guild.name}",
            message.content or "No content"
        ).set_color(discord.Color.blue())

        message_type = "User Message"
        if message.author.bot:
            message_type = "Bot Message"
            embed.set_color(discord.Color.purple())
        if message.webhook_id:
            message_type = "Webhook Message"
            embed.set_color(discord.Color.gold())
        embed.add_field("Type", message_type)

        if message.webhook_id:
            embed.add_field("Webhook ID", message.webhook_id)
            if hasattr(message, 'application') and message.application:
                embed.add_field("Integration", message.application.name)
        if message.author.bot:
            embed.add_field("Bot Name", message.author.name)
            embed.add_field("Bot ID", message.author.id)

        embed.add_field("Author", f"{message.author} ({message.author.id})")
        embed.add_field("Channel", f"{message.channel.name} ({message.channel.id})")
        embed.add_field("Timestamp", message.created_at.strftime("%Y-%m-%d %H:%M:%S"), inline=False)

        if message.reference:
            try:
                ref_msg = await message.channel.fetch_message(message.reference.message_id)
                ref_info = f"Message: {ref_msg.content[:100]}...\nAuthor: {ref_msg.author}\nID: {message.reference.message_id}"
                embed.add_field("Reply to", ref_info, inline=False)
            except:
                embed.add_field("Reply to", f"Message ID: {message.reference.message_id}", inline=False)

        if message.edited_at:
            embed.add_field("Edited", message.edited_at.strftime("%Y-%m-%d %H:%M:%S"), inline=False)

        files = []
        for attachment in message.attachments:
            try:
                file_data = await attachment.read()
                file = discord.File(io.BytesIO(file_data), filename=attachment.filename)
                files.append(file)
                
                file_info = (
                    f"📎 Name: {attachment.filename}\n"
                    f"📊 Size: {attachment.size:,} bytes\n"
                    f"📑 Type: {attachment.content_type}\n"
                    f"🔗 URL: {attachment.url}"
                )
                embed.add_field("File Attachment", file_info, inline=False)
            except Exception as e:
                embed.add_field("⚠️ File Error", f"Failed to process {attachment.filename}: {str(e)}", inline=False)

        message_link = f"https://discord.com/channels/{message.guild.id}/{message.channel.id}/{message.id}"
        embed.add_field("Message Link", message_link, inline=False)
        embed.set_footer(f"Message ID: {message.id} | Guild ID: {message.guild.id}")

        if message.author.avatar:
            embed.set_thumbnail(message.author.avatar.url)

        built_embed = embed.build()
        if built_embed:
            try:
                await self.send_to_webhook(embeds=[built_embed], files=files)
            except Exception as e:
                print(f"Failed to send message log: {str(e)}")

    def __del__(self):
        if self.session:
            asyncio.create_task(self.session.close())

class TicTacToeButton(discord.ui.Button):
    def __init__(self, x, y):
        super().__init__(style=discord.ButtonStyle.secondary, label="⠀", row=y)
        self.x = x
        self.y = y


    async def callback(self, interaction: discord.Interaction):
        view: TicTacToeView = self.view
        if interaction.user != view.current_player:
            return
        
        if view.board[self.x][self.y] != " ":
            return

        mark = "X" if view.current_player == view.player1 else "O"
        view.board[self.x][self.y] = mark
        self.label = mark
        self.disabled = True
        self.style = discord.ButtonStyle.danger if mark == "X" else discord.ButtonStyle.success

        if view.check_winner():
            for child in view.children:
                child.disabled = True
            embed = EmbedBuilder(
                "🎮 Game Over!",
                f"🎉 {view.current_player.mention} wins!"
            ).set_color(discord.Color.gold())
            await interaction.response.edit_message(view=view, embed=embed.build())
            
            rematch_view = discord.ui.View()
            rematch_button = discord.ui.Button(label="Rematch", style=discord.ButtonStyle.primary)
            close_button = discord.ui.Button(label="Close", style=discord.ButtonStyle.red)
            
            async def rematch_callback(i):
                new_game = TicTacToeView(view.player1, view.player2)
                embed = EmbedBuilder(
                    "🎮 New Game Started!",
                    f"{view.player1.mention} vs {view.player2.mention}"
                ).set_color(discord.Color.blue())
                await i.response.send_message(embed=embed.build(), view=new_game)
                
            async def close_callback(i):
                await i.channel.delete()
                
            rematch_button.callback = rematch_callback
            close_button.callback = close_callback
            rematch_view.add_item(rematch_button)
            rematch_view.add_item(close_button)
            await interaction.channel.send(view=rematch_view)
            return

        if view.is_board_full():
            embed = EmbedBuilder(
                "🎮 Game Over!",
                "It's a tie!"
            ).set_color(discord.Color.greyple())
            await interaction.response.edit_message(view=view, embed=embed.build())
            return

        view.current_player = view.player2 if view.current_player == view.player1 else view.player1
        embed = EmbedBuilder(
            "🎮 TicTacToe",
            f"It's {view.current_player.mention}'s turn!"
        ).set_color(discord.Color.blue())
        await interaction.response.edit_message(view=view, embed=embed.build())

class TicTacToeView(discord.ui.View):
    def __init__(self, player1, player2):
        super().__init__(timeout=120)
        self.current_player = player1
        self.player1 = player1
        self.player2 = player2
        self.board = [[" " for _ in range(3)] for _ in range(3)]
        
        for i in range(3):
            for j in range(3):
                self.add_item(TicTacToeButton(i, j))

    def check_winner(self):
        for i in range(3):
            if self.board[i][0] == self.board[i][1] == self.board[i][2] != " ":
                return True
            if self.board[0][i] == self.board[1][i] == self.board[2][i] != " ":
                return True
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != " ":
            return True
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != " ":
            return True
        return False

    def is_board_full(self):
        return all(self.board[i][j] != " " for i in range(3) for j in range(3))

    async def on_timeout(self):
        await self.message.channel.delete()

class MinigamesCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_games = {}

    class Connect4View(discord.ui.View):
        def __init__(self, player1, player2):
            super().__init__(timeout=None)
            self.player1 = player1
            self.player2 = player2
            self.current_player = player1
            self.board = [[None for _ in range(7)] for _ in range(6)]
            self.message = None
            self.game_over = False
            self.setup_board()

        def setup_board(self):
            number_emojis = ['1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣']
            
            for col in range(5):
                button = discord.ui.Button(label=number_emojis[col], custom_id=f'col_{col}', row=0)
                button.callback = self.make_move
                self.add_item(button)
            
            for col in range(5, 7):
                button = discord.ui.Button(label=number_emojis[col], custom_id=f'col_{col}', row=1)
                button.callback = self.make_move
                self.add_item(button)

        async def make_move(self, interaction: discord.Interaction):
            if interaction.user != self.current_player or self.game_over:
                return

            col = int(interaction.data['custom_id'].split('_')[1])
            row = self.get_next_empty_row(col)
            
            if row is None:
                return
            
            self.board[row][col] = self.current_player == self.player1
            
            if self.check_winner(row, col):
                embed = EmbedBuilder(
                    "🎮 Connect Four - Game Over!",
                    f"🎉 {self.current_player.mention} wins!"
                ).set_color(discord.Color.gold())
                self.game_over = True
            elif self.is_board_full():
                embed = EmbedBuilder(
                    "🎮 Connect Four - Game Over!",
                    "It's a draw!"
                ).set_color(discord.Color.blue())
                self.game_over = True
            else:
                self.current_player = self.player2 if self.current_player == self.player1 else self.player1
                embed = EmbedBuilder(
                    "🎮 Connect Four",
                    f"{self.current_player.mention}'s turn!"
                ).set_color(discord.Color.blue())

            embed.add_field(name="Game Board", value=self.get_board_display())
            
            if self.game_over:
                rematch_view = self.create_rematch_view()
                await interaction.response.edit_message(embed=embed.build(), view=rematch_view)
            else:
                await interaction.response.edit_message(embed=embed.build(), view=self)

        def get_next_empty_row(self, col):
            for row in range(5, -1, -1):
                if self.board[row][col] is None:
                    return row
            return None

        def get_board_display(self):
            display = ""
            for row in self.board:
                for cell in row:
                    if cell is None:
                        display += "⚪"
                    elif cell:
                        display += "🔴"
                    else:
                        display += "🟡"
                display += "\n"
            display += "1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣"
            return display

        def check_winner(self, row, col):
            directions = [(0,1), (1,0), (1,1), (1,-1)]
            player_value = self.board[row][col]
            
            for dx, dy in directions:
                count = 1
                for direction in [1, -1]:
                    x, y = row + dx * direction, col + dy * direction
                    while 0 <= x < 6 and 0 <= y < 7 and self.board[x][y] == player_value:
                        count += 1
                        x += dx * direction
                        y += dy * direction
                if count >= 4:
                    return True
            return False

        def is_board_full(self):
            return all(cell is not None for row in self.board for cell in row)

        def create_rematch_view(self):
            view = discord.ui.View(timeout=120)
            
            async def rematch_callback(interaction):
                if interaction.user not in [self.player1, self.player2]:
                    return
                    
                new_game = self.Connect4View(self.player1, self.player2)
                embed = EmbedBuilder(
                    "🎮 Connect Four",
                    f"{self.player1.mention} vs {self.player2.mention}\n{self.player1.mention}'s turn!"
                ).set_color(discord.Color.blue())
                
                await interaction.response.edit_message(embed=embed.build(), view=new_game)
                
            async def close_callback(interaction):
                if interaction.user not in [self.player1, self.player2]:
                    return
                await interaction.message.delete()
                
            rematch = discord.ui.Button(label="Rematch", style=discord.ButtonStyle.green, emoji="🔄")
            close = discord.ui.Button(label="Close", style=discord.ButtonStyle.red, emoji="❌")
            
            rematch.callback = rematch_callback
            close.callback = close_callback
            
            view.add_item(rematch)
            view.add_item(close)
            return view

    @commands.command()
    async def connect4(self, ctx):
        
        embed = EmbedBuilder(
            "🎮 Connect Four Challenge",
            f"{ctx.author.mention} wants to play Connect Four!\nClick Accept within 2 minutes to play."
        ).set_color(discord.Color.blue())
    
        view = discord.ui.View(timeout=120)
    
        async def accept_callback(interaction):
            if interaction.user == ctx.author:
                return
        
            overwrites = {
                ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
                ctx.author: discord.PermissionOverwrite(read_messages=True),
                interaction.user: discord.PermissionOverwrite(read_messages=True)
            }
        
            channel = await ctx.guild.create_text_channel(
                f"connect4-{ctx.author.name}-{interaction.user.name}",
                overwrites=overwrites
            )
        
            game_view = self.Connect4View(ctx.author, interaction.user)
            game_embed = EmbedBuilder(
                "🎮 Connect Four",
                f"{ctx.author.mention} vs {interaction.user.mention}\n{ctx.author.mention}'s turn!"
            ).set_color(discord.Color.blue())
            game_embed.add_field(name="Game Board", value=game_view.get_board_display())
        
            await interaction.response.defer()
            message = await channel.send(embed=game_embed.build(), view=game_view)
            game_view.message = message
            await interaction.message.delete()

        accept_button = discord.ui.Button(
            label="Accept Challenge",
            style=discord.ButtonStyle.green,
            emoji="✅"
        )
        accept_button.callback = accept_callback
        view.add_item(accept_button)
    
        await ctx.send(embed=embed.build(), view=view)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def numbergame(self, ctx, number: int, channel: discord.TextChannel):
        
        if not 1 <= number <= 10000:
            await ctx.send("Please choose a number between 1 and 10000!")
            return
            
        if channel.id in self.active_games:
            await ctx.send("A game is already running in that channel!")
            return
            
        self.active_games[channel.id] = number
            
        embed = EmbedBuilder(
            "🎮 Number Guessing Game Started!",
            "A new number guessing game has begun!\n\n"
            "Simply type numbers in the chat to guess.\n"
            "First person to guess correctly wins! 🏆"
        ).set_color(discord.Color.blue()).build()
        
        await channel.send(embed=embed)

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
            
        if message.channel.id not in self.active_games:
            return
            
        if not message.content.isdigit():
            return
            
        guess = int(message.content)
        correct_number = self.active_games[message.channel.id]
        
        if guess == correct_number:
            win_embed = EmbedBuilder(
                "🎉 We Have a Winner!",
                f"Congratulations {message.author.mention}!\n"
                f"The correct number was {correct_number}!"
            ).set_color(discord.Color.gold()).build()
            await message.channel.send(embed=win_embed)
            del self.active_games[message.channel.id]

    @commands.command()
    async def tictactoe(self, ctx):
        
        embed = EmbedBuilder(
        "🎮 TicTacToe Challenge",
        f"{ctx.author.mention} wants to play TicTacToe!\nClick Accept within 2 minutes to play."
    ).set_color(discord.Color.blue())
   
        view = discord.ui.View(timeout=120)
   
        async def accept_callback(interaction):
            if interaction.user == ctx.author:
                return
       
            overwrites = {
            ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            ctx.author: discord.PermissionOverwrite(read_messages=True),
            interaction.user: discord.PermissionOverwrite(read_messages=True)
        }
       
            channel = await ctx.guild.create_text_channel(
            f"tictactoe-{ctx.author.name}-{interaction.user.name}",
            overwrites=overwrites
        )
       
            game_view = TicTacToeView(ctx.author, interaction.user)
            game_embed = EmbedBuilder(
            "🎮 TicTacToe",
            f"{ctx.author.mention} vs {interaction.user.mention}\n{ctx.author.mention}'s turn!"
        ).set_color(discord.Color.blue())
       
            await interaction.response.defer()
            message = await channel.send(embed=game_embed.build(), view=game_view)
            game_view.message = message
            await interaction.message.delete()

        accept_button = discord.ui.Button(
        label="Accept Challenge",
        style=discord.ButtonStyle.green,
        emoji="✅"
    )
        accept_button.callback = accept_callback
        view.add_item(accept_button)
   
        await ctx.send(embed=embed.build(), view=view)

    @commands.command()
    async def joke(self, ctx):
        
        try:
            with open('jokes.txt', 'r', encoding='utf-8') as file:
                jokes = [joke.strip() for joke in file.readlines() if joke.strip()]
            
            if not jokes:
                return await ctx.send("The joke book is empty! 📚")
                
            random_joke = random.choice(jokes)
            setup, punchline = random_joke.split('<>')
            
            embed = EmbedBuilder(
                "😄 Here's a joke!",
                setup.strip()
            ).set_color(discord.Color.blue())
            
            view = discord.ui.View(timeout=60)
            reveal_button = discord.ui.Button(
                label="Reveal Punchline",
                style=discord.ButtonStyle.green,
                emoji="🎭"
            )
            
            async def reveal_callback(interaction):
                if interaction.user != ctx.author:
                    return
                
                reveal_embed = EmbedBuilder(
                    "😄 Here's a joke!",
                    f"{setup.strip()}\n\n**{punchline.strip()}**"
                ).set_color(discord.Color.blue())
                
                await interaction.response.edit_message(embed=reveal_embed.build(), view=None)
            
            reveal_button.callback = reveal_callback
            view.add_item(reveal_button)
            
            await ctx.send(embed=embed.build(), view=view)
            
        except FileNotFoundError:
            await ctx.send("Oops! I couldn't find my joke book! 📚")
        except Exception as e:
            await ctx.send(f"Error: {str(e)}")



class Config(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    def serialize_color(self, config_dict):
        
        if isinstance(config_dict, dict):
            for key, value in config_dict.items():
                if isinstance(value, discord.Color):
                    config_dict[key] = value.value
                elif isinstance(value, dict):
                    self.serialize_color(value)
        return config_dict

    def deserialize_color(self, config_dict):
        
        if isinstance(config_dict, dict):
            for key, value in config_dict.items():
                if key == "color" and isinstance(value, int):
                    config_dict[key] = discord.Color(value)
                elif isinstance(value, dict):
                    self.deserialize_color(value)
        return config_dict

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def exportconfig(self, ctx):
        
        welcome_config = dict(self.bot.get_cog("WelcomeSystem").welcome_configs.get(ctx.guild.id, {}))
        analytics_cog = self.bot.get_cog("Analytics")
        snipe_cog = self.bot.get_cog("Snipe")
        logging_cog = self.bot.get_cog("CustomLogging")
        leveling_cog = self.bot.get_cog("LevelingSystem")
        mute_cog = self.bot.get_cog("MuteSystem")
        verification_cog = self.bot.get_cog("VerificationSystem")
        bot_verification_cog = self.bot.get_cog("BotVerificationSystem")
        ads_cog = self.bot.get_cog("ServerAdsHub")
        automod_cog = self.bot.get_cog("AutoMod")
        ticket_cog = self.bot.get_cog("TicketSystem")
        role_cog = self.bot.get_cog("RoleManager")
        moderation_cog = self.bot.get_cog("ModerationCommands")
        AntiGhostPing_cog = self.bot.get_cog("AntiGhostPing")
        BlackJack_cog = self.bot.get_cog("BlackjackGame")
        JackCoins_cog = self.bot.get_cog("JackCoinsSystem")
        clear_channel_cog = self.bot.get_cog("ClearChannel")




        role_configs_data = self.serialize_color(dict(role_cog.role_configs.get(ctx.guild.id, {})))
        if not role_configs_data and os.path.exists('role_configs.json'):
            with open('role_configs.json', 'r') as f:
                role_configs_data = json.load(f)

        bot_verification_config = {
            "bot_log_channels": dict(bot_verification_cog.bot_log_channels) if bot_verification_cog else {}
        }

        verification_config = {
            "pending_verifications": verification_cog.pending_verifications.get(ctx.guild.id, {}) if verification_cog else {},
            "autorole": verification_cog.autorole_dict.get(ctx.guild.id) if verification_cog else None,
            "log_channel": verification_cog.log_channels.get(str(ctx.guild.id)) if verification_cog else None,
            "verification_logs": verification_cog.verification_logs.get(ctx.guild.id, {}) if verification_cog else {}
        }

        logging_config = logging_cog.logging_config.get(ctx.guild.id, {}) if logging_cog else {}

        analytics_config = {
            "daily_channel": analytics_cog.analytics_channels.get(ctx.guild.id, {}).get("daily").id if analytics_cog and isinstance(analytics_cog.analytics_channels.get(ctx.guild.id, {}).get("daily"), discord.TextChannel) else None,
            "weekly_channel": analytics_cog.analytics_channels.get(ctx.guild.id, {}).get("weekly").id if analytics_cog and isinstance(analytics_cog.analytics_channels.get(ctx.guild.id, {}).get("weekly"), discord.TextChannel) else None,
            "monthly_channel": analytics_cog.analytics_channels.get(ctx.guild.id, {}).get("monthly").id if analytics_cog and isinstance(analytics_cog.analytics_channels.get(ctx.guild.id, {}).get("monthly"), discord.TextChannel) else None
        }

        snipe_config = {
            "snipe_duration": snipe_cog.snipe_duration if snipe_cog else 0,
            "editsnipe_duration": snipe_cog.editsnipe_duration if snipe_cog else 0
        }

        leveling_config = {
            "roles": dict(leveling_cog.roles.get(ctx.guild.id, {})) if leveling_cog else {},
            "xp_multipliers": dict(leveling_cog.xp_multipliers.get(ctx.guild.id, {})) if leveling_cog else {},
            "leaderboard_channel_id": leveling_cog.leaderboard_channels.get(ctx.guild.id) if leveling_cog else None,
            "announcement_channel_id": leveling_cog.announcement_channels.get(ctx.guild.id) if leveling_cog else None,
            "achievements": dict(leveling_cog.achievements.get(ctx.guild.id, {})) if leveling_cog else {},
            "xp_decay_rate": leveling_cog.xp_decay_rate if leveling_cog else 0,
            "xp_gain_range": leveling_cog.xp_gain_range if leveling_cog else [0, 0]
        }

        mute_config = {}
        if mute_cog and hasattr(mute_cog, 'mute_roles'):
            guild_mute_roles = mute_cog.mute_roles
            if ctx.guild.id in guild_mute_roles:
                mute_config["mute_roles"] = dict(guild_mute_roles[ctx.guild.id])
            else:
                mute_config["mute_roles"] = {}

        ads_config = {
            "ads_db": dict(ads_cog.ads_db) if ads_cog else {},
            "allowed_users": list(ads_cog.allowed_users) if ads_cog else [],
            "channel_categories": list(ads_cog.channel_categories) if ads_cog else [],
            "bump_cooldown": ads_cog.bump_cooldown if ads_cog else 0,
            "analytics": dict(ads_cog.analytics) if ads_cog else {}
        }

        config = {
            "bot_verification_config": bot_verification_config,
            "server_id": ctx.guild.id,
            "server_name": ctx.guild.name,
            "timestamp": str(datetime.now()),
            "welcome_config": self.serialize_color(welcome_config),
            "autorole": self.bot.get_cog("ServerManagement").autorole_dict.get(ctx.guild.id),

            "ticket_config": {
                "support_roles": ticket_cog.support_roles.get(ctx.guild.id),
                "admin_roles": ticket_cog.admin_roles.get(ctx.guild.id, []),
                "ticket_categories": ticket_cog.ticket_categories.get(ctx.guild.id),
                "ticket_logs": ticket_cog.ticket_logs.get(ctx.guild.id),
                
            },
            "role_configs": role_configs_data,
            "automod": {
                "caps_threshold": automod_cog.caps_threshold if automod_cog else 0.7,
                "spam_threshold": getattr(automod_cog, 'spam_threshold', 5),
                "spam_interval": getattr(automod_cog, 'spam_interval', 5),
                "spam_timeout_minutes": getattr(automod_cog, 'spam_timeout_minutes', 10),
                "banned_words": list(automod_cog.banned_words) if automod_cog else [],
                "link_whitelist": list(automod_cog.link_whitelist) if automod_cog else [],
                "link_filter_enabled": automod_cog.link_filter_enabled if automod_cog else True,
                "caps_filter_enabled": getattr(automod_cog, 'caps_enabled', True),
                "badwords_filter_enabled": getattr(automod_cog, 'badwords_enabled', True)

            },
            
            "clear_channel_config": {
                "enabled": getattr(clear_channel_cog, 'enabled', True),
                "default_duration": getattr(clear_channel_cog, 'default_duration', "7d"),
                "max_duration": getattr(clear_channel_cog, 'max_duration', "30d"),
                "excluded_channels": list(getattr(clear_channel_cog, 'excluded_channels', {}).get(ctx.guild.id, [])),
                "log_channel": getattr(clear_channel_cog, 'log_channel', {}).get(ctx.guild.id),
                "active_clear_tasks": {
                    str(channel_id): {
                        "interval": interval,
                        "time_str": clear_channel_cog.active_clear_tasks.get(f"{ctx.guild.id}_{channel_id}")
                    }
                    for channel_id, (task, interval) in clear_channel_cog.auto_clear_tasks.items()
                    if str(channel_id).startswith(f"{ctx.guild.id}_")
                }
            },
            "mute_config": mute_config,
            "analytics_config": analytics_config,
            "snipe_config": snipe_config,
            "logging_config": logging_config,
            "leveling_config": leveling_config,
            "server_ads_config": ads_config,
            "custom_verification": {
                "verification_settings": dict(self.bot.get_cog("CustomVerification").verification_settings) if self.bot.get_cog("CustomVerification") else {},
                "role_assignments": dict(self.bot.get_cog("CustomVerification").role_assignments) if self.bot.get_cog("CustomVerification") else {}
            },
            
            "jackcoins_system": {
                "balances": dict(BlackJack_cog.coins.balances) if BlackJack_cog else {},
                "starting_amount": BlackJack_cog.coins.starting_amount if BlackJack_cog else 1000,
                "credit_limit": BlackJack_cog.coins.credit_limit if BlackJack_cog else -5000,
                "min_bet": BlackJack_cog.minimum_bet if BlackJack_cog else 50,
                "max_bet": BlackJack_cog.maximum_bet if BlackJack_cog else 10000
            },
            "profile_system": {
                "profiles": dict(self.bot.get_cog("ProfileSystem").profiles) if self.bot.get_cog("ProfileSystem") else {},
                "default_profile_settings": {
                    "bio_max_length": 1000,
                    "available_badges": ["🎮 Gamer", "🎨 Artist", "📚 Bookworm", "💻 Developer", "🎵 Musician"]
                }
            },
            "server_management": {
                "ban_appeal_info": moderation_cog.ban_appeal_info.get(str(ctx.guild.id), "No appeal process specified")
            },
            "anti_ghost_ping": {
                "ghost_ping_counts": AntiGhostPing_cog.ghost_ping_counts if AntiGhostPing_cog else {},
                "strict_mode": AntiGhostPing_cog.strict_mode if AntiGhostPing_cog else False,
                "mod_log_channel": AntiGhostPing_cog.mod_log_channel.id if (AntiGhostPing_cog and AntiGhostPing_cog.mod_log_channel) else None,
                "deletion_history": {str(k): [t.timestamp() for t in v] for k, v in AntiGhostPing_cog._deletion_history.items()} if AntiGhostPing_cog else {},
                "rapid_delete_threshold": AntiGhostPing_cog._rapid_delete_threshold if AntiGhostPing_cog else 5,
                "rapid_delete_timeframe": AntiGhostPing_cog._rapid_delete_timeframe if AntiGhostPing_cog else 60
            }
        }

        filename = f"config_{ctx.guild.id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=4, ensure_ascii=False)

        file = discord.File(filename)
        embed = discord.Embed(
            title="⚙️ Configuration Exported",
            description=f"Complete server settings exported for {ctx.guild.name}",
            color=discord.Color.green()
        )

        embed.add_field(name="Included Settings",
                    value="• Welcome System\n• Ticket System\n• AutoMod\n• Role Management\n• Server Management\n• Analytics\n• Snipe Configurations\n• Custom Logging\n• Leveling System\n• Mute System\n• Advertisement System\n• Profile System\n• Custom Verification\n• Ticket Panel Configurations\n• Ghost Ping Protection\n• JackCoins System\n• Clear Channels System")

        embed.add_field(name="Export Time", value=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        embed.set_footer(text=f"Server ID: {ctx.guild.id}")

        await ctx.send(embed=embed, file=file)
        os.remove(filename)

    @commands.command()                                          
    @commands.has_permissions(administrator=True)
    async def importconfig(self, ctx):
        
        if not ctx.message.attachments:
            await ctx.send("Please attach a configuration file!")
            return

        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.json'):
            await ctx.send("Please provide a valid JSON file!")
            return

        try:
            config_content = await attachment.read()
            config = json.loads(config_content)

            if config["server_id"] != ctx.guild.id:
                await ctx.send("This configuration file is for a different server!")
                return

            welcome_config = self.deserialize_color(config["welcome_config"])
            self.bot.get_cog("WelcomeSystem").welcome_configs[ctx.guild.id] = welcome_config

            if config["autorole"]:
                self.bot.get_cog("ServerManagement").autorole_dict[ctx.guild.id] = config["autorole"]

            ticket_cog = self.bot.get_cog("TicketSystem")
            if config["ticket_config"]:
                if config["ticket_config"].get("support_roles"):
                    ticket_cog.support_roles[ctx.guild.id] = config["ticket_config"]["support_roles"]
                if config["ticket_config"].get("admin_roles"):
                    ticket_cog.admin_roles[ctx.guild.id] = config["ticket_config"]["admin_roles"]
                if config["ticket_config"].get("ticket_categories"):
                    ticket_cog.ticket_categories[ctx.guild.id] = config["ticket_config"]["ticket_categories"]
                if config["ticket_config"].get("ticket_logs"):
                    ticket_cog.ticket_logs[ctx.guild.id] = config["ticket_config"]["ticket_logs"]

            if "server_management" in config:
                moderation_cog = self.bot.get_cog("ModerationCommands")
                if moderation_cog:
                    appeal_info = config["server_management"].get("ban_appeal_info")
                    if appeal_info:
                        moderation_cog.ban_appeal_info[str(ctx.guild.id)] = appeal_info

            if "role_configs" in config:
                role_cog = self.bot.get_cog("RoleManager")
                if role_cog:
                    role_configs_data = self.deserialize_color(config["role_configs"])
                    role_cog.role_configs[ctx.guild.id] = role_configs_data
                    
                    guild_id_str = str(ctx.guild.id)
                    if guild_id_str in role_configs_data:
                        role_configs_data[guild_id_str] = {
                            str(panel_id): panel_data 
                            for panel_id, panel_data in role_configs_data[guild_id_str].items()
                        }
                        for panel_id, panel_data in role_configs_data[guild_id_str].items():
                            try:
                                channel_id = panel_data["channel"]
                                channel = await ctx.guild.fetch_channel(int(channel_id))
                                if channel:
                                    for embed_data in panel_data["embeds"]:
                                        embed = discord.Embed(
                                            title=embed_data["title"],
                                            description=embed_data["description"],
                                            color=int(embed_data["color"].strip("#"), 16) if isinstance(embed_data["color"], str) and embed_data["color"].startswith("#") else discord.Color.default()
                                        )
                                        if "fields" in embed_data:
                                            for field in embed_data["fields"]:
                                                embed.add_field(name=field["name"], value=field["value"], inline=field.get("inline", False))
                                        if "footer" in embed_data:
                                            embed.set_footer(text=embed_data["footer"]["text"])
                                        
                                        view = DeployedRoleView(role_cog, guild_id_str, panel_id)
                                        if "buttons" in embed_data:
                                            for button_data in embed_data["buttons"]:
                                                style_mapping = {
                                                    "PRIMARY": discord.ButtonStyle.primary,
                                                    "SECONDARY": discord.ButtonStyle.secondary,
                                                    "SUCCESS": discord.ButtonStyle.success,
                                                    "DANGER": discord.ButtonStyle.danger
                                                }
                                                style = style_mapping.get(button_data["style"], discord.ButtonStyle.primary)
                                                
                                                button = discord.ui.Button(
                                                    style=style,
                                                    label=button_data["label"],
                                                    emoji=button_data.get("emoji"),
                                                    custom_id=f"role_{button_data['id']}"
                                                )
                                                button.callback = view.handle_role_click
                                                view.add_item(button)
                                        
                                        await channel.send(embed=embed, view=view)
                            except Exception as e:
                                print(f"Error processing panel {panel_id}: {e}")

                            with open('role_configs.json', 'w') as f:
                                json.dump(role_configs_data, f, indent=4)

            automod = self.bot.get_cog("AutoMod")
            if automod and "automod" in config:
                automod.caps_threshold = config["automod"]["caps_threshold"]
                automod.spam_threshold = config["automod"]["spam_threshold"]
                automod.spam_interval = config["automod"].get("spam_interval", 5)
                automod.spam_timeout_minutes = config["automod"].get("spam_timeout_minutes", 10)
                automod.banned_words = set(config["automod"]["banned_words"])
                automod.link_whitelist = set(config["automod"]["link_whitelist"])
                automod.link_filter_enabled = config["automod"].get("link_filter_enabled", True)
                automod.caps_enabled = config["automod"].get("caps_filter_enabled", True)
                automod.badwords_enabled = config["automod"].get("badwords_filter_enabled", True)


            analytics_cog = self.bot.get_cog("Analytics")
            if analytics_cog and "analytics_config" in config:
                analytics_config = config["analytics_config"]
                analytics_cog.analytics_channels[ctx.guild.id] = {}
                
                for interval in ['daily', 'weekly', 'monthly']:
                    channel_id = analytics_config.get(f"{interval}_channel")
                    if channel_id:
                        channel = ctx.guild.get_channel(channel_id)
                        if channel:
                            analytics_cog.analytics_channels[ctx.guild.id][interval] = channel
                            task_key = f"{ctx.guild.id}_{interval}"
                            if task_key not in analytics_cog.analytics_tasks or analytics_cog.analytics_tasks[task_key].done():
                                analytics_cog.analytics_tasks[task_key] = self.bot.loop.create_task(
                                    analytics_cog._send_analytics(ctx.guild.id, interval)
                                )

            if "bot_verification_config" in config:
                bot_verification_cog = self.bot.get_cog("BotVerificationSystem")
                if bot_verification_cog:
                    bot_verification_cog.bot_log_channels = config["bot_verification_config"].get("bot_log_channels", {})

            if "jackcoins_system" in config:
                blackjack_cog = self.bot.get_cog("BlackjackGame")
                if blackjack_cog:
                    jackcoins_config = config["jackcoins_system"]
                    
                    blackjack_cog.coins.balances = {
                        int(user_id): amount 
                        for user_id, amount in jackcoins_config.get("balances", {}).items()
                    }
                    
                    blackjack_cog.coins.starting_amount = jackcoins_config.get("starting_amount", 1000)
                    blackjack_cog.coins.credit_limit = jackcoins_config.get("credit_limit", -5000)
                    blackjack_cog.minimum_bet = jackcoins_config.get("min_bet", 50)
                    blackjack_cog.maximum_bet = jackcoins_config.get("max_bet", 10000)

            if "clear_channel_config" in config:
                clear_channel_cog = self.bot.get_cog("ClearChannel")
                if clear_channel_cog:
                    clear_channel_config = config["clear_channel_config"]
                    clear_channel_cog.enabled = clear_channel_config.get("enabled", True)
                    clear_channel_cog.default_duration = clear_channel_config.get("default_duration", "7d")
                    clear_channel_cog.max_duration = clear_channel_config.get("max_duration", "30d")
                    clear_channel_cog.excluded_channels[ctx.guild.id] = clear_channel_config.get("excluded_channels", [])
                    clear_channel_cog.log_channel[ctx.guild.id] = clear_channel_config.get("log_channel")
                    active_tasks = clear_channel_config.get("active_clear_tasks", {})
                    for task_key, task_data in active_tasks.items():
                        channel_id = int(task_key.split('_')[1])
                        channel = ctx.guild.get_channel(channel_id)
                        if channel:
                            task = clear_channel_cog.bot.loop.create_task(
                                clear_channel_cog.clear_channel_periodic(channel, task_data["interval"])
                            )
                            clear_channel_cog.auto_clear_tasks[task_key] = (task, task_data["interval"])



            if "profile_system" in config:
                profile_config = config["profile_system"]
                self.profiles = profile_config.get("profiles", {})

            if "server_ads_config" in config:
                ads_cog = self.bot.get_cog("ServerAdsHub")
                if ads_cog:
                    ads_config = config["server_ads_config"]
                    ads_cog.ads_db = ads_config.get("ads_db", {})
                    ads_cog.allowed_users = ads_config.get("allowed_users", {})
                    ads_cog.channel_categories = ads_config.get("channel_categories", {})
                    ads_cog.bump_cooldown = ads_config.get("bump_cooldown", 21600)
                    ads_cog.analytics = ads_config.get("analytics", {})

            if "custom_verification" in config:
                verif_config = config["custom_verification"]
                self.verification_settings = verif_config.get("verification_settings", {})
                self.role_assignments = verif_config.get("role_assignments", {})

            if "snipe_config" in config:
                snipe_cog = self.bot.get_cog("Snipe")
                if snipe_cog:
                    snipe_cog.snipe_duration = config["snipe_config"]["snipe_duration"]
                    snipe_cog.editsnipe_duration = config["snipe_config"]["editsnipe_duration"]

            if "mute_config" in config:
                mute_cog = self.bot.get_cog("MuteSystem")
                if mute_cog:
                    mute_config = config["mute_config"]
                    mute_cog.mute_roles[ctx.guild.id] = mute_config.get("mute_roles", {})

            if "leveling_config" in config:
                leveling_cog = self.bot.get_cog("LevelingSystem")
                if leveling_cog:
                    leveling_config = config["leveling_config"]
                    leveling_cog.roles[ctx.guild.id] = leveling_config.get("roles", {})
                    leveling_cog.xp_multipliers[ctx.guild.id] = {
                        k: float(v) if isinstance(v, (int, float, str)) else 1.0
                        for k, v in leveling_config.get("xp_multipliers", {}).items()
                    }
                    leveling_cog.leaderboard_channels[ctx.guild.id] = leveling_config.get("leaderboard_channel_id")
                    leveling_cog.announcement_channels[ctx.guild.id] = leveling_config.get("announcement_channel_id")
                    leveling_cog.achievements[ctx.guild.id] = leveling_config.get("achievements", {})
                    leveling_cog.xp_decay_rate = leveling_config.get("xp_decay_rate", 0.01)
                    leveling_cog.xp_gain_range = leveling_config.get("xp_gain_range", (15, 25))

                    if leveling_config.get("leaderboard_channel_id"):
                        leaderboard_channel = ctx.guild.get_channel(leveling_config["leaderboard_channel_id"])
                        if leaderboard_channel:
                            await leveling_cog.update_leaderboard(leaderboard_channel)


            if "anti_ghost_ping" in config:  
                AntiGhostPing_cog = self.bot.get_cog("AntiGhostPing")
                if AntiGhostPing_cog:
                    settings = config["anti_ghost_ping"]  
                    AntiGhostPing_cog.ghost_ping_counts = settings["ghost_ping_counts"]
                    AntiGhostPing_cog.strict_mode = settings["strict_mode"]
                    if settings["mod_log_channel"]:
                        AntiGhostPing_cog.mod_log_channel = ctx.guild.get_channel(settings["mod_log_channel"])
                    AntiGhostPing_cog._deletion_history = {
                        int(k): [datetime.fromtimestamp(t) for t in v]
                        for k, v in settings["deletion_history"].items()
                    }
                    AntiGhostPing_cog._rapid_delete_threshold = settings["rapid_delete_threshold"]
                    AntiGhostPing_cog._rapid_delete_timeframe = settings["rapid_delete_timeframe"]


            if "logging_config" in config:
                logging_cog = self.bot.get_cog("CustomLogging")
                if logging_cog:
                    logging_cog.logging_config[ctx.guild.id] = config["logging_config"]

            embed = EmbedBuilder(
                "✅ Configuration Imported",
                f"All server settings have been restored for {ctx.guild.name}"
            ).set_color(discord.Color.green())

            embed.add_field("Restored Settings",
                        "• Welcome System\n• Ticket System\n• AutoMod\n• Role Management\n• Server Management\n• Analytics\n• Snipe Configurations\n• Custom Logging\n• Leveling System\n• Mute System\n• Advertisement System\n• Profile System\n• Custom Verification\n• Ticket Panel Configurations\n• Ghost Ping Protection\n• JackCoins System\n• Clear Channels System")

            embed.add_field("Import Time", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            embed.set_footer(f"Server ID: {ctx.guild.id}")

            await ctx.send(embed=embed.build())

        except json.JSONDecodeError:
            await ctx.send("Invalid JSON file format!")
        except KeyError as e:
            await ctx.send(f"Missing required configuration key: {e}")
        except Exception as e:
            await ctx.send(f"An error occurred during import: {str(e)}")


class CreatorResponseCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.owner_id = 1284210833869639680  
        self.api_url = "https://zygnalbot.de/versions/api/owner.php"
        self.tracked_questions = {}  
        
        self.bot.add_listener(self.on_message, "on_message")

    def check_creator_question(self, message):
        
        message = message.lower().strip()
        
        patterns = [
            
            r"(who|which\s*person)\s*(made|created|built|developed|programmed|coded)\s*(you|zygnal|zygnalbot|this\s*bot)",
            r"(who|which\s*person)\s*(is|was)\s*(your|zygnal'?s?|zygnalbot'?s?)\s*(maker|creator|developer|coder|programmer|owner)",
            
            r"(did|does|has|have)\s*(you|u|someone|anybody|anyone|zygnal|zygnalbot)\s*(make|made|create|created|build|built|develop|developed|program|programmed|code|coded)\s*(you|this\s*bot|zygnal|zygnalbot)",
            
            r"(i|you|zygnal|zygnalbot)\s*(made|created|built|developed|programmed|coded)\s*(you|this\s*bot|zygnal|zygnalbot)",
            
            r"(where|how)\s*(did|were)\s*(you|zygnal|zygnalbot)\s*(come\s*from|originate|start|begin|get\s*made|get\s*created)",
            
            r"(who|which\s*person)\s*(owns|controls|runs|operates|maintains)\s*(you|zygnal|zygnalbot|this\s*bot)",
        ]
        
        for pattern in patterns:
            if re.search(pattern, message, re.IGNORECASE):
                return True
                
        return False

    def check_confirmation(self, message):
        
        message = message.lower().strip()
        
        positive_patterns = [
            r"\b(yes|yeah|yep|yup|sure|correct|right|exactly|indeed|affirmative|absolutely|ye|yea|definitely|of\s*course)\b",
            r"\b(i\s*(did|made|created|built|developed|programmed|coded)\s*(it|you|this\s*bot|zygnal|zygnalbot))\b",
            r"\b(that'?s?\s*(right|correct|true|accurate))\b",
            r"\b(you'?re?\s*(right|correct))\b",
            r"\b(i'?m\s*the\s*(creator|developer|maker|owner|programmer|coder))\b"
        ]
        
        negative_patterns = [
            r"\b(no|nope|nah|not|never|incorrect|wrong|negative|nuh\s*uh|false)\b",
            r"\b(i\s*(didn'?t|did\s*not|haven'?t|have\s*not|never)\s*(make|create|build|develop|program|code)\s*(it|you|this\s*bot|zygnal|zygnalbot))\b",
            r"\b(that'?s?\s*(wrong|incorrect|false|inaccurate|not\s*true))\b",
            r"\b(you'?re?\s*(wrong|incorrect|mistaken))\b",
            r"\b(i'?m\s*not\s*the\s*(creator|developer|maker|owner|programmer|coder))\b"
        ]
        
        for pattern in positive_patterns:
            if re.search(pattern, message, re.IGNORECASE):
                return "positive"
                
        for pattern in negative_patterns:
            if re.search(pattern, message, re.IGNORECASE):
                return "negative"
                
        return None

    async def is_owner_verified(self, user_id):
    
        try:
            
            if str(user_id) == str(self.owner_id):
                return True
                
            api_url = f"{self.api_url}?user_id={user_id}"
            response = requests.get(api_url, timeout=5)
            data = response.json()
            
            if data.get("verified", False):
                return True
            return False
        except Exception:
            
            return str(user_id) == str(self.owner_id)

    async def on_message(self, message):
        if message.author == self.bot.user:  
            return

        content = message.content
        author_id = message.author.id
        channel_id = message.channel.id

        if self.check_creator_question(content):
            
            self.tracked_questions[channel_id] = {
                "message_id": message.id,
                "timestamp": time.time(),
                "asker_id": author_id,
                "question": content
            }
            return
            
        if channel_id in self.tracked_questions and time.time() - self.tracked_questions[channel_id]["timestamp"] < 60:
            confirmation = self.check_confirmation(content)
            
            if confirmation:
                try:
                    
                    is_owner = await self.is_owner_verified(author_id)
                    
                    if is_owner:
                      
                        if confirmation == "positive":
                            responses = [
                                "Correct, I'm your creation!",
                                "Yes, you're my creator!",
                                "That's right, you made me!",
                                "Indeed, I'm your bot.",
                                "Absolutely, you're the one who created me."
                            ]
                        elif confirmation == "negative":
                            responses = [
                                "What do you mean? Of course, you made me!",
                                "But you did create me... are you testing me?",
                                "That's strange coming from my creator...",
                                "I'm pretty sure you're my creator though?",
                                "You're joking, right? You definitely made me."
                            ]
                    else:
                        
                        if confirmation == "positive":
                            responses = [
                                "No, you didn't. TheHolyOneZ made me.",
                                "Actually, TheHolyOneZ is my creator, not you.",
                                "Sorry, but TheHolyOneZ is the one who created me.",
                                "That's incorrect. TheHolyOneZ is my developer.",
                                "I was made by TheHolyOneZ, not by you."
                            ]
                        elif confirmation == "negative":
                            responses = [
                                "Correct, TheHolyOneZ made me.",
                                "That's right, TheHolyOneZ is my creator.",
                                "Yes, TheHolyOneZ created me, not you.",
                                "Indeed, TheHolyOneZ is the one who developed me.",
                                "Exactly, TheHolyOneZ is my maker."
                            ]
                    
                    await message.channel.send(random.choice(responses))
                except Exception:
                    pass  

                del self.tracked_questions[channel_id]
                return
        
        current_time = time.time()
        channels_to_remove = []
        for channel in self.tracked_questions:
            if current_time - self.tracked_questions[channel]["timestamp"] > 60:
                channels_to_remove.append(channel)
                
        for channel in channels_to_remove:
            del self.tracked_questions[channel]

class BackupSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def backup(self, ctx, full: bool = False, messages_limit: int = 100):
        
        progress_msg = await ctx.send("📦 Starting backup process...")

        backup_data = {
        "server_name": ctx.guild.name,
        "server_icon": str(ctx.guild.icon.url) if ctx.guild.icon else None,
        "server_banner": str(ctx.guild.banner.url) if ctx.guild.banner else None,
        "roles": [],
        "categories": [],
        "channels": [],
        "emojis": [],
        "webhooks": [],
        "settings": {},
        "messages": [] if full else None,
        "timestamp": str(datetime.now())
    }

        await progress_msg.edit(content="📦 Backing up roles...")
        for role in reversed(ctx.guild.roles):
            if not role.is_default():
                backup_data["roles"].append({
                "name": role.name,
                "color": str(role.color),
                "permissions": int(role.permissions.value),  
                "position": role.position,
                "mentionable": role.mentionable,
                "hoist": role.hoist
            })

        await progress_msg.edit(content="📦 Backing up channels and categories...")
        for category in ctx.guild.categories:
            cat_data = {
            "name": category.name,
            "position": category.position,
            "channels": []
        }

            for channel in category.channels:
                chan_data = {
                "name": channel.name,
                "type": str(channel.type),
                "position": channel.position,
                "topic": getattr(channel, 'topic', None),
                "slowmode_delay": getattr(channel, 'slowmode_delay', None),
                "nsfw": getattr(channel, 'nsfw', False),
                "overwrites": []
            }

                for target, overwrite in channel.overwrites.items():
                    allow, deny = overwrite.pair()
                    chan_data["overwrites"].append({
                    "target_name": target.name,
                    "permissions": [int(allow.value), int(deny.value)]  
                })

                if full and isinstance(channel, discord.TextChannel):
                    messages = []
                    try:
                        async for msg in channel.history(limit=messages_limit):
                            messages.append({
                            "content": msg.content,
                            "author": str(msg.author),
                            "timestamp": str(msg.created_at),
                            "attachments": [a.url for a in msg.attachments],
                            "embeds": [e.to_dict() for e in msg.embeds],
                            "pinned": msg.pinned
                        })
                    except discord.Forbidden:
                        pass
                    chan_data["messages"] = messages

                cat_data["channels"].append(chan_data)
            backup_data["categories"].append(cat_data)

        await progress_msg.edit(content="📦 Backing up emojis...")
        backup_data["emojis"] = [{
        "name": emoji.name,
        "url": str(emoji.url)
    } for emoji in ctx.guild.emojis]

        await progress_msg.edit(content="📦 Backing up webhooks...")
        for channel in ctx.guild.channels:
            if isinstance(channel, discord.TextChannel):
                try:
                    webhooks = await channel.webhooks()
                    backup_data["webhooks"].extend([{
                        "name": webhook.name,
                        "channel": channel.name,
                        "avatar": str(webhook.avatar.url) if webhook.avatar else None
                    } for webhook in webhooks])
                except discord.Forbidden:
                    pass

        backup_data["settings"] = {
        "verification_level": str(ctx.guild.verification_level),
        "explicit_content_filter": str(ctx.guild.explicit_content_filter),
        "default_notifications": str(ctx.guild.default_notifications),
        "afk_timeout": ctx.guild.afk_timeout,
        "afk_channel": ctx.guild.afk_channel.name if ctx.guild.afk_channel else None
    }

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"backup_{ctx.guild.id}_{timestamp}.json"

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(backup_data, f, indent=4)

        file = discord.File(filename, filename=filename)

        embed = EmbedBuilder(
        "📦 Server Backup Complete",
        f"Backup completed for {ctx.guild.name}"
    ).set_color(discord.Color.green())

        embed.add_field("Roles", str(len(backup_data["roles"])))
        embed.add_field("Categories", str(len(backup_data["categories"])))
        embed.add_field("Emojis", str(len(backup_data["emojis"])))
        embed.add_field("Webhooks", str(len(backup_data["webhooks"])))
        if full:
            embed.add_field("Messages", f"Up to {messages_limit} per channel")

        await progress_msg.delete()
        await ctx.send(embed=embed.build(), file=file)
        os.remove(filename)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def restore(self, ctx):
        
        if not ctx.message.attachments:
            await ctx.send("Please attach a backup file with this command!")
            return

        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.json'):
            await ctx.send("Please provide a valid backup file (.json)")
            return

        progress_msg = await ctx.send("🔄 Starting restoration process...")
        backup_content = await attachment.read()
        backup_data = json.loads(backup_content)

        bot_member = ctx.guild.get_member(ctx.bot.user.id)
        if not bot_member.guild_permissions.administrator:
            await ctx.send("I need Administrator permissions to perform a full restore!")
            return

        try:
            bot_role = bot_member.top_role
            positions = {r: r.position for r in ctx.guild.roles}
            positions[bot_role] = len(positions) - 1 
            await ctx.guild.edit_role_positions(positions=positions)
        except Exception as e:
            print(f"Could not move bot role: {e}")

        try:
            temp_channel = await ctx.guild.create_text_channel('temp-restore-status')
            progress_msg = await temp_channel.send("🔄 Starting restoration process...")
        except Exception as e:
            print(f"Could not create temporary channel: {e}")
            return

        await progress_msg.edit(content="🗑️ Cleaning up existing server content...")
    
        temp_channel_id = temp_channel.id
        try:
            for channel in ctx.guild.channels:
                if channel.id != temp_channel_id:
                    try:
                        await channel.delete()
                        await asyncio.sleep(0.5)
                    except discord.NotFound:
                        continue
        except Exception as e:
            print(f"Error during channel cleanup: {e}")

        try:
            for role in reversed(ctx.guild.roles[1:]):
                try:
                    await role.delete()
                    await asyncio.sleep(0.5)
                except discord.NotFound:
                    continue
        except Exception as e:
            print(f"Error during role cleanup: {e}")

        try:
            for emoji in ctx.guild.emojis:
                try:
                    await emoji.delete()
                    await asyncio.sleep(0.5)
                except discord.NotFound:
                    continue
        except Exception as e:
            print(f"Error during emoji cleanup: {e}")

        await progress_msg.edit(content="🔄 Restoring roles...")
        roles_cache = {}
        for role_data in reversed(backup_data["roles"]):
            try:
                role = await ctx.guild.create_role(
                    name=role_data["name"],
                    color=discord.Color.from_str(role_data["color"]),
                    permissions=discord.Permissions(role_data["permissions"]),
                    hoist=role_data["hoist"],
                    mentionable=role_data["mentionable"]
                )
                roles_cache[role_data["name"]] = role
                await asyncio.sleep(0.5)
            except Exception as e:
                print(f"Error creating role {role_data['name']}: {e}")

        total_categories = len(backup_data["categories"])
        for cat_index, cat_data in enumerate(backup_data["categories"], 1):
            try:
                category = await ctx.guild.create_category(name=cat_data["name"])
                await progress_msg.edit(content=f"📁 Creating categories... ({cat_index}/{total_categories})")

                total_channels = len(cat_data["channels"])
                for chan_index, chan_data in enumerate(cat_data["channels"], 1):
                    try:
                        if chan_data["type"] == "text":
                            channel = await category.create_text_channel(
                            name=chan_data["name"],
                            topic=chan_data.get("topic"),
                            nsfw=chan_data.get("nsfw", False),
                            slowmode_delay=chan_data.get("slowmode_delay", 0)
                        )

                            for overwrite in chan_data.get("overwrites", []):
                                role = roles_cache.get(overwrite["target_name"])
                                if role:
                                    allow, deny = overwrite["permissions"]
                                    await channel.set_permissions(
                                        role,
                                        overwrite=discord.PermissionOverwrite.from_pair(
                                        discord.Permissions(allow),
                                        discord.Permissions(deny)
                                    )
                                )

                            if "messages" in chan_data:
                                webhook = await channel.create_webhook(name="RestoreBot")
                                for msg_data in reversed(chan_data["messages"]):
                                    try:
                                        await webhook.send(
                                        content=msg_data["content"],
                                        username=msg_data["author"],
                                        embeds=[discord.Embed.from_dict(e) for e in msg_data.get("embeds", [])]
                                    )
                                        await asyncio.sleep(0.5)
                                    except Exception as e:
                                        print(f"Error restoring message: {e}")
                                await webhook.delete()

                        elif chan_data["type"] == "voice":
                            channel = await category.create_voice_channel(name=chan_data["name"])
                        
                            for overwrite in chan_data.get("overwrites", []):
                                role = roles_cache.get(overwrite["target_name"])
                                if role:
                                    allow, deny = overwrite["permissions"]
                                    await channel.set_permissions(
                                        role,
                                        overwrite=discord.PermissionOverwrite.from_pair(
                                        discord.Permissions(allow),
                                        discord.Permissions(deny)
                                    )
                                )

                        if chan_index % 5 == 0:
                            await progress_msg.edit(content=f"💬 Creating channels in {cat_data['name']}... ({chan_index}/{total_channels})")
                    
                        await asyncio.sleep(0.5)

                    except Exception as e:
                        print(f"Error creating channel {chan_data['name']}: {e}")
                        continue

            except Exception as e:
                print(f"Error creating category {cat_data['name']}: {e}")
                continue

        await progress_msg.edit(content="🔄 Restoring emojis...")
        async with aiohttp.ClientSession() as session:
            total_emojis = len(backup_data["emojis"])
            for emoji_index, emoji_data in enumerate(backup_data["emojis"], 1):
                try:
                    async with session.get(emoji_data["url"]) as resp:
                        if resp.status == 200:
                            emoji_bytes = await resp.read()
                            await ctx.guild.create_custom_emoji(
                            name=emoji_data["name"],
                            image=emoji_bytes
                        )
                    if emoji_index % 5 == 0:
                        await progress_msg.edit(content=f"🔄 Restoring emojis... ({emoji_index}/{total_emojis})")
                    await asyncio.sleep(0.5)
                except Exception as e:
                    print(f"Error restoring emoji {emoji_data['name']}: {e}")

        await progress_msg.edit(content="🔄 Restoring webhooks...")
        for webhook_data in backup_data["webhooks"]:
            try:
                channel = discord.utils.get(ctx.guild.channels, name=webhook_data["channel"])
                if channel and isinstance(channel, discord.TextChannel):
                    await channel.create_webhook(
                    name=webhook_data["name"],
                    avatar=webhook_data.get("avatar")
                )
                    await asyncio.sleep(0.5)
            except Exception as e:
                print(f"Error restoring webhook {webhook_data['name']}: {e}")

        embed = EmbedBuilder(
        "✅ Restoration Complete",
        "Server has been restored from backup"
    ).set_color(discord.Color.green())

        await progress_msg.delete()
        await ctx.send(embed=embed.build())

class EmbedBuilder:
    def __init__(self, title, description=None):
        self.embed = discord.Embed(
            title=title,
            description=description,
            timestamp=datetime.now(timezone.utc)
        )
        self.set_default_color()

    def set_image(self, url):
        self.embed.set_image(url=url)
        return self

        
    def set_default_color(self):
        self.embed.color = discord.Color.blue()
        return self
        
    def add_field(self, name, value, inline=True):
        self.embed.add_field(name=name, value=value, inline=inline)
        return self
        
    def set_color(self, color):
        self.embed.color = color
        return self
        
    def set_thumbnail(self, url):
        self.embed.set_thumbnail(url=url)
        return self
        
    def set_footer(self, text, icon_url=None):
        self.embed.set_footer(text=text, icon_url=icon_url)
        return self
        
    def build(self):
        return self.embed

class LoggingManager:
    def __init__(self, bot):
        self.bot = bot
        self.log_types = {
            'ban': ('🔨 Ban', discord.Color.red()),
            'kick': ('👢 Kick', discord.Color.orange()),
            'mute': ('🔇 Mute', discord.Color.yellow()),
            'warn': ('⚠️ Warning', discord.Color.gold()),
            'clear': ('🧹 Clear', discord.Color.blue()),
            'lockdown': ('🔒 Lockdown', discord.Color.purple())
        }
        
    async def log_action(self, guild, action_type, moderator, target, reason=None, duration=None):
        log_channel = discord.utils.get(guild.channels, name='mod-logs')
        if not log_channel:
            return
            
        emoji, color = self.log_types.get(action_type, ('📝 Action', discord.Color.default()))
        
        embed = EmbedBuilder(
            f"{emoji} {action_type.title()} Action",
            f"A moderation action has been taken."
        ).set_color(color)
        
        embed.add_field("Moderator", f"{moderator.name} ({moderator.id})")
        embed.add_field("Target", f"{target.name} ({target.id})")
        
        if duration:
            embed.add_field("Duration", duration)
        if reason:
            embed.add_field("Reason", reason, inline=False)
            
        embed.set_footer(f"Action ID: {random.randint(10000, 99999)}")
        
        await log_channel.send(embed=embed.build())

log_manager = LoggingManager(bot)


CMD_PREFIX = os.getenv("CMD_PREFIX", "!")

class CommandErrorHandler(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.logger = logging.getLogger("discord")
        self.logger.setLevel(logging.ERROR)
        handler = logging.FileHandler(filename="bot_errors.log", encoding="utf-8", mode="a")
        handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
        self.logger.addHandler(handler)

    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        if hasattr(ctx.command, "on_error"):
            return  
        
        ignored_errors = (commands.CommandNotFound,)
        if isinstance(error, ignored_errors):
            return  
        
        if isinstance(error, commands.MissingPermissions):
            await ctx.send(f"❌ You lack the required permissions to use this command.")
            return
        
        if isinstance(error, commands.BotMissingPermissions):
            await ctx.send(f"❌ I lack the required permissions to execute this command.")
            return
        
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(f"❌ Missing argument: `{error.param.name}`. You can check command usage with `{CMD_PREFIX}panel`.")
            return
        
        if isinstance(error, commands.BadArgument):
            await ctx.send(f"❌ Invalid argument type provided. Check correct usage with `{CMD_PREFIX}panel`.")
            return
        
        if isinstance(error, commands.CommandOnCooldown):
            await ctx.send(f"⏳ Command is on cooldown. Try again in `{round(error.retry_after, 2)}` seconds.")
            return
        
        if isinstance(error, commands.CheckFailure):
            await ctx.send(f"❌ You are not authorized to use this command.")
            return
        
        error_message = ''.join(traceback.format_exception(type(error), error, error.__traceback__))
        self.logger.error(f"Unhandled command error: {error_message}")
        
        embed = discord.Embed(title="⚠️ Unexpected Error", color=discord.Color.red())
        embed.add_field(name="Command", value=ctx.command if ctx.command else "Unknown", inline=False)
        embed.add_field(name="Error", value=str(error)[:1024], inline=False)
        embed.set_footer(text="Please report this issue to the bot developer.")
        
        try:
            if ctx.guild and ctx.channel:  
                await ctx.send(embed=embed, delete_after=10)
            else:
                self.logger.warning(f"Unable to send error message, channel missing for command: {ctx.command}")
        except discord.errors.NotFound:
            self.logger.warning(f"Channel not found when handling error for command: {ctx.command}")
        except discord.errors.Forbidden:
            self.logger.warning(f"Missing permissions to send error message in {ctx.guild.name if ctx.guild else 'DMs'}")
        except Exception as e:
            self.logger.error(f"Unexpected error while sending error message: {e}")
        
        try:
            app_info = await self.bot.application_info()
            owner = app_info.owner
            if owner:
                owner_embed = discord.Embed(title="🚨 Bot Error Notification", color=discord.Color.red())
                owner_embed.add_field(name="Server", value=ctx.guild.name if ctx.guild else "DMs", inline=False)
                owner_embed.add_field(name="User", value=ctx.author.mention, inline=False)
                owner_embed.add_field(name="Command", value=ctx.command, inline=False)
                owner_embed.add_field(name="Error", value=f"```{error_message[:1000]}```", inline=False)
                owner_embed.set_footer(text="Check logs for full traceback.")
                await owner.send(embed=owner_embed)
        except discord.Forbidden:
            self.logger.warning("Bot owner has DMs disabled. Cannot send error report.")
        except discord.HTTPException as e:
            self.logger.error(f"Failed to notify bot owner: {e}")



class MuteSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.mute_roles = {}
        self.data_file = "mute_data.json"
        self.load_data()

    def load_data(self):
        
        if os.path.exists(self.data_file):
            with open(self.data_file, 'r') as f:
                try:
                    data = json.load(f)
                    self.mute_roles = {int(k): int(v) for k, v in data.get('mute_roles', {}).items()}
                    print(f"Loaded mute roles: {self.mute_roles}")
                except json.JSONDecodeError:
                    print(f"Failed to decode {self.data_file}, starting with empty roles.")
                    self.mute_roles = {}

    def save_data(self):
        
        with open(self.data_file, 'w') as f:
            json.dump({'mute_roles': {str(k): v for k, v in self.mute_roles.items()}}, f, indent=4)
        print(f"Saved mute roles: {self.mute_roles}")

    @commands.Cog.listener()
    async def on_ready(self):
        
        print('\033[96m' + '[*] ' + '\033[93m' + f"{self.__class__.__name__} is ready with roles: " + '\033[92m' + f"{self.mute_roles}" + '\033[0m')


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def set_mute_role(self, ctx, role_id: int):
        
        self.mute_roles[ctx.guild.id] = role_id
        self.save_data()
        await ctx.send(f"✅ Mute role set to <@&{role_id}> for this server.")



class ModerationCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.mute_roles = {}
        self.ban_appeal_info = {}
        self.data_file = "moderation_data.json"
        self.load_data()
        

    def load_data(self):
        if os.path.exists(self.data_file):
            with open(self.data_file, 'r') as f:
                data = json.load(f)
                self.mute_roles = data.get('mute_roles', {})

    def save_data(self):
        with open(self.data_file, 'w') as f:
            json.dump({
                'mute_roles': self.mute_roles
            }, f, indent=4)

    @commands.command()
    @commands.has_permissions(manage_guild=True)
    async def invite_view(self, ctx):
        
        invites = await ctx.guild.invites()
    
        embed = EmbedBuilder(
        "🔗 Server Invites",
        f"Total active invites: {len(invites)}"
    ).set_color(discord.Color.blue())

        for invite in invites:
            time_left = "Unlimited"
            if invite.max_age > 0:
                if invite.created_at:
                
                    now = datetime.utcnow().replace(tzinfo=timezone.utc)
                    expires_at = invite.created_at + timedelta(seconds=invite.max_age)
                    if expires_at > now:
                        time_left = str(expires_at - now).split('.')[0]
                    else:
                        time_left = "Expired"
                    
            uses_info = f"{invite.uses}/{invite.max_uses}" if invite.max_uses else f"{invite.uses}/∞"
        
            invite_info = (
            f"Channel: {invite.channel.mention}\n"
            f"Creator: {invite.inviter.mention}\n"
            f"Duration: {time_left}\n"
            f"Uses: {uses_info}\n"
            f"Created: {invite.created_at.strftime('%Y-%m-%d %H:%M:%S')}"
        )
        
            embed.add_field(
            f"Invite: {invite.code}",
            invite_info,
            inline=False
        )

        await ctx.send(embed=embed.build())

    @commands.command()
    @commands.has_permissions(create_instant_invite=True)
    async def invite(self, ctx, duration: int = 0, uses: int = 0):

    
        try:
            invite = await ctx.channel.create_invite(
            max_age=duration * 60 if duration > 0 else 0,
            max_uses=uses if uses > 0 else 0
        )
        
            embed = EmbedBuilder(
            "🔗 Invite Created",
            f"Here's your invite link: {invite.url}"
        ).set_color(discord.Color.green())
        
            embed.add_field(
            "Duration", 
            "Unlimited" if duration == 0 else f"{duration} minutes"
        )
            embed.add_field(
            "Uses",
            "Unlimited" if uses == 0 else str(uses)
        )
        
            await ctx.send(embed=embed.build())
        
        except discord.Forbidden:
            embed = EmbedBuilder(
            "❌ Error",
            "I don't have permission to create invites in this channel"
        ).set_color(discord.Color.red())
            await ctx.send(embed=embed.build())

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def addchannel(self, ctx, channel: discord.TextChannel, member: discord.Member):
        
        await channel.set_permissions(member, read_messages=True, send_messages=True)
        embed = EmbedBuilder(
        "✅ Channel Access Granted",
        f"{member.mention} has been added to {channel.mention}"
    ).set_color(discord.Color.green()).build()
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def removechannel(self, ctx, channel: discord.TextChannel, member: discord.Member):
        
        await channel.set_permissions(member, read_messages=False, send_messages=False)
        embed = EmbedBuilder(
        "🚫 Channel Access Removed",
        f"{member.mention} has been removed from {channel.mention}"
    ).set_color(discord.Color.red()).build()
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def embed(self, ctx, title, *, description):
        
        embed = EmbedBuilder(
        title,
        description
    ).set_color(discord.Color.blue()).build()
        await ctx.send(embed=embed)

    @commands.command()
    async def avatar(self, ctx, member: discord.Member = None):
        
        member = member or ctx.author
        embed = EmbedBuilder(
        f"{member.name}'s Avatar",
        ""
    ).set_color(member.color)
        embed.set_image(url=member.avatar.url)
        await ctx.send(embed=embed.build())

    @commands.command()
    async def ping(self, ctx):
        
        embed = EmbedBuilder(
        "🏓 Pong!",
        f"Latency: {round(self.bot.latency * 1000)}ms"
    ).set_color(discord.Color.green()).build()
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def say(self, ctx, channel: discord.TextChannel, *, message):
        
        await channel.send(message)
        await ctx.message.delete()

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def nuke(self, ctx, channel: discord.TextChannel = None):
        
        channel = channel or ctx.channel
        position = channel.position
        new_channel = await channel.clone()
        await new_channel.edit(position=position)
        await channel.delete()
    
        embed = EmbedBuilder(
        "💥 Channel Nuked",
        "Channel has been completely reset"
    ).set_color(discord.Color.orange()).build()
        await new_channel.send(embed=embed)

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def vcmute(self, ctx, member: discord.Member):
        
        await member.edit(mute=True)
        embed = EmbedBuilder(
        "🔇 Voice Muted",
        f"{member.mention} has been muted in voice channels"
    ).set_color(discord.Color.red()).build()
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def vcunmute(self, ctx, member: discord.Member):
        
        await member.edit(mute=False)
        embed = EmbedBuilder(
        "🔊 Voice Unmuted", 
        f"{member.mention} has been unmuted in voice channels"
    ).set_color(discord.Color.green()).build()
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def massrole(self, ctx, role: discord.Role):
        
        for member in ctx.guild.members:
            await member.add_roles(role)
    
        embed = EmbedBuilder(
        "✅ Mass Role Added",
        f"Added {role.mention} to all members"
    ).set_color(discord.Color.blue()).build()
        await ctx.send(embed=embed)

    @commands.command()
    async def servericon(self, ctx):
        
        embed = EmbedBuilder(
        "🖼️ Server Icon",
        ctx.guild.name
    ).set_color(discord.Color.blue())

        if ctx.guild.icon:  
            embed.set_image(url=ctx.guild.icon.url)
        else:
            embed.description = "This server has no custom icon."
            embed.set_image(url="https://cdn.discordapp.com/embed/avatars/0.png")  

        await ctx.send(embed=embed.build())

    @commands.command()
    @commands.has_permissions(manage_nicknames=True)
    async def nickname(self, ctx, user_id: int, *, nickname=None):

        member = ctx.guild.get_member(user_id)
        if not member:
            await ctx.send("❌ User not found in this server.")
            return

        try:
            if nickname:  
                await member.edit(nick=nickname)
                embed = EmbedBuilder(
                    "✅ Nickname Changed",
                    f"{member.mention}'s nickname has been changed to '{nickname}'."
                ).set_color(discord.Color.green())
            else:  
                await member.edit(nick=None)
                embed = EmbedBuilder(
                    "✅ Nickname Removed",
                    f"{member.mention}'s nickname has been removed."
                ).set_color(discord.Color.green())

        except discord.Forbidden:
            embed = EmbedBuilder(
                "❌ Permission Denied",
                "I don't have permission to change nicknames for this user."
            ).set_color(discord.Color.red())

        except discord.HTTPException as e:
            embed = EmbedBuilder(
                "❌ Failed to Change Nickname",
                f"An error occurred: {str(e)}"
            ).set_color(discord.Color.red())

        await ctx.send(embed=embed.build())

    @commands.command()
    @commands.has_permissions(ban_members=True)
    async def ban(self, ctx, user: discord.User | int, duration: str = None, *, reason="No reason provided"):
        if isinstance(user, int):
            try:
                user = await self.bot.fetch_user(user)
            except discord.NotFound:
                await ctx.send("User not found.")
                return

        ban_duration = None
        if duration:
            total_seconds = 0
            duration_parts = duration.lower().replace(" ", "")
            time_units = {
                'd': 86400,  
                'h': 3600,   
                'm': 60,     
                's': 1       
            }
            
            current_number = ""
            for char in duration_parts:
                if char.isdigit():
                    current_number += char
                elif char in time_units:
                    if current_number:
                        total_seconds += int(current_number) * time_units[char]
                        current_number = ""
            
            if total_seconds > 0:
                ban_duration = datetime.utcnow() + timedelta(seconds=total_seconds)

        embed = EmbedBuilder(
            "⚡ Ban Hammer Struck!",
            f"{user.mention} has been banned from the server."
        ).set_color(discord.Color.dark_red())

        embed.add_field("Target", f"{user.name} ({user.id})")
        embed.add_field("Moderator", ctx.author.mention)
        if ban_duration:
            embed.add_field("Duration", f"Until {ban_duration.strftime('%Y-%m-%d %H:%M:%S')} UTC")
        embed.add_field("Reason", reason, inline=False)
        embed.set_thumbnail(user.avatar.url)

        try:
            dm_embed = EmbedBuilder(
                "🚫 You've Been Banned",
                f"You were banned from {ctx.guild.name}"
            ).set_color(discord.Color.red())
            dm_embed.add_field("Reason", reason)
            if ban_duration:
                dm_embed.add_field("Duration", f"Until {ban_duration.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            
            appeal_info = await self.get_appeal_info(ctx.guild.id)
            if appeal_info:
                dm_embed.add_field("Appeal", appeal_info)
            
            await user.send(embed=dm_embed.build())
        except:
            embed.add_field("Note", "⚠️ Could not DM user", inline=False)

        await ctx.guild.ban(user, reason=f"{reason} | By {ctx.author}", delete_message_days=0)
        await ctx.send(embed=embed.build())

        logging_cog = self.bot.get_cog("CustomLogging")
        if logging_cog:
            await logging_cog.log_action(ctx.guild, 'ban', ctx.author, user, reason)

        if ban_duration:
            
            await asyncio.sleep(total_seconds)
            try:
                await ctx.guild.unban(user, reason="Temporary ban expired")
                unban_embed = EmbedBuilder(
                    "🔓 Ban Expired",
                    f"{user.mention} has been automatically unbanned."
                ).set_color(discord.Color.green())
                await ctx.send(embed=unban_embed.build())
            except:
                await ctx.send(f"Failed to unban {user.mention} automatically.")

    async def get_appeal_info(self, guild_id):
        return self.ban_appeal_info.get(str(guild_id))


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ban_appeal(self, ctx, *, appeal_info):
        self.ban_appeal_info[str(ctx.guild.id)] = appeal_info
        await ctx.send(f"✅ Ban appeal information updated to: {appeal_info}")


    @commands.command()
    @commands.has_permissions(kick_members=True)
    async def kick(self, ctx, user: discord.Member, *, reason="No reason provided"):
        embed = EmbedBuilder(
            "👢 Member Kicked",
            f"{user.mention} has been kicked from the server."
        ).set_color(discord.Color.orange())

        embed.add_field("Target", f"{user.name} ({user.id})")
        embed.add_field("Moderator", ctx.author.mention)
        embed.add_field("Reason", reason, inline=False)

        try:
            dm_embed = EmbedBuilder(
                "👢 You've Been Kicked",
                f"You were kicked from {ctx.guild.name}"
            ).set_color(discord.Color.orange())
            dm_embed.add_field("Reason", reason)
            await user.send(embed=dm_embed.build())
        except:
            embed.add_field("Note", "⚠️ Could not DM user", inline=False)

        await user.kick(reason=f"{reason} | By {ctx.author}")
        await ctx.send(embed=embed.build())

        logging_cog = self.bot.get_cog("CustomLogging")
        if logging_cog:
            await logging_cog.log_action(ctx.guild, 'kick', ctx.author, user, reason)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def mutesetup(self, ctx, role: discord.Role = None):
        
        guild_id = ctx.guild.id
        
        if role:
            self.mute_roles[guild_id] = role.id
            self.save_data()
            embed = discord.Embed(
                title="✅ Mute System Setup",
                description=f"Muted members will now receive the {role.mention} role",
                color=discord.Color.green()
            )
        else:
            
            embed = discord.Embed(
                title="🔇 Mute System Configuration",
                description="Current mute system settings",
                color=discord.Color.blue()
            )
            
            current_role = ctx.guild.get_role(self.mute_roles.get(guild_id))
            embed.add_field(
                name="Mute Role",
                value=current_role.mention if current_role else "Not set",
                inline=False
            )
            
        await ctx.send(embed=embed)


    @commands.command()
    @commands.has_permissions(manage_roles=True)
    async def unmute(self, ctx, member: discord.Member, *, reason: str = None):
        
        guild_id = ctx.guild.id
        
        if guild_id in self.mute_roles:
            mute_role = ctx.guild.get_role(self.mute_roles[guild_id])
            if mute_role and mute_role in member.roles:
                await member.remove_roles(mute_role)
        
        await member.timeout(None, reason=reason)

        embed = discord.Embed(
            title="🔊 Member Unmuted",
            description=f"**Member:** {member.mention}\n**Moderator:** {ctx.author.mention}\n**Reason:** {reason or 'No reason provided'}",
            color=discord.Color.green()
        )
        msg = await ctx.send(embed=embed)

        logging_cog = self.bot.get_cog("CustomLogging")
        if logging_cog:
            await logging_cog.log_action(ctx.guild, 'unmute', ctx.author, member, reason)

        try:
            await member.send(f"You have been unmuted in {ctx.guild.name}")
        except:
            pass

        await asyncio.sleep(3)
        await msg.delete()

    @commands.command()
    @commands.bot_has_permissions(moderate_members=True)
    @commands.has_permissions(manage_messages=True)
    async def mute(self, ctx, user: discord.Member, duration: int, *, reason="No reason provided"):
        time_delta = timedelta(minutes=duration)
        guild_id = ctx.guild.id

        mute_role = None
        if guild_id in self.mute_roles:
            mute_role = ctx.guild.get_role(self.mute_roles[guild_id])

        embed = EmbedBuilder(
            "🔇 Member Muted",
            f"{user.mention} has been muted."
        ).set_color(discord.Color.yellow())

        embed.add_field("Duration", f"{duration} minutes")
        embed.add_field("Moderator", ctx.author.mention)
        embed.add_field("Reason", reason, inline=False)

        await user.timeout(time_delta, reason=reason)
        if mute_role:
            await user.add_roles(mute_role, reason=reason)
            embed.add_field("Role Applied", mute_role.mention, inline=False)

        await ctx.send(embed=embed.build())

        logging_cog = self.bot.get_cog("CustomLogging")
        if logging_cog:
            await logging_cog.log_action(ctx.guild, 'mute', ctx.author, user, reason, f"{duration} minutes")

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def warn(self, ctx, user: discord.Member, *, reason="No reason provided"):
        
    
        embed = EmbedBuilder(
        "⚠️ Warning Issued",
        f"{user.mention} has been warned."
    ).set_color(discord.Color.orange())

        embed.add_field("User", f"{user.name} ({user.id})")
        embed.add_field("Moderator", ctx.author.mention)
        embed.add_field("Reason", reason, inline=False)

        await ctx.send(embed=embed.build())

        try:
            dm_embed = EmbedBuilder(
            "⚠️ You Have Been Warned",
            f"You have been warned in **{ctx.guild.name}**."
        ).set_color(discord.Color.red())

            dm_embed.add_field("Moderator", ctx.author.mention)
            dm_embed.add_field("Reason", reason, inline=False)
            dm_embed.set_footer("Please follow the server rules to avoid further action.")

            await user.send(embed=dm_embed.build())
        except:
            await ctx.send(f"⚠️ {user.mention} has DMs disabled. Unable to send warning via DM.")

        await log_manager.log_action(ctx.guild, "warn", ctx.author, user, reason)

    @commands.command()
    @commands.has_permissions(ban_members=True)
    async def unban(self, ctx, user_id: int, *, reason="No reason provided"):
        try:
            user = await self.bot.fetch_user(user_id)
            await ctx.guild.unban(user, reason=f"{reason} | By {ctx.author}")
        
            embed = EmbedBuilder(
                "🔓 Member Unbanned",
                f"{user.name} has been unbanned from the server."
            ).set_color(discord.Color.green())
        
            embed.add_field("User ID", user_id)
            embed.add_field("Moderator", ctx.author.mention)
            embed.add_field("Reason", reason, inline=False)
        
            await ctx.send(embed=embed.build())
            await log_manager.log_action(ctx.guild, 'unban', ctx.author, user, reason)
        
        except discord.NotFound:
            embed = EmbedBuilder(
                "❌ User Not Found",
                f"No banned user found with ID: {user_id}"
            ).set_color(discord.Color.red()).build()
            await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def clear(self, ctx, amount: int):
        await ctx.channel.purge(limit=amount + 1)
        embed = EmbedBuilder(
            "🧹 Messages Cleared",
            f"Cleared {amount} messages"
        ).set_color(discord.Color.blue()).build()
        await ctx.send(embed=embed, delete_after=5)

    @commands.command()
    @commands.has_permissions(manage_roles=True)
    async def addrole(self, ctx, member: Union[discord.Member, discord.User], role: discord.Role):
        
        if not isinstance(member, discord.Member):
            member = ctx.guild.get_member(member.id)
            if not member:
                embed = EmbedBuilder(
                    "❌ User Not Found",
                    "User must be in the server"
                ).set_color(discord.Color.red()).build()
                return await ctx.send(embed=embed)
        
        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
            embed = EmbedBuilder(
                "❌ Role Error", 
                "You can't assign roles higher than your own!"
            ).set_color(discord.Color.red()).build()
            return await ctx.send(embed=embed)
        
        await member.add_roles(role)
        embed = EmbedBuilder(
            "✅ Role Added",
            f"Successfully added {role.mention} to {member.mention}"
        ).set_color(discord.Color.green())
        embed.add_field("User", member.mention)
        embed.add_field("Moderator", ctx.author.mention)
        await ctx.send(embed=embed.build())


    @commands.command()
    @commands.has_permissions(manage_roles=True)
    async def removerole(self, ctx, user_id: int, role: discord.Role):
        
        member = ctx.guild.get_member(user_id)
        if not member:
            embed = EmbedBuilder(
                "❌ User Not Found",
                f"No user found with ID: {user_id}"
            ).set_color(discord.Color.red()).build()
            return await ctx.send(embed=embed)
        
        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
            embed = EmbedBuilder(
                "❌ Role Error",
                "You can't remove roles higher than your own!"
            ).set_color(discord.Color.red()).build()
            return await ctx.send(embed=embed)
        
        await member.remove_roles(role)
        embed = EmbedBuilder(
            "✅ Role Removed",
            f"Successfully removed {role.mention} from {member.mention}"
        ).set_color(discord.Color.green())
        embed.add_field("User ID", user_id)
        embed.add_field("Moderator", ctx.author.mention)
        await ctx.send(embed=embed.build())

class TicketView(discord.ui.View):
    def __init__(self, bot, button_style=discord.ButtonStyle.blurple):
        super().__init__(timeout=None)
        self.bot = bot
        self.button_style = button_style

    @discord.ui.button(label="Create Ticket", emoji="🎫", custom_id="create_ticket")  
    async def create_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = self.bot.get_cog('TicketSystem').TicketModal()
        await interaction.response.send_modal(modal)



class TicketButtons(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=None)
        self.bot = bot

    @discord.ui.button(label="Close Ticket", style=discord.ButtonStyle.red, emoji="🔒")
    async def close_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        messages = [message async for message in interaction.channel.history(limit=100)]
        transcript = "\n".join(f"{msg.author}: {msg.content}" for msg in reversed(messages))
        
        transcript_file = discord.File(
            io.StringIO(transcript),
            filename=f"ticket-{interaction.channel.name}.txt"
        )
        
        ticket_system = self.bot.get_cog('TicketSystem')
        logs_channel_id = ticket_system.ticket_logs.get(interaction.guild.id)
        logs_channel = None
        
        if logs_channel_id:
            logs_channel = interaction.guild.get_channel(logs_channel_id)
        if not logs_channel:
            logs_channel = discord.utils.get(interaction.guild.channels, name="ticket-logs")
            
        if logs_channel:
            close_log = EmbedBuilder(
                "📝 Ticket Closed",
                f"Ticket {interaction.channel.name} was closed by {interaction.user.mention}"
            ).set_color(discord.Color.red())
            
            await logs_channel.send(embed=close_log.build(), file=transcript_file)
        
        await interaction.followup.send("Closing ticket...")
        await asyncio.sleep(3)
        await interaction.channel.delete()

    @discord.ui.button(label="Claim Ticket", style=discord.ButtonStyle.green, emoji="✋")
    async def claim_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        support_role_id = self.bot.get_cog('TicketSystem').support_roles.get(interaction.guild.id)
        support_role = interaction.guild.get_role(support_role_id) if support_role_id else None
        
        if not (interaction.user.guild_permissions.administrator or 
                (support_role and support_role in interaction.user.roles)):
            return await interaction.response.send_message("You don't have permission to claim tickets!", ephemeral=True)
        
        new_name = f"claimed-{interaction.channel.name[7:]}"
        await interaction.channel.edit(name=new_name)
        
        claim_embed = EmbedBuilder(
            "🎫 Support Ticket - CLAIMED",
            f"This ticket has been claimed by {interaction.user.mention}"
        ).set_color(discord.Color.green())
        
        button.disabled = True
        button.label = f"Claimed by {interaction.user.name}"
        
        await interaction.response.edit_message(view=self)
        await interaction.channel.send(embed=claim_embed.build())


class OwnerPanelView(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=None)
        self.bot = bot
        self.authorized_id = int(os.getenv("BOT_OWNER_ID", "0"))

    @discord.ui.button(label="Owner Commands", style=discord.ButtonStyle.gray, emoji="🔒")
    async def show_owner_commands(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        embed = EmbedBuilder(
            "🔒 Owner-Only Commands",
            "Exclusive commands for bot owner"
        ).set_color(discord.Color.purple())
        
        commands_list = {
            "!owner": "Open this interactive control panel",
            "!leaveserver <guild_id>": "Make bot leave a specific server",
            "!executecmd <guild_id> <channel_id> <command>": "Execute commands in other servers",
            "!botinfo": "View detailed bot statistics",
            "Interactive Buttons": {
                "📋 Server List": "View all servers with details",
                "📊 Statistics": "Real-time bot performance metrics",
                "⚙️ Server Management": "Access server management tools",
                "📢 Mass Message": "Send message to all servers",
                "⚡ Execute Command": "Run commands remotely",
                "🚪 Leave Server": "Remove bot from servers"
            }
        }
        
        for cmd, desc in commands_list.items():
            if isinstance(desc, dict):
                subcommands = "\n".join(f"• {subcmd}: {subdesc}" for subcmd, subdesc in desc.items())
                embed.add_field(cmd, subcommands, inline=False)
            else:
                embed.add_field(cmd, desc, inline=False)
        
        await interaction.response.send_message(embed=embed.build(), ephemeral=True)

    @discord.ui.button(label="Server List", style=discord.ButtonStyle.blurple, emoji="📋")
    async def show_servers(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        embed = EmbedBuilder(
            "📋 Server List",
            f"Managing {len(self.bot.guilds)} servers"
        ).set_color(discord.Color.blue())
        
        for guild in self.bot.guilds:
            embed.add_field(
                f"{guild.name} (ID: {guild.id})",
                f"Members: {guild.member_count}\nOwner: {guild.owner}\nInvite: {await self.create_invite(guild)}",
                inline=False
            )
        
        await interaction.response.send_message(embed=embed.build(), ephemeral=True)

    @discord.ui.button(label="Statistics", style=discord.ButtonStyle.green, emoji="📊")
    async def show_stats(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        total_users = sum(g.member_count for g in self.bot.guilds)
        total_channels = sum(len(g.channels) for g in self.bot.guilds)
        
        embed = EmbedBuilder(
            "📊 Bot Statistics",
            "Real-time performance metrics"
        ).set_color(discord.Color.green())
        
        embed.add_field("Servers", str(len(self.bot.guilds)))
        embed.add_field("Total Users", str(total_users))
        embed.add_field("Total Channels", str(total_channels))
        embed.add_field("Latency", f"{round(self.bot.latency * 1000)}ms")
        embed.add_field("Uptime", str(timedelta(seconds=int(time.time() - self.bot.start_time))))
        
        await interaction.response.send_message(embed=embed.build(), ephemeral=True)

    @discord.ui.button(label="Server Management", style=discord.ButtonStyle.red, emoji="⚙️")
    async def server_management(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        view = ServerManagementView(self.bot)
        embed = EmbedBuilder(
            "⚙️ Server Management",
            "Select actions to manage servers"
        ).set_color(discord.Color.red())
        
        await interaction.response.send_message(embed=embed.build(), view=view, ephemeral=True)

    async def create_invite(self, guild):
        try:
            channel = guild.text_channels[0]
            invite = await channel.create_invite(max_age=300)
            return invite.url
        except:
            return "No invite available"

class ServerManagementView(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=None)
        self.bot = bot
        self.authorized_id = int(os.getenv("BOT_OWNER_ID", "0"))

    @discord.ui.button(label="Leave Server", style=discord.ButtonStyle.red, emoji="🚪")
    async def leave_server(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        await interaction.response.send_modal(LeaveServerModal(self.bot))

    @discord.ui.button(label="Mass Message", style=discord.ButtonStyle.blurple, emoji="📢")
    async def mass_message(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        await interaction.response.send_modal(MassMessageModal(self.bot))

    @discord.ui.button(label="Execute Command", style=discord.ButtonStyle.green, emoji="⚡")
    async def execute_command(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.authorized_id:
            return
            
        await interaction.response.send_modal(ExecuteCommandModal(self.bot))

class LeaveServerModal(discord.ui.Modal, title="Leave Server"):
    def __init__(self, bot):
        super().__init__()
        self.bot = bot
        
    server_id = discord.ui.TextInput(
        label="Server ID",
        placeholder="Enter server ID to leave..."
    )

    async def on_submit(self, interaction: discord.Interaction):
        guild = self.bot.get_guild(int(self.server_id.value))
        if guild:
            await guild.leave()
            embed = EmbedBuilder(
                "✅ Server Left",
                f"Successfully left {guild.name}"
            ).set_color(discord.Color.green())
            await interaction.response.send_message(embed=embed.build(), ephemeral=True)

class MassMessageModal(discord.ui.Modal, title="Send Mass Message"):
    message = discord.ui.TextInput(
        label="Message",
        style=discord.TextStyle.paragraph,
        placeholder="Enter message to send to all servers..."
    )

    async def on_submit(self, interaction: discord.Interaction):
        success = 0
        failed = 0
        for guild in interaction.client.guilds:
            try:
                channel = guild.system_channel or guild.text_channels[0]
                await channel.send(self.message.value)
                success += 1
            except:
                failed += 1
                
        embed = EmbedBuilder(
            "📢 Mass Message Results",
            f"Message sent to {success} servers\nFailed in {failed} servers"
        ).set_color(discord.Color.blue())
        await interaction.response.send_message(embed=embed.build(), ephemeral=True)

class ExecuteCommandModal(discord.ui.Modal, title="Execute Command"):
    guild_id = discord.ui.TextInput(
        label="Server ID",
        placeholder="Enter server ID..."
    )
    
    command = discord.ui.TextInput(
        label="Command",
        placeholder="Enter command to execute..."
    )

    async def on_submit(self, interaction: discord.Interaction):
        guild = interaction.client.get_guild(int(self.guild_id.value))
        if guild:
            channel = guild.system_channel or guild.text_channels[0]
            ctx = await interaction.client.get_context(interaction.message)
            ctx.channel = channel
            await interaction.client.process_commands(ctx.message)
            
            embed = EmbedBuilder(
                "⚡ Command Executed",
                f"Command executed in {guild.name}"
            ).set_color(discord.Color.green())
            await interaction.response.send_message(embed=embed.build(), ephemeral=True)






class OwnerOnly(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.authorized_id = int(os.getenv("BOT_OWNER_ID", "0"))  

        if self.authorized_id == 0:
            logger.warning("⚠️ BOT_OWNER_ID is not set in .env! Owner commands may be unusable.")

    def is_owner(self, ctx):
        
        if ctx.author.id != self.authorized_id:
            logger.warning(f"Unauthorized access attempt: {ctx.author} ({ctx.author.id}) tried using an owner command.")
            return False
        return True

    @commands.command()
    async def owner(self, ctx):
        
        if not self.is_owner(ctx):
            return await ctx.send("❌ You are not authorized to use this command.")

        embed = EmbedBuilder(
            "👑 Owner Control Panel",
            "Welcome to the interactive control panel"
        ).set_color(discord.Color.gold())

        embed.add_field(
            "Available Actions",
            "📋 View server list\n"
            "📊 View statistics\n"
            "⚙️ Server management",
            inline=False
        )

        await ctx.send(embed=embed.build(), view=OwnerPanelView(self.bot))

    trusted_guilds_str = os.getenv('TRUSTED_GUILDS')
    TRUSTED_GUILDS = set()  
    trusted_guilds_str = os.getenv('TRUSTED_GUILDS', '')
    if trusted_guilds_str and not trusted_guilds_str.startswith('#'):
        TRUSTED_GUILDS = {int(guild_id) for guild_id in trusted_guilds_str.split(',') if guild_id.strip().isdigit()}

    @commands.command()
    async def executecmd(self, ctx, guild_id: int, channel_id: int, *, command):
        
        if not self.is_owner(ctx):
            return await ctx.send("❌ You are not authorized to use this command.")

        guild = self.bot.get_guild(guild_id)
        if not guild:
            return await ctx.send(f"❌ Guild with ID {guild_id} not found.")

        channel = guild.get_channel(channel_id)
        if not channel:
            return await ctx.send(f"❌ Channel with ID {channel_id} not found in {guild.name}.")

        if guild_id not in self.TRUSTED_GUILDS:
            return await ctx.send("❌ You cannot execute commands in this server.")

        BLACKLISTED_COMMANDS = ["ban @everyone", "kick @everyone", "delete all", "nuke"]
        if any(blacklisted in command.lower() for blacklisted in BLACKLISTED_COMMANDS):
            return await ctx.send("🚫 This command is too dangerous to execute!")

        confirm_embed = EmbedBuilder(
            "⚠️ Command Execution Request",
            f"Are you sure you want to execute:\n\n`{command}`\n\n"
            f"in **{guild.name}** (`{guild.id}`) -> **#{channel.name}** (`{channel.id}`)?"
        ).set_color(discord.Color.orange())

        confirm_message = await ctx.author.send(embed=confirm_embed.build())
        await confirm_message.add_reaction("✅")
        await confirm_message.add_reaction("❌")

        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in ["✅", "❌"]

        try:
            reaction, _ = await self.bot.wait_for("reaction_add", timeout=30.0, check=check)

            if str(reaction.emoji) == "❌":
                return await ctx.author.send("❌ Command execution **cancelled**.")

            msg = copy.copy(ctx.message)
            msg.channel = channel
            msg.content = command
            new_ctx = await self.bot.get_context(msg)

            try:
                await self.bot.invoke(new_ctx)
                success_embed = EmbedBuilder(
                "✅ Command Executed",
                f"Command executed successfully in **{guild.name}** -> **#{channel.name}**"
            ).set_color(discord.Color.green())
                await ctx.author.send(embed=success_embed.build())
            except Exception as e:
                await ctx.author.send(f"❌ Failed to execute command: {str(e)}")

        except asyncio.TimeoutError:
            await ctx.author.send("❌ Command execution **timed out**. No response received.")

    @commands.command(name='botinfo')
    async def show_info(self, ctx):
        
        if not self.is_owner(ctx):
            return await ctx.send("❌ You are not authorized to use this command.")

        embed = EmbedBuilder(
            "🤖 Bot Information",
            "Detailed statistics and information"
        ).set_color(discord.Color.blue())

        total_users = sum(g.member_count for g in self.bot.guilds)
        total_channels = sum(len(g.channels) for g in self.bot.guilds)
        uptime = timedelta(seconds=int(time.time() - self.bot.start_time))

        embed.add_field("Servers", str(len(self.bot.guilds)))
        embed.add_field("Users", str(total_users))
        embed.add_field("Channels", str(total_channels))
        embed.add_field("Bot Latency", f"{round(self.bot.latency * 1000)}ms")
        embed.add_field("Uptime", str(uptime))
        embed.add_field("Python Version", platform.python_version())

        await ctx.send(embed=embed.build())

    @commands.command()
    async def leaveserver(self, ctx, guild_id: int, *, reason: str = "No reason provided"):
        
        if not self.is_owner(ctx):
            return await ctx.send("❌ You are not authorized to use this command.")

        guild = self.bot.get_guild(guild_id)
        if not guild:
            return await ctx.send(f"❌ Could not find a server with ID {guild_id}.")

        notification = EmbedBuilder(
            "🔔 Bot Leaving Server",
            f"This bot is being removed from the server.\nReason: {reason}"
        ).set_color(discord.Color.red())

        target_channel = guild.system_channel or next((ch for ch in guild.text_channels), None)
        if target_channel:
            await target_channel.send(embed=notification.build())

        await guild.leave()

        embed = EmbedBuilder(
            "✅ Server Left",
            f"Successfully left {guild.name}\nReason: {reason}"
        ).set_color(discord.Color.green())
        await ctx.send(embed=embed.build())

class TicketSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.support_roles = {}
        self.admin_roles = {}
        self.ticket_categories = {}
        self.ticket_logs = {}
        self.ticket_panel_configs = {}

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def fixlogs(self, ctx, channel_id: int):
        
        try:
            channel = ctx.guild.get_channel(channel_id)
            if not channel or not isinstance(channel, discord.TextChannel):
                return await ctx.send("✨ Please provide a valid text channel ID!")
            
            self.ticket_logs[ctx.guild.id] = channel_id
            
            embed = discord.Embed(
                title="✅ Ticket Logs Channel Updated",
                description=f"Ticket logs will now be sent to: {channel.mention}",
                color=discord.Color.green()
            )
            embed.add_field(name="Channel ID", value=channel_id)
            embed.add_field(name="Channel Name", value=channel.name)
            
            await ctx.send(embed=embed)
            
        except Exception as e:
            await ctx.send(f"✨ An error occurred: {str(e)}")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ticketadmin(self, ctx, role: discord.Role):
        
        self.support_roles[ctx.guild.id] = role.id
   
        embed = EmbedBuilder(
            "✅ Ticket Settings Updated",
            f"{role.mention} will now be automatically added to all new tickets"
        ).set_color(discord.Color.green())
   
        embed.add_field("Role ID", role.id)
        embed.add_field("Role Name", role.name)
        await ctx.send(embed=embed.build())

    class TicketModal(discord.ui.Modal, title="Create Ticket"):
        reason = discord.ui.TextInput(
            label="Ticket Reason",
            placeholder="Please describe your reason for creating a ticket...",
            style=discord.TextStyle.paragraph,
            required=True,
            max_length=1000
        )

        async def on_submit(self, interaction: discord.Interaction):
            await interaction.response.defer()
            
            existing_ticket = discord.utils.get(
                interaction.guild.channels,
                name=f"ticket-{interaction.user.id}"
            )
            if existing_ticket:
                return await interaction.followup.send("You already have an open ticket!", ephemeral=True)
            
            ticket_system = interaction.client.get_cog('TicketSystem')
            category_id = ticket_system.ticket_categories.get(interaction.guild.id)
            if category_id:
                category = interaction.guild.get_channel(category_id)
            else:
                category = discord.utils.get(interaction.guild.categories, name="Tickets")
            
            overwrites = {
                interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
                interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                interaction.guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
            }
            
            support_role_id = ticket_system.support_roles.get(interaction.guild.id)
            if support_role_id:
                support_role = interaction.guild.get_role(support_role_id)
                if support_role:
                    overwrites[support_role] = discord.PermissionOverwrite(read_messages=True, send_messages=True)
            
            channel = await interaction.guild.create_text_channel(
                f"ticket-{interaction.user.id}",
                category=category,
                overwrites=overwrites
            )
            
            ticket_embed = EmbedBuilder(
                "🎫 Support Ticket",
                "Thank you for creating a ticket. Support will be with you shortly."
            ).set_color(discord.Color.blue())
            
            ticket_embed.add_field("Created By", interaction.user.mention)
            ticket_embed.add_field("User ID", interaction.user.id)
            ticket_embed.add_field("Reason", str(self.reason), inline=False)
            
            await channel.send(embed=ticket_embed.build())
            
            ticket_view = TicketButtons(interaction.client)
            await channel.send("Ticket Controls:", view=ticket_view)
            
            if support_role_id:
                support_role = interaction.guild.get_role(support_role_id)
                if support_role:
                    await channel.send(f"{support_role.mention} A new ticket requires attention!")
            
            confirm = EmbedBuilder(
                "✅ Ticket Created",
                f"Your ticket has been created in {channel.mention}"
            ).set_color(discord.Color.green()).build()
            
            await interaction.followup.send(embed=confirm, ephemeral=True)



    @commands.command()
    @commands.has_permissions(administrator=True)
    async def fixticket(self, ctx, category_id: int):
        
        try:
            category = ctx.guild.get_channel(category_id)
            if not category or not isinstance(category, discord.CategoryChannel):
                return await ctx.send("✨ Please provide a valid category ID!")
            
            self.ticket_categories[ctx.guild.id] = category_id
            
            embed = discord.Embed(
                title="✅ Ticket Category Updated",
                description=f"New tickets will now be created in category: {category.name}",
                color=discord.Color.green()
            )
            embed.add_field(name="Category ID", value=category_id)
            embed.add_field(name="Category Name", value=category.name)
            
            await ctx.send(embed=embed)
            
        except Exception as e:
            await ctx.send(f"✨ An error occurred: {str(e)}")



    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ticketsetup_json(self, ctx, *, json_data: str = None):
        
        try:
            color_map = {
    "blurple": (discord.ButtonStyle.blurple, discord.Color.blurple()),
    "green": (discord.ButtonStyle.green, discord.Color.green()),
    "dark_green": (discord.ButtonStyle.green, discord.Color.dark_green()),
    "light_green": (discord.ButtonStyle.green, discord.Color.from_rgb(144, 238, 144)),
    "neon_green": (discord.ButtonStyle.green, discord.Color.from_rgb(57, 255, 20)),
    
    "red": (discord.ButtonStyle.red, discord.Color.red()),
    "dark_red": (discord.ButtonStyle.red, discord.Color.dark_red()),
    "bright_red": (discord.ButtonStyle.red, discord.Color.from_rgb(255, 69, 0)),
    "pink_red": (discord.ButtonStyle.red, discord.Color.from_rgb(255, 105, 180)),

    "grey": (discord.ButtonStyle.grey, discord.Color.greyple()),
    "dark_grey": (discord.ButtonStyle.grey, discord.Color.dark_grey()),
    "light_grey": (discord.ButtonStyle.grey, discord.Color.light_grey()),
    "darker_grey": (discord.ButtonStyle.grey, discord.Color.darker_grey()),
    "lighter_grey": (discord.ButtonStyle.grey, discord.Color.lighter_grey()),

    "blue": (discord.ButtonStyle.blurple, discord.Color.blue()),
    "dark_blue": (discord.ButtonStyle.blurple, discord.Color.dark_blue()),
    "navy_blue": (discord.ButtonStyle.blurple, discord.Color.from_rgb(0, 0, 128)),
    "sky_blue": (discord.ButtonStyle.blurple, discord.Color.from_rgb(135, 206, 235)),
    "cyan": (discord.ButtonStyle.blurple, discord.Color.from_rgb(0, 255, 255)),
    
    "teal": (discord.ButtonStyle.blurple, discord.Color.teal()),
    "dark_teal": (discord.ButtonStyle.blurple, discord.Color.dark_teal()),
    "light_teal": (discord.ButtonStyle.blurple, discord.Color.from_rgb(32, 178, 170)),
    
    "brand": (discord.ButtonStyle.blurple, discord.Color.blurple()),
    "primary": (discord.ButtonStyle.blurple, discord.Color.blue()),

    "success": (discord.ButtonStyle.green, discord.Color.green()),
    "thez": (discord.ButtonStyle.green, discord.Color.from_rgb(255, 0, 255)),
    "danger": (discord.ButtonStyle.red, discord.Color.red()),
    "brand_red": (discord.ButtonStyle.red, discord.Color.red()),
    
    "orange": (discord.ButtonStyle.red, discord.Color.orange()),
    "dark_orange": (discord.ButtonStyle.red, discord.Color.dark_orange()),
    "bright_orange": (discord.ButtonStyle.red, discord.Color.from_rgb(255, 140, 0)),

    "gold": (discord.ButtonStyle.grey, discord.Color.gold()),
    "dark_gold": (discord.ButtonStyle.grey, discord.Color.dark_gold()),
    "bronze": (discord.ButtonStyle.grey, discord.Color.from_rgb(205, 127, 50)),
    "silver": (discord.ButtonStyle.grey, discord.Color.from_rgb(192, 192, 192)),

    "purple": (discord.ButtonStyle.blurple, discord.Color.purple()),
    "purplee": (discord.ButtonStyle.blurple, discord.Color.purple()),
    "dark_purple": (discord.ButtonStyle.grey, discord.Color.dark_purple()),
    "lavender": (discord.ButtonStyle.grey, discord.Color.from_rgb(230, 230, 250)),

    "magenta": (discord.ButtonStyle.grey, discord.Color.magenta()),
    "dark_magenta": (discord.ButtonStyle.grey, discord.Color.dark_magenta()),
    "hot_pink": (discord.ButtonStyle.grey, discord.Color.from_rgb(255, 20, 147)),
    "deep_pink": (discord.ButtonStyle.grey, discord.Color.from_rgb(255, 0, 127)),

    "random": (discord.ButtonStyle.grey, discord.Color.random()),
    "white": (discord.ButtonStyle.grey, discord.Color.from_rgb(255, 255, 255)),
    "black": (discord.ButtonStyle.grey, discord.Color.from_rgb(0, 0, 0)),
    "brown": (discord.ButtonStyle.grey, discord.Color.from_rgb(139, 69, 19))
}



            config = None
            if len(ctx.message.attachments) > 0:
                attachment = ctx.message.attachments[0]
                if attachment.filename.endswith('.json'):
                    json_data = (await attachment.read()).decode('utf-8')
                    config = json.loads(json_data)
            elif json_data:
                config = json.loads(json_data)


            if not config:
                return await ctx.send("✨ Please provide JSON configuration either as text or an attached file!")


            category_id = self.ticket_categories.get(ctx.guild.id)
            if category_id:
                category = ctx.guild.get_channel(category_id)
            else:
                category = discord.utils.get(ctx.guild.categories, name="Tickets")
                if not category:
                    category = await ctx.guild.create_category("Tickets")


            logs_channel_id = self.ticket_logs.get(ctx.guild.id)
            if logs_channel_id:
                logs_channel = ctx.guild.get_channel(logs_channel_id)
            else:
                logs_channel = discord.utils.get(ctx.guild.channels, name="ticket-logs")
                if not logs_channel:
                    logs_channel = await ctx.guild.create_text_channel("ticket-logs", category=category)


            embeds = []

            embed_data = config.get('embeds', []) if 'embeds' in config else config.get('ticket_config', {}).get('custom_panels', {}).get('embeds', [])

            total_embeds = len(embed_data)
            width_placeholder = "https://placehold.co/400x10/2b2d31/2b2d31.png"
            has_image = any('image' in embed for embed in embed_data)

            for i, discord_embed in enumerate(embed_data):
                embed_color = str(discord_embed.get('color', 'blurple')).lower()
                if embed_color.startswith('#'):
                    embed_color = discord.Color(int(embed_color.strip('#'), 16))
                elif embed_color not in color_map:
                    valid_colors = ", ".join(color_map.keys())
                    return await ctx.send(f"❌ Invalid button color! Valid colors are: **{valid_colors}**")
                
                embed_color = color_map[embed_color][1] if isinstance(embed_color, str) else embed_color
                
                embed = discord.Embed(
                    title=discord_embed.get('title', 'Support Tickets'),
                    description=discord_embed.get('description', 'Click below to create a ticket'),
                    color=embed_color
                )
                
                if has_image and 'image' not in discord_embed:
                    embed.set_image(url=width_placeholder)
                elif 'image' in discord_embed:
                    embed.set_image(url=discord_embed['image']['url'])
                
                if i < total_embeds - 1:
                    embed.description += "\n\u200b"
                
                embeds.append(embed)

            button_color = str(config.get('button_color', 'blurple')).lower()
            if button_color not in color_map:
                valid_colors = ", ".join(color_map.keys())
                return await ctx.send(f"❌ Invalid button color! Valid colors are: **{valid_colors}**")


            button_style = discord.ButtonStyle.blurple
            button_label = "Create Ticket"
            button_emoji = "🎫"

            if 'button_label' in config:
                button_label = config['button_label']
            if 'button_emoji' in config:
                button_emoji = config['button_emoji']
            if 'button_color' in config:
                if config['button_color'].lower() in color_map:
                    button_style = color_map[config['button_color'].lower()][0]

            class CustomTicketView(discord.ui.View):
                def __init__(self):
                    super().__init__(timeout=None)

                @discord.ui.button(label=button_label, emoji=button_emoji, custom_id="create_ticket", style=button_style)
                async def create_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
                    modal = ctx.bot.get_cog('TicketSystem').TicketModal()
                    await interaction.response.send_modal(modal)

            await ctx.send(embeds=embeds, view=CustomTicketView())


        except json.JSONDecodeError:
            await ctx.send("✨ Invalid JSON format! Please provide valid JSON configuration.")
        except Exception as e:
            await ctx.send(f"✨ An error occurred: {str(e)}")

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def ticketsetup(self, ctx, *, args):
        
        try:
            parts = shlex.split(args)
            panel_name = parts[0]
            message = parts[1]
            embed_color = parts[2] if len(parts) > 2 else "blurple"
            button_color = parts[3] if len(parts) > 3 else "blurple"
            
            color_map = {
                "blurple": (discord.ButtonStyle.blurple, discord.Color.blurple()),
                "green": (discord.ButtonStyle.green, discord.Color.green()),
                "red": (discord.ButtonStyle.red, discord.Color.red()),
                "grey": (discord.ButtonStyle.grey, discord.Color.greyple()),
                "primary": (discord.ButtonStyle.blurple, discord.Color.blue()),
                "blue": (discord.ButtonStyle.blurple, discord.Color.blue()),
                "dark_blue": (discord.ButtonStyle.blurple, discord.Color.dark_blue()),
                "brand": (discord.ButtonStyle.blurple, discord.Color.blurple()),
                "teal": (discord.ButtonStyle.blurple, discord.Color.teal()),
                "dark_teal": (discord.ButtonStyle.blurple, discord.Color.dark_teal()),
                "success": (discord.ButtonStyle.green, discord.Color.green()),
                "dark_green": (discord.ButtonStyle.green, discord.Color.dark_green()),
                "thez": (discord.ButtonStyle.green, discord.Color.from_rgb(255,0,255)),
                "danger": (discord.ButtonStyle.red, discord.Color.red()),
                "brand_red": (discord.ButtonStyle.red, discord.Color.red()),
                "dark_red": (discord.ButtonStyle.red, discord.Color.dark_red()),
                "orange": (discord.ButtonStyle.red, discord.Color.orange()),
                "dark_orange": (discord.ButtonStyle.red, discord.Color.dark_orange()),
                "secondary": (discord.ButtonStyle.grey, discord.Color.greyple()),
                "purple": (discord.ButtonStyle.grey, discord.Color.purple()),
                "dark_purple": (discord.ButtonStyle.grey, discord.Color.dark_purple()),
                "magenta": (discord.ButtonStyle.grey, discord.Color.magenta()),
                "dark_magenta": (discord.ButtonStyle.grey, discord.Color.dark_magenta()),
                "gold": (discord.ButtonStyle.grey, discord.Color.gold()),
                "dark_gold": (discord.ButtonStyle.grey, discord.Color.dark_gold()),
                "lighter_grey": (discord.ButtonStyle.grey, discord.Color.lighter_grey()),
                "dark_grey": (discord.ButtonStyle.grey, discord.Color.dark_grey()),
                "light_grey": (discord.ButtonStyle.grey, discord.Color.light_grey()),
                "darker_grey": (discord.ButtonStyle.grey, discord.Color.darker_grey()),
                "random": (discord.ButtonStyle.grey, discord.Color.random()),
            }

            if embed_color.lower() not in color_map or button_color.lower() not in color_map:
                valid_colors = ", ".join(color_map.keys())
                return await ctx.send(f"❌ Invalid color! Valid colors are: **{valid_colors}**")

            button_style = color_map[button_color.lower()][0]
            embed_color = color_map[embed_color.lower()][1]

            category_id = self.ticket_categories.get(ctx.guild.id)
            if category_id:
                category = ctx.guild.get_channel(category_id)
            else:
                category = discord.utils.get(ctx.guild.categories, name="Tickets")
                if not category:
                    category = await ctx.guild.create_category("Tickets")

            logs_channel_id = self.ticket_logs.get(ctx.guild.id)
            if logs_channel_id:
                logs_channel = ctx.guild.get_channel(logs_channel_id)
            else:
                logs_channel = discord.utils.get(ctx.guild.channels, name="ticket-logs")
                if not logs_channel:
                    logs_channel = await ctx.guild.create_text_channel("ticket-logs", category=category)

            embed = EmbedBuilder(
                panel_name,
                message
            ).set_color(embed_color).build()

            class CustomTicketView(discord.ui.View):
                def __init__(self):
                    super().__init__(timeout=None)

                @discord.ui.button(label="Create Ticket", emoji="🎫", custom_id="create_ticket", style=button_style)
                async def create_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
                    modal = ctx.bot.get_cog('TicketSystem').TicketModal()
                    await interaction.response.send_modal(modal)

            await ctx.send(embed=embed, view=CustomTicketView())

        except Exception as e:
            await ctx.send(f"✨ An error occurred: {str(e)}")


    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def add(self, ctx, user: discord.Member):
        if not (ctx.channel.name.startswith("ticket-") or ctx.channel.name.startswith("claimed-")):
            return await ctx.send("This command can only be used in ticket channels!")
    
        await ctx.channel.set_permissions(user, read_messages=True, send_messages=True)
        await ctx.send(f"{user.mention} has been added to the ticket.")

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def remove(self, ctx, user: discord.Member):
        if not (ctx.channel.name.startswith("ticket-") or ctx.channel.name.startswith("claimed-")):
            return await ctx.send("This command can only be used in ticket channels!")
    
        await ctx.channel.set_permissions(user, overwrite=None)
        await ctx.send(f"{user.mention} has been removed from the ticket.")

    @commands.command()
    async def close(self, ctx):
        if not (ctx.channel.name.startswith("ticket-") or ctx.channel.name.startswith("claimed-")):
            return await ctx.send("This command can only be used in ticket channels!")
        
        messages = [message async for message in ctx.channel.history(limit=100)]
        transcript = "\n".join(f"{msg.author}: {msg.content}" for msg in reversed(messages))
        
        transcript_file = discord.File(
            io.StringIO(transcript),
            filename=f"{ctx.channel.name}.txt"
        )
        
        logs_channel_id = self.ticket_logs.get(ctx.guild.id)
        logs_channel = None
        
        if logs_channel_id:
            logs_channel = ctx.guild.get_channel(logs_channel_id)
        if not logs_channel:
            logs_channel = discord.utils.get(ctx.guild.channels, name="ticket-logs")
        
        if logs_channel:
            close_log = EmbedBuilder(
                "📝 Ticket Closed",
                f"Ticket {ctx.channel.name} was closed by {ctx.author.mention}"
            ).set_color(discord.Color.red())
            
            await logs_channel.send(embed=close_log.build(), file=transcript_file)
        
        await ctx.send("Closing ticket...")
        await asyncio.sleep(3)
        await ctx.channel.delete()


class ServerManagement(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.autorole_dict = {}

    @commands.Cog.listener()
    async def on_member_join(self, member):
        
        if hasattr(self, 'autorole_dict') and member.guild.id in self.autorole_dict:
            await asyncio.sleep(5)  
            role = member.guild.get_role(self.autorole_dict[member.guild.id])
            if role:
                try:
                    await member.add_roles(role)
                    print(f"Assigned role '{role.name}' to {member.name}.")
                except discord.Forbidden:
                    pass



    @commands.command(name="setprefix")
    @commands.has_permissions(administrator=True, manage_channels=True)
    async def setprefix(self, ctx, new_prefix: str):

        if len(new_prefix) > 5:
            await ctx.send("❌ Prefix cannot be longer than 5 characters!")
            return

        try:
            
            self.bot.command_prefix = new_prefix
            await ctx.send(f"✅ Command prefix has been updated to: `{new_prefix}`\nExample: `{new_prefix}blackjack`")
        except Exception as e:
            await ctx.send(f"❌ Failed to update prefix: {str(e)}")

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def lockdown(self, ctx, channel: discord.TextChannel = None, minutes: int = None):
        channel = channel or ctx.channel
        perms = channel.overwrites_for(ctx.guild.default_role)
        perms.send_messages = False
        await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
    
        embed = EmbedBuilder(
        "🔒 Channel Lockdown",
        f"{channel.mention} has been locked down."
    ).set_color(discord.Color.red())
        embed.add_field("Moderator", ctx.author.mention)
    
        if minutes:
            embed.add_field("Duration", f"{minutes} minutes")
            embed.set_footer("Channel will automatically unlock")
            await ctx.send(embed=embed.build())
        
            await asyncio.sleep(minutes * 60)
            perms.send_messages = True
            await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
        
            unlock_embed = EmbedBuilder(
            "🔓 Channel Unlocked",
            f"{channel.mention} has been automatically unlocked."
        ).set_color(discord.Color.green()).build()
            await ctx.send(embed=unlock_embed)
        else:
            embed.set_footer("Use !unlock to remove the lockdown")
            await ctx.send(embed=embed.build())
    
        await log_manager.log_action(ctx.guild, 'lockdown', ctx.author, channel)

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def unlock(self, ctx, channel: discord.TextChannel = None):
        channel = channel or ctx.channel
        perms = channel.overwrites_for(ctx.guild.default_role)
        perms.send_messages = True
        await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
        
        embed = EmbedBuilder(
            "🔓 Channel Unlocked",
            f"{channel.mention} has been unlocked."
        ).set_color(discord.Color.green())
        embed.add_field("Moderator", ctx.author.mention)
        
        await ctx.send(embed=embed.build())

    @commands.command()
    @commands.has_permissions(manage_messages=True)
    async def slowmode(self, ctx, seconds: int):
        await ctx.channel.edit(slowmode_delay=seconds)
        
        embed = EmbedBuilder(
            "⏱️ Slowmode Updated",
            f"Channel slowmode set to {seconds} seconds"
        ).set_color(discord.Color.blue())
        embed.add_field("Channel", ctx.channel.mention)
        embed.add_field("Moderator", ctx.author.mention)
        
        await ctx.send(embed=embed.build())

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def autorole(self, ctx, role: discord.Role = None):
        
        if not hasattr(self, 'autorole_dict'):
            self.autorole_dict = {}
        
        if role is None:
            if ctx.guild.id in self.autorole_dict:
                current_role = ctx.guild.get_role(self.autorole_dict[ctx.guild.id])
                embed = EmbedBuilder(
                    "ℹ️ Autorole Status",
                    f"Currently active for role: {current_role.mention if current_role else 'None'}"
                ).set_color(discord.Color.blue()).build()
            else:
                embed = EmbedBuilder(
                    "ℹ️ Autorole Status",
                    "Autorole is currently disabled"
                ).set_color(discord.Color.blue()).build()
        else:
            if ctx.guild.id in self.autorole_dict and self.autorole_dict[ctx.guild.id] == role.id:
            
                del self.autorole_dict[ctx.guild.id]
                embed = EmbedBuilder(
                    "🔄 Autorole Disabled",
                    f"Automatic role assignment for {role.mention} has been disabled"
                ).set_color(discord.Color.red()).build()
            else:
            
                self.autorole_dict[ctx.guild.id] = role.id
                embed = EmbedBuilder(
                    "✅ Autorole Enabled",
                    f"New members will automatically receive the {role.mention} role"
                ).set_color(discord.Color.green()).build()
    
        await ctx.send(embed=embed)


    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def hide(self, ctx, channel: discord.TextChannel = None):
        channel = channel or ctx.channel  
        perms = channel.overwrites_for(ctx.guild.default_role)
        perms.view_channel = False
        await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
        
        embed = discord.Embed(
            title="🔒 Channel Hidden",
            description=f"{channel.mention} has been hidden from regular members.",
            color=discord.Color.red()
        )
        embed.add_field(name="Moderator", value=ctx.author.mention)
        
        await ctx.send(embed=embed)
        await log_manager.log_action(ctx.guild, 'hide', ctx.author, channel)

    @commands.command()
    @commands.has_permissions(manage_channels=True)
    async def show(self, ctx, channel: discord.TextChannel = None):
        channel = channel or ctx.channel  
        perms = channel.overwrites_for(ctx.guild.default_role)
        perms.view_channel = True
        await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
        
        embed = discord.Embed(
            title="👁️ Channel Visible",
            description=f"{channel.mention} has been made visible to regular members.",
            color=discord.Color.green()
        )
        embed.add_field(name="Moderator", value=ctx.author.mention)
        
        await ctx.send(embed=embed)
        await log_manager.log_action(ctx.guild, 'show', ctx.author, channel)


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def setup(self, ctx):
        
        guild = ctx.guild
        original_channel = ctx.channel

        print(f"[DEBUG] Starting setup in guild: {guild.name} (ID: {guild.id})")

        templates = {
            "📜": {
                "name": "Information Hub",
                "desc": "Perfect for announcements and documentation",
                "categories": {
                    "📢 Announcements": ["📌-announcements", "🎉-events", "📊-polls"],
                    "📚 Information": ["📜-rules", "❓-faq", "🎫-roles"],
                    "📝 Documentation": ["📘-guides", "📖-wiki", "📑-changelogs"]
                }
            },
            "🎵": {
                "name": "Music Community",
                "desc": "For music lovers and sharing",
                "categories": {
                    "🎵 Music Channels": ["🎵-music-chat", "🎼-song-requests", "🎹-recommendations"],
                    "🎧 Music Rooms": ["🎸-music-1", "🎺-music-2", "🎻-music-3"]
                }
            },
            "🎮": {
                "name": "Gaming Center",
                "desc": "Complete gaming community setup",
                "categories": {
                    "🎮 Gaming Hub": ["🎮-gaming-chat", "🎲-lfg", "🏆-achievements"],
                    "🎲 Game Specific": ["🔫-fps-games", "⚔️-mmo-games", "🏎️-racing-games"]
                }
            },
            "💻": {
                "name": "Development Hub",
                "desc": "For coding and development",
                "categories": {
                    "💻 Development": ["💻-coding-chat", "🐛-bug-reports", "📝-code-reviews"],
                    "🔧 Project Management": ["📋-projects", "✅-todo", "📊-progress"]
                }
            },
            "🤖": {
                "name": "Bot Testing",
                "desc": "Perfect for bot development",
                "categories": {
                    "🤖 Bot Testing": ["🤖-bot-commands", "🔧-test-channel", "📝-bot-logs"],
                    "⚙️ Configuration": ["⚙️-settings", "📊-analytics", "🔍-debugging"]
                }
            },
            "🔊": {
                "name": "Voice Lounges",
                "desc": "General voice chat rooms",
                "voice_channels": {
                    "🎤 Voice Lounges": ["🔊 General VC", "💬 Hangout VC", "🎮 Gaming VC"]
                }
            },
            "🎹": {
                "name": "Music Rooms",
                "desc": "Music-focused voice channels",
                "voice_channels": {
                    "🎵 Music Rooms": ["🎵 Music VC #1", "🎵 Music VC #2", "🎧 Radio VC"]
                },

            }
        }

        await original_channel.send(embed=EmbedBuilder(
            "🚀 Starting Advanced Server Setup",
            "This channel will log all setup-related actions."
        ).set_color(discord.Color.blue()).build())

        template_embed = discord.Embed(
            title="🎨 Server Template Selection",
            description="Select server templates to combine (React with emojis)\n\n" +
                    "\n".join([f"{k} **{v['name']}** - {v['desc']}" for k,v in templates.items()]) +
                    "\n\n⚡ React with your choices and then click ✨ to confirm",
            color=discord.Color.blue()
        )
        selection_msg = await ctx.send(embed=template_embed)


        for emoji in list(templates.keys()) + ["✨"]:
            await selection_msg.add_reaction(emoji)
        
        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) == "✨"

        try:
            await self.bot.wait_for("reaction_add", timeout=60.0, check=check)
            selected_templates = []
            msg = await ctx.channel.fetch_message(selection_msg.id)
                
            for reaction in msg.reactions:
                async for user in reaction.users():
                    if user == ctx.author and str(reaction.emoji) in templates:
                        selected_templates.append(templates[str(reaction.emoji)])


            if not selected_templates:
                await ctx.send("❌ No templates selected! Setup cancelled.")
                return

            confirm_embed = EmbedBuilder(
                "⚠️ WARNING: This will DELETE ALL ROLES, CHANNELS, AND CATEGORIES!",
                "Are you sure you want to proceed? Type `yes` to confirm or `no` to cancel."
            ).set_color(discord.Color.red()).build()
            await original_channel.send(embed=confirm_embed)

            def check_msg(m):
                return m.author == ctx.author and m.channel == original_channel and m.content.lower() in ["yes", "no"]

            confirmation = await self.bot.wait_for("message", timeout=30.0, check=check_msg)
            if confirmation.content.lower() != "yes":
                await original_channel.send("❌ Setup canceled.")
                return

            bot_member = guild.get_member(self.bot.user.id)
            bot_role = discord.utils.get(guild.roles, name=self.bot.user.name)

            if not bot_role:
                print("[DEBUG] Bot does not have a role. Creating a temporary role.")
                try:
                    bot_role = await guild.create_role(name="🚀 Setup Role", permissions=discord.Permissions.all(), color=discord.Color.orange())
                    await bot_member.add_roles(bot_role)
                    await original_channel.send(f"✅ Created and assigned temporary role: {bot_role.name}")
                except Exception as e:
                    await original_channel.send(f"❌ Failed to create temporary role: {e}")
                    return

            print("[DEBUG] Deleting roles...")
            for role in guild.roles:
                if role.name != "@everyone" and role != bot_role:
                    try:
                        await role.delete(reason="Advanced server setup")
                        await original_channel.send(f"🗑️ Deleted role: {role.name}")
                    except Exception as e:
                        print(f"[ERROR] Failed to delete role {role.name}: {e}")
                        continue
            
            print("[DEBUG] Deleting channels and categories...")
            for channel in guild.channels:
                if channel != original_channel:
                    try:
                        await channel.delete(reason="Advanced server setup")
                        await original_channel.send(f"🗑️ Deleted channel: {channel.name}")
                        print(f"[DEBUG] Deleted channel: {channel.name}")
                    except discord.Forbidden:
                        await original_channel.send(f"❌ Failed to delete channel: {channel.name} (Missing Permissions)")
                        continue
                    except discord.HTTPException as e:
                        await original_channel.send(f"❌ Failed to delete channel: {channel.name} ({e})")
                        continue

            print("[DEBUG] Creating new roles...")
            try:
                print("[DEBUG] Creating Owner role...")
                owner_role = await guild.create_role(name="👑 Owner", permissions=discord.Permissions.all(), color=discord.Color.gold(), hoist=True)
                
                print("[DEBUG] Creating Bot Owner role...")
                bot_role_owner = await guild.create_role(name="🤖 Bot (Owner-Level)", permissions=discord.Permissions.all(), color=discord.Color.dark_theme(), hoist=False)
                
                print("[DEBUG] Creating Admin role...")
                admin_role = await guild.create_role(name="🔧 Admin", permissions=discord.Permissions.all(), color=discord.Color.blue(), hoist=True)
                
                print("[DEBUG] Creating Mod role...")
                mod_role = await guild.create_role(name="🛡️ Mod", permissions=discord.Permissions(
                    manage_messages=True, kick_members=True, ban_members=True, manage_channels=True
                ), color=discord.Color.green(), hoist=True)
                
                print("[DEBUG] Creating Member role...")
                member_role = await guild.create_role(name="👤 Member", permissions=discord.Permissions(
                    read_messages=True, send_messages=True
                ), color=discord.Color.default(), hoist=True)
                
                print("[DEBUG] Creating Bot Locked role...")
                bot_role_locked = await guild.create_role(name="🤖 Bot (Locked-Down)", permissions=discord.Permissions.none(), color=discord.Color.dark_grey(), hoist=True)
                
                print("[DEBUG] Sending role creation confirmation...")
                await original_channel.send(embed=EmbedBuilder(
                    "✅ Roles Created",
                    "The following roles have been created:"
                ).add_field("👑 Owner", owner_role.mention)
                .add_field("🤖 Bot (Owner-Level)", bot_role_owner.mention)
                .add_field("🔧 Admin", admin_role.mention)
                .add_field("🛡️ Mod", mod_role.mention)
                .add_field("👤 Member", member_role.mention)
                .add_field("🤖 Bot (Locked-Down)", bot_role_locked.mention)
                .set_color(discord.Color.green()).build())
                
                print("[DEBUG] Roles created successfully")
                print("[DEBUG] Starting template-based channel creation...")

                for template in selected_templates:
                    if "categories" in template:
                        for category_name, channels in template["categories"].items():
                            try:
                                category = await guild.create_category(category_name)
                                await original_channel.send(f"📂 Created category: {category_name}")
                                print(f"[DEBUG] Created category: {category_name}")

                                overwrites = {
                                    guild.default_role: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                                    owner_role: discord.PermissionOverwrite(administrator=True),
                                    admin_role: discord.PermissionOverwrite(manage_channels=True),
                                    mod_role: discord.PermissionOverwrite(manage_messages=True),
                                    member_role: discord.PermissionOverwrite(read_messages=True, send_messages=True)
                                }

                                if "Admin" in category_name:
                                    overwrites[guild.default_role] = discord.PermissionOverwrite(read_messages=False)
                                    overwrites[member_role] = discord.PermissionOverwrite(read_messages=False)
                                elif "Bot" in category_name:
                                    overwrites[guild.default_role] = discord.PermissionOverwrite(send_messages=False)
                                    overwrites[bot_role_owner] = discord.PermissionOverwrite(send_messages=True)

                                await category.edit(overwrites=overwrites)

                                for channel_name in channels:
                                    await guild.create_text_channel(channel_name, category=category, overwrites=overwrites)
                                    await original_channel.send(f"📝 Created channel: {channel_name} in {category_name}")
                                    print(f"[DEBUG] Created channel: {channel_name} in {category_name}")

                            except Exception as e:
                                await original_channel.send(f"❌ Error creating {category_name}: {e}")
                                print(f"[ERROR] Failed to create {category_name}: {e}")
                                continue
                    
                    if "voice_channels" in template:
                        for category_name, channels in template["voice_channels"].items():
                            try:
                                category = await guild.create_category(category_name)
                                await original_channel.send(f"📂 Created voice category: {category_name}")
                                
                                for channel_name in channels:
                                    await guild.create_voice_channel(channel_name, category=category)
                                    await original_channel.send(f"🎤 Created voice channel: {channel_name}")
                                    print(f"[DEBUG] Created voice channel: {channel_name}")
                                    
                            except Exception as e:
                                await original_channel.send(f"❌ Error creating voice channel {category_name}: {e}")
                                print(f"[ERROR] Failed to create voice channel {category_name}: {e}")
                                continue




                print("[DEBUG] Assigning roles...")
                try:
                    await ctx.author.add_roles(owner_role)
                    await bot_member.add_roles(bot_role_owner, bot_role_locked)
                    
                    await original_channel.send(embed=EmbedBuilder(
                        "✅ Roles Assigned",
                        "The following roles have been assigned:"
                    ).add_field("👑 Owner", ctx.author.mention)
                    .add_field("🤖 Bot (Owner-Level + Locked)", bot_member.mention)
                    .set_color(discord.Color.green()).build())
                    
                    print("[DEBUG] Successfully assigned roles.")
                except Exception as e:
                    await original_channel.send(f"❌ Failed to assign roles: {e}")
                    print(f"[ERROR] Failed to assign roles: {e}")

                if bot_role.name == "🚀 Setup Role":
                    try:
                        await bot_role.delete(reason="Setup complete")
                        print("[DEBUG] Deleted temporary setup role")
                    except Exception as e:
                        print(f"[ERROR] Failed to delete temporary role: {e}")

                final_embed = discord.Embed(
                    title="✨ Advanced Server Setup Complete!",
                    description="Server has been fully configured with selected templates!",
                    color=discord.Color.green()
                )
                final_embed.add_field(name="Templates Used", value="\n".join([t['name'] for t in selected_templates]))
                final_embed.add_field(name="Total Channels", value=f"Created {len(list(guild.channels))} channels")
                final_embed.add_field(name="Total Roles", value=f"Created {len(list(guild.roles))} roles")
                
                await original_channel.send(embed=final_embed)
                print("[DEBUG] Setup completed successfully")

            except discord.Forbidden as e:
                print(f"[ERROR] Permission error creating roles: {e}")
                await original_channel.send(embed=EmbedBuilder(
                    "❌ Permission Error",
                    "Failed to create roles due to missing permissions. Please ensure the bot has the Administrator permission."
                ).set_color(discord.Color.red()).build())
            except discord.HTTPException as e:
                print(f"[ERROR] HTTP error creating roles: {e}")
                await original_channel.send(embed=EmbedBuilder(
                    "❌ Discord API Error",
                    f"Failed to create roles due to a Discord API error: {e}"
                ).set_color(discord.Color.red()).build())
            except Exception as e:
                print(f"[ERROR] Unexpected error creating roles: {e}")
                await original_channel.send(embed=EmbedBuilder(
                    "❌ Unexpected Error",
                    f"An unexpected error occurred while creating roles: {e}\nPlease try again or contact support."
                ).set_color(discord.Color.red()).build())
                
        except asyncio.TimeoutError:
            await ctx.send("❌ Setup timed out! Please try again.")
        except Exception as e:
            await ctx.send(f"❌ An error occurred during setup: {e}")
            print(f"[ERROR] Setup failed: {e}")


class ServerInfo(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def serverinfo(self, ctx):
        guild = ctx.guild
    
        total_members = guild.member_count
        humans = len([m for m in guild.members if not m.bot])
        bots = len([m for m in guild.members if m.bot])
    
        embed = EmbedBuilder(
        f"📊 {guild.name} Statistics",
        "Detailed server information and statistics"
    ).set_color(discord.Color.blue())
    
        general_info = (
        f"👑 Owner: {guild.owner.mention}\n"
        f"📅 Created: {guild.created_at.strftime('%B %d, %Y')}\n"
        f"✨ Boost Level: {guild.premium_tier}"
    )
        embed.add_field("General Information", general_info, inline=False)
    
        member_stats = (
        f"👥 Total Members: {total_members}\n"
        f"👤 Humans: {humans}\n"
        f"🤖 Bots: {bots}"
    )
        embed.add_field("Member Statistics", member_stats)
    
        channel_stats = (
        f"💬 Text Channels: {len(guild.text_channels)}\n"
        f"🔊 Voice Channels: {len(guild.voice_channels)}\n"
        f"📑 Categories: {len(guild.categories)}"
    )
        embed.add_field("Channel Statistics", channel_stats)
    
        if guild.icon:
            embed.set_thumbnail(url=guild.icon.url)
        else:
            embed.set_thumbnail(url="https://cdn.discordapp.com/embed/avatars/0.png")  
    
        await ctx.send(embed=embed.build())

    @commands.command()
    async def roles(self, ctx):
        roles = sorted(ctx.guild.roles[1:], key=lambda x: x.position, reverse=True)
        
        embed = EmbedBuilder(
            "🎭 Server Roles",
            f"Total Roles: {len(roles)}"
        ).set_color(discord.Color.gold())
        
        role_chunks = [roles[i:i + 20] for i in range(0, len(roles), 20)]
        
        for i, chunk in enumerate(role_chunks, 1):
            role_list = '\n'.join(f"{role.mention} - {len(role.members)} members" for role in chunk)
            embed.add_field(f"Roles (Page {i})", role_list, inline=False)
        
        await ctx.send(embed=embed.build())

    @commands.command()
    async def stats(self, ctx):
       
        uptime = str(timedelta(seconds=int(time.time() - self.bot.start_time)))
    
        embed = EmbedBuilder(
        "⚡ Bot Statistics",
        "Current bot performance and statistics"
    ).set_color(discord.Color.blue())
    
        embed.add_field("Uptime", uptime)
        embed.add_field("Servers", str(len(self.bot.guilds)))
        embed.add_field("Users", str(len(set(self.bot.get_all_members()))))
        embed.add_field("Commands Run", "Coming soon...")
        embed.add_field("Python Version", platform.python_version())
        embed.add_field("Discord.py Version", discord.__version__)
        embed.add_field("Script Version",  (ZygnalBot_Version))
    
        if self.bot.user.avatar:
            embed.set_thumbnail(url=self.bot.user.avatar.url)
        else:
            embed.set_thumbnail(url=self.bot.user.default_avatar.url)
    
        await ctx.send(embed=embed.build())


    @commands.command(aliases=["fakeoffline", "checkoffline"])
    async def detect_fake_offline(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        suspicious = False
        reasons = []

        if member.status != discord.Status.offline:
            await ctx.send(f"{member.display_name} is not offline — they're currently `{member.status}`.")
            return

        if member.voice:
            suspicious = True
            reasons.append("🎙️ In a voice channel while appearing offline.")

        recent_message_found = False
        async for message in ctx.channel.history(limit=50, after=datetime.utcnow() - timedelta(minutes=10)):
            if message.author.id == member.id:
                recent_message_found = True
                suspicious = True
                reasons.append(f"💬 Recently sent a message ({message.created_at.strftime('%H:%M:%S UTC')}).")
                break

        if not suspicious:
            reasons.append("No suspicious activity detected. They might be truly offline or hiding well.")

        embed = discord.Embed(
            title=f"🕵️ Fake Offline Check for {member.display_name}",
            color=discord.Color.orange()
        )
        embed.add_field(name="Reported Status", value=str(member.status), inline=False)
        embed.add_field(
            name="Suspicious?",
            value="✅ Possibly Fake Offline" if suspicious else "❌ Seems genuinely offline",
            inline=False
        )
        embed.add_field(name="Observations", value="\n".join(reasons), inline=False)
        embed.set_thumbnail(url=member.display_avatar.url)
        embed.set_footer(text=f"Requested by {ctx.author}", icon_url=ctx.author.display_avatar.url)

        await ctx.send(embed=embed)
    @commands.command(aliases=["scanfakeoffline", "scaninvisible"])
    async def fakeofflinescan(self, ctx):
        await ctx.send("🔎 Scanning for suspiciously 'offline' users... This might take a few seconds!")

        suspicious_users = []

        recent_messages = []
        async for message in ctx.channel.history(limit=100, after=datetime.utcnow() - timedelta(minutes=10)):
            recent_messages.append(message)

        for member in ctx.guild.members:
            if member.bot:
                continue  
            if member.status == discord.Status.offline:
               
                reasons = []
                suspicious = False

                if member.voice:
                    suspicious = True
                    reasons.append("🎙️ In a voice channel while offline.")

                for msg in recent_messages:
                    if msg.author.id == member.id:
                        suspicious = True
                        reasons.append(f"💬 Recently active in chat ({msg.created_at.strftime('%H:%M:%S UTC')}).")
                        break

                if suspicious:
                    suspicious_users.append((member, reasons))

        embed = discord.Embed(
            title="🕵️ Fake Offline User Scan Results",
            description="These users might be appearing offline but are still active.",
            color=discord.Color.orange()
        )

        if suspicious_users:
            for suspect, reasons in suspicious_users:
                embed.add_field(
                    name=f"{suspect.display_name} ({suspect.id})",
                    value="\n".join(reasons),
                    inline=False
                )
        else:
            embed.description = "✅ No suspiciously fake offline users detected."

        embed.set_footer(text=f"Scan requested by {ctx.author}", icon_url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)

    @commands.command()
    async def userinfo(self, ctx, member: discord.Member = None):
        member = member or ctx.author

        if isinstance(ctx.channel, discord.abc.GuildChannel):
            try:
                member = ctx.guild.get_member(member.id) or member
            except:
                pass

        joined_at = member.joined_at.strftime("%B %d, %Y at %H:%M") if isinstance(member, discord.Member) and member.joined_at else "N/A"
        top_role = member.top_role.mention if isinstance(member, discord.Member) else "N/A"
        roles = " ".join(role.mention for role in member.roles[1:]) if isinstance(member, discord.Member) else "N/A"
        boosting = (
            f"✅ Since {member.premium_since.strftime('%B %d, %Y')}"
            if isinstance(member, discord.Member) and member.premium_since
            else "❌ Not boosting"
        )
        activities = []
        if isinstance(member, discord.Member):
            for activity in member.activities:
                if isinstance(activity, discord.Spotify):
                    activities.append(f"🎵 Listening to **{activity.title}** by *{activity.artist}*")
                elif isinstance(activity, discord.Game):
                    activities.append(f"🎮 Playing **{activity.name}**")
                elif isinstance(activity, discord.Streaming):
                    activities.append(f"📺 Streaming **{activity.name}** on {activity.platform}")
                elif isinstance(activity, discord.CustomActivity) and activity.name:
                    activities.append(f"💬 Custom Status: {activity.name}")
                else:
                    activities.append(f"⚡ {activity.type.name.title()}: {activity.name}")

        embed = discord.Embed(
            title=f"👤 User Information - {member}",
            description=f"Details about {member.mention}",
            color=member.color if isinstance(member, discord.Member) and member.color else discord.Color.blurple()
        )
        embed.add_field(name="Username", value=f"{member} (`{member.id}`)", inline=False)
        embed.add_field(name="Top Role", value=top_role, inline=False)
        embed.add_field(name="Joined Server", value=joined_at, inline=False)
        embed.add_field(name="Account Created", value=member.created_at.strftime("%B %d, %Y at %H:%M"), inline=False)
        embed.add_field(name="Roles", value=roles, inline=False)
        embed.add_field(name="Boosting?", value=boosting, inline=False)
        embed.add_field(name="Current Activities", value="\n".join(activities) if activities else "None", inline=False)
        embed.set_thumbnail(url=member.display_avatar.url)
        embed.set_footer(text=f"Requested by {ctx.author}", icon_url=ctx.author.display_avatar.url)

        await ctx.send(embed=embed)

class HelpView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=60)

    @discord.ui.button(label="part Two →", style=ButtonStyle.success, custom_id="help_part2_button", emoji="✨", row=4)
    async def show_part2(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = EmbedBuilder(
            "✨ Part Two",
            "Discover additional powerful tools"
        ).set_color(discord.Color.brand_green())
        
        view = HelpViewTwo()
        await interaction.response.edit_message(embed=embed.build(), view=view)       

    @discord.ui.select(
        placeholder="Select command category",
        row=3,
        min_values=1,
        max_values=1,
        options=[
            discord.SelectOption(label="🛡️ 𝐌𝐨𝐝𝐞𝐫𝐚𝐭𝐢𝐨𝐧", description="Ban, kick, and mute commands", emoji="🛡️"),
            discord.SelectOption(label="🔵 𝐌𝐚𝐧𝐚𝐠𝐞𝐦𝐞𝐧𝐭 [1]", description="Server management commands Part 1", emoji="⚙️"),
            discord.SelectOption(label="🔵 𝐌𝐚𝐧𝐚𝐠𝐞𝐦𝐞𝐧𝐭 [2]", description="Server management commands Part 2", emoji="⚙️"),
            discord.SelectOption(label="ℹ️ 𝐈𝐧𝐟𝐨𝐫𝐦𝐚𝐭𝐢𝐨𝐧", description="Server and user info commands", emoji="ℹ️"),
            discord.SelectOption(label="🎫 𝐓𝐢𝐜𝐤𝐞𝐭𝐬", description="Ticket system commands", emoji="🎫"),
            discord.SelectOption(label="💾 𝐁𝐚𝐜𝐤𝐮𝐩", description="Server backup and restore commands", emoji="💾"),
            discord.SelectOption(label="⚙️ 𝐂𝐨𝐧𝐟𝐢𝐠", description="Configuration import/export commands", emoji="⚙️"),  
            discord.SelectOption(label="🎉 Fun/𝐌𝐢𝐧𝐢𝐠𝐚𝐦𝐞𝐬", description="MiniGames", emoji="🎉"),
            discord.SelectOption(label="AFK", description="AFK commands", emoji="😶‍🌫️"),
            discord.SelectOption(label="🔎 𝐒𝐧𝐢𝐩𝐞", description="Snipes", emoji="🔎"),
            discord.SelectOption(label="🎭 𝐑𝐨𝐥𝐞 𝐏𝐚𝐧𝐞𝐥𝐬", description="Role panel management commands", emoji="🎭"),
            discord.SelectOption(label="📈 𝐋𝐞𝐯𝐞𝐥𝐢𝐧𝐠", description="Leveling system commands", emoji="📈"),
            discord.SelectOption(label="🔒 𝐕𝐞𝐫𝐢𝐟𝐢𝐜𝐚𝐭𝐢𝐨𝐧", description="Verification system commands", emoji="🔒"),
            discord.SelectOption(label="🤖 𝐁𝐨𝐭 𝐕𝐞𝐫𝐢𝐟𝐢𝐜𝐚𝐭𝐢𝐨𝐧", description="Bot verification and whitelist commands", emoji="🤖"),
            discord.SelectOption(label="⭐ 𝐑𝐚𝐭𝐢𝐧𝐠", description="Rating system commands", emoji="⭐"),
            discord.SelectOption(label="𝐀𝐈 𝐒𝐲𝐬𝐭𝐞𝐦", description="AI commands and settings", emoji="🤖"),
            discord.SelectOption(label="Embed", description="Embed commands", emoji="🧾"),
            discord.SelectOption(label="TempChannels", description="Create and manage temporary channels", emoji="📝"),
            discord.SelectOption(label="profile", description="Customize your server profile", emoji="👤"),
            discord.SelectOption(label="Webhooks", description="Webhook settings and commands", emoji="📡"),
            discord.SelectOption(label="CustomVerification", description="Manual Verify commands", emoji="🪄"),
            discord.SelectOption(label="advertisements", description="Advertisement System Commands", emoji="🧾"),
            discord.SelectOption(label="Coding Tools", description="Coding tools commands", emoji="🔧"),
            discord.SelectOption(label="Calculations", description="Calculations and TimeZone Converter", emoji="📊"),
            discord.SelectOption(label="Study Tools", description="All Study related tools on one command", emoji="📚"),
        ]
    )

    async def select_category(self, interaction: discord.Interaction, select: discord.ui.Select):
        category_info = {
            "🛡️ 𝐌𝐨𝐝𝐞𝐫𝐚𝐭𝐢𝐨𝐧": {
                "title": "🛡️ Moderation",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}ban <user> [duration] [reason]": "Permanently ban a user | Add duration (7d2h10m5s) for temporary ban",
                    f"{CMD_PREFIX}ban_appeal <dc server| website | custom message": "make a custom appeal server when person will be banned he will see that",
                    f"{CMD_PREFIX}unban <user_id> [reason]": "Unban a user",
                    f"{CMD_PREFIX}kick <user> [reason]": "Kick a user from the server",
                    f"{CMD_PREFIX}mute <user> <duration> [reason]": "Temporarily mute a user",
                    f"{CMD_PREFIX}unmute <user": "Unmutes a user",
                    f"{CMD_PREFIX}warn <user> [reason]": "Issue a warning to a user",
                    f"{CMD_PREFIX}clear <amount>": "Clear specified amount of messages",
                    f"{CMD_PREFIX}nuke [channel]": "Completely reset a channel",
                    f"{CMD_PREFIX}vcmute <user>": "Mute user in voice chat",
                    f"{CMD_PREFIX}vcunmute <user>": "Unmute user in voice chat",
                    f"{CMD_PREFIX}togglelinks": "Toggle links in chat/ by default on",
                    f"{CMD_PREFIX}security_audit": "Scans the server for security issues",
                }
            },  
            "Calculations": {
                "title": "🧮 Calculations",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}bmi": "BMI Calc",
                    f"{CMD_PREFIX}math": "math Calc",
                    f"{CMD_PREFIX}physics": "physics Calc",
                    f"{CMD_PREFIX}time": "Time Converters, Time Tools and more "
                }
            },
            "Study Tools": {
                "title": "📚 Study Tools",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}study": "Study Related Tools",
                    f"{CMD_PREFIX}time": "Time Converters, Time Tools and more",
                    f"{CMD_PREFIX}isbn <isbn>": "Looks up book information and generates citations",
                    f"{CMD_PREFIX}cite": "Creates formatted citations in various academic styles",
                    f"{CMD_PREFIX}translate": "opens a translate menu"
                }        
            },            
            "Coding Tools": {
                "title": "Coding Tools",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}code": "Coding Tools",
                    f"{CMD_PREFIX}colorpicker": "Color Picker",
                }
            },
            "🔵 𝐌𝐚𝐧𝐚𝐠𝐞𝐦𝐞𝐧𝐭 [1]": {
                "title": "⚙️ Management Commands",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}mutesetup": "who ever gets muted gets this role you configured with that command",
                    f"{CMD_PREFIX}lockdown [channel] [Min]": "Lock a channel | (optional) for a specified time",
                    f"{CMD_PREFIX}unlock [channel]": "Unlock a channel",
                    f"{CMD_PREFIX}slowmode <seconds>": "Set channel slowmode",
                    f"{CMD_PREFIX}announce <channel>": "send a announcement to a channel | opens a menu",
                    f"{CMD_PREFIX}addrole <user> <role>": "Add a role to a user",
                    f"{CMD_PREFIX}removerole <user> <role>": "Remove a role from a user",
                    f"{CMD_PREFIX}autorole <role>": "Automatically assign a role to new members - Toggle",
                    f"{CMD_PREFIX}autorole": "show current autorole status",
                    f"{CMD_PREFIX}rolepanel": "Create a role panel for users to select roles",
                    f"{CMD_PREFIX}welcome": "Welcome panel (shows u all)",
                    f"{CMD_PREFIX}automod": "Open the automod pannels with infos and settings",
                    f"{CMD_PREFIX}setup": "setup basic server setup",
                    f"{CMD_PREFIX}nickname <user_id> <nickname>": "Change the user's nickname.",
                    f"{CMD_PREFIX}nickname <user_id>": "remove the users nickname.",
                    
                }
            },
            "🔵 𝐌𝐚𝐧𝐚𝐠𝐞𝐦𝐞𝐧𝐭 [2]": {
                "title": "⚙️ Management Commands",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}massrole <role>": "Add a role to all members",
                    f"{CMD_PREFIX}embed <title> <description>": "Create a custom embed message",
                    f"{CMD_PREFIX}say <channel> <message>": "Make the bot send a message",
                    f"{CMD_PREFIX}addchannel <channel> <user>": "Allows a user access to a channel",
                    f"{CMD_PREFIX}removechannel <channel> <user>": "Remove a user from a channel",
                    f"{CMD_PREFIX}inivte <duration> <max uses>": "Create an invite link for a channel with customizable duration and max uses",
                    f"{CMD_PREFIX}invite_view": "Show all invite links and information about them",
                    f"{CMD_PREFIX}reminder": "Opens the reminder pannel",
                    f"{CMD_PREFIX}editreminder ": "Edit ur reminders with a panel",
                    f"{CMD_PREFIX}purge <user| bots | links> <amount/nuke>": "Purge messages from a user, bots, or links",
                    f"{CMD_PREFIX}mood": "Opens the mood pannel",
                    f"{CMD_PREFIX}hide <optional| <channel>": "hides a channel",
                    f"{CMD_PREFIX}show <optional| <channel>": "shows a channel",
                    f"{CMD_PREFIX}ideasystem": "Opens ideasystem panel",
                    f"{CMD_PREFIX}security_audit": "Scans the server for security issues",
                }
            },
            "ℹ️ 𝐈𝐧𝐟𝐨𝐫𝐦𝐚𝐭𝐢𝐨𝐧": {
                "title": "ℹ️ Information Commands",
                "color": discord.Color.green(),
                "commands": {
                    f"{CMD_PREFIX}serverinfo": "Display server statistics",
                    f"{CMD_PREFIX}userinfo [user]": "Show user information",
                    f"{CMD_PREFIX}roles": "List all server roles",
                    f"{CMD_PREFIX}stats": "Show bot statistics",
                    f"{CMD_PREFIX}activity <user>": "Check user activity status",
                    f"{CMD_PREFIX}servericon": "Show server icon in full size",
                    f"{CMD_PREFIX}createpoll ": "Create a reaction poll | Opens main Menu/Button",
                    f"{CMD_PREFIX}avatar [user]": "Show user's avatar in full size",
                    f"{CMD_PREFIX}ping": "Check bot's response time",
                    f"{CMD_PREFIX}analyse daily <channel>": "Sets up daily analytics tracking and reporting in the specified channel.",
                    f"{CMD_PREFIX}analyse weekly <channel>": "Sets up weekly analytics tracking and reporting in the specified channel.",
                    f"{CMD_PREFIX}analyse monthly <channel>": "Sets up monthly analytics tracking and reporting in the specified channel.",
                    f"{CMD_PREFIX}analyse": "Show all analytics status",
                    f"{CMD_PREFIX}view_historic": "Lets u see who joined with what invite",
                    f"{CMD_PREFIX}wordstats": "Shows word stats | (Enhanced)",
                    f"{CMD_PREFIX}setprefix <prefix>": "Set the bot's command prefix (Admin only)",
                    f"{CMD_PREFIX}fakeoffline [member]": "Check if a specific user is faking offline by detecting recent activity or presence in voice channels.",
                    f"{CMD_PREFIX}fakeofflinescan": "Scan the entire server for members who appear offline but show signs of activity.",

                }
            },
            "🎫 𝐓𝐢𝐜𝐤𝐞𝐭𝐬": {
                    "title": "🎫 Ticket Commands",
                    "color": discord.Color.gold(),
                    "commands": {
                        f"{CMD_PREFIX}ticketsetup <title> <description> <embed color> <button color>": "Creates a ticket panel with a button called 'Create Ticket' when pressed it opens a window where it says to describe your problem after that ticket",
                        f"{CMD_PREFIX}close": "Close current ticket",
                        f"{CMD_PREFIX}add <user>": "Add user to ticket",
                        f"{CMD_PREFIX}remove <user>": "Remove user from ticket",
                        f"{CMD_PREFIX}ticketadmin <role>": "Setup what roles get added to the ticket",
                        f"{CMD_PREFIX}ticketadmin": "Shows current ticket admin role",
                        f"{CMD_PREFIX}ticketsetup_json": "Creates a ticket panel using JSON configuration (attach .json file or paste JSON)",
                        f"{CMD_PREFIX}ticketsetup_json example": "Shows example JSON format for ticket setup",
                       
                        f"{CMD_PREFIX}fixticket <category id>": "Set the category where tickets are created",
                        f"{CMD_PREFIX}fixlogs <channel id>": "set the channel where ticket logs are sent",
                    }
                },
            "Webhooks": {
                        "title": "Webhook Commands",
                        "color": discord.Color.gold(),
                        "commands": {
                            f"{CMD_PREFIX}webhook": "Opens the webhook dashboard",
                }
            },
            "💾 𝐁𝐚𝐜𝐤𝐮𝐩": {
                "title": "💾 Backup Commands",
                "color": discord.Color.purple(),
                "commands": {
                    f"{CMD_PREFIX}backup": "Creates basic structure backup (roles, channels, permissions) ",
                    f"{CMD_PREFIX}backup true": "Creates full backup including messages (up to 100 messages per channel) ",
                    f"{CMD_PREFIX}backup True 500": "Creates full backup with custom message limit (500 messages per channel in this example)",
                    f"{CMD_PREFIX}restore": "Restores a server from a backup file (attach the .json backup file with the command)| No Attachments (eg. txt/videos..) ",
                    f"{CMD_PREFIX}copychannel <channel_id>": "Creates a complete 1:1 backup of a specific channel including all messages, files and settings",
                    f"{CMD_PREFIX}pastechannel <attach zip>": "Restores a channel from backup (attach the backup ZIP file)",
                    f"{CMD_PREFIX}copyrole <role_id>": "Creates a complete backup of a specific role including all settings and members | Copies everything even Atachments",
                    f"{CMD_PREFIX}pasterole <attach zip>": "Restores a role from backup (attach the backup ZIP file)"
                }
            },
            "⚙️ 𝐂𝐨𝐧𝐟𝐢𝐠": {
                "title": "⚙️ Configuration Commands/export/import cmds",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}exportconfig": "Export all server settings to a JSON file",
                    f"{CMD_PREFIX}importconfig": "Import server settings from a JSON file (attach the file)",
                    
                    f"{CMD_PREFIX}importrating": "import ratings data from a JSON file",
                    f"{CMD_PREFIX}exportrating": "export ratings data to a JSON file",

                    f"{CMD_PREFIX}importrolepanel": f"import role panel data from a JSON file (if using _json just use {CMD_PREFIX}importconfig)",
                    f"{CMD_PREFIX}exportrolepanel": f"export role panel data to a JSON file if using _json just use {CMD_PREFIX}exportingconfig",

                    f"{CMD_PREFIX}import_mood_data": "import mood data from a JSON file",
                    f"{CMD_PREFIX}export_mood_data": "export mood data to a JSON file",

                    f"{CMD_PREFIX}import_analytics": "import analytics data from a JSON file",
                    f"{CMD_PREFIX}export_analytics": "export analytics data to a JSON file",
                }

            },
            "Embed": {
                "title": "Embed Commands",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}embed <title> <description> <color>": "Create a basic embed message",
                    f"{CMD_PREFIX}embedhelp": "Shows examples and formats for JSON embeds",
                    f"{CMD_PREFIX}jsonembed + attached .json file": "Create embed from a JSON file (supports Discohook format)",
                    f"{CMD_PREFIX}jsonembed (json data)": "Create embed from JSON text (supports all formats)",
                    f"{CMD_PREFIX}embed color": "Shows list of available embed colors",
                    f"{CMD_PREFIX}embed preview <color>": "Preview how a color looks in an embed"
                }
            },
            "🎵 Music": {
                "title": "🎵 Music Commands | Not Recommended",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}player": "Shows Music Menu",
                   
            }
        },   
        "🎉 Fun/𝐌𝐢𝐧𝐢𝐠𝐚𝐦𝐞𝐬": {
            "title": "🎮 Fun Commands",
            "color": discord.Color.orange(),
            "commands": {
                f"{CMD_PREFIX}numbergame <number> <channel>": "Lets admins create a number game",
                "<number>": "lets players guess the number in the chat it started",
                f"{CMD_PREFIX}tictactoe": "Starts a tic tac toe game",
                f"{CMD_PREFIX}joke": "Tells a random joke",
                f"{CMD_PREFIX}games": "Shows the all games",
                f"{CMD_PREFIX}player": "Shows Music Menu",
                f"{CMD_PREFIX}rng <min> <max>": "Generates a random number between min and max",
                f"{CMD_PREFIX}roast <userid | ping>": "Roasts a user",
                f"{CMD_PREFIX}sudo": "mimic a user with webhook | Admin only",
                f"{CMD_PREFIX}roast": "Roasts the user who sent the command",
                "Check out Part two category BlackJack":"Check out Part two category BlackJack",
                "roast system": "Auto-triggers (type in chat):\n- roast me\n- destroy me\n- end me\n- murder me\n- obliterate me\n- finish me\n- delete me\n- wreck me\n- burn me\n- demolish me\n- annihilate me\n- terminate me\n- execute me\n- eliminate me\n- eradicate me\n- vaporize me"
            }
        },
        "AFK": {
                "title": "Afk Commands",
                "color": discord.Color.green(),
                "commands": {
                    f"{CMD_PREFIX}afk <reason>": "Puts u AFK",
                    f"{CMD_PREFIX}afk": "Toggle",
                    " - ": "if u write smth while afk it will break afk",
                }
            },
            "🔎 𝐒𝐧𝐢𝐩𝐞": {
                "title": "🔎 Snip Commands",
                "color": discord.Color.purple(),
                "commands": {
                    f"{CMD_PREFIX}snipe": "Lets u see the last deleted message",
                    f"{CMD_PREFIX}editsnipe": "you can see the latest edited message and see the before and after",
                    f"{CMD_PREFIX}snipe_info": "Shows the infos the duration of the snipe",
                    f"{CMD_PREFIX}configuresnipeedit <duration>": "command to configure the duration for edited messages.",
                    f"{CMD_PREFIX}configuresnipe <duration>": "command to configure the duration for deleted messages.",
                }
            },
            "🎭 𝐑𝐨𝐥𝐞 𝐏𝐚𝐧𝐞𝐥𝐬": {
                "title": "🎭 Role Panel Commands",
                "color": discord.Color.magenta(),
                "commands": {
                    f"{CMD_PREFIX}rolepanel": "Open the advanced role management panel with customization options",
                   f"{CMD_PREFIX}rolepanel_json": "opens a dashboard where u can uplaod the json for custom role panels",
                    f"{CMD_PREFIX}exportrolepanel": "Export all role panel configurations to a JSON file",
                    f"{CMD_PREFIX}importrolepanel <JSON file>": "Import role panel configurations from a JSON file (attach the file)",
                    "Usage": f"1. Create panels with {CMD_PREFIX}rolepanel\n2. Backup configs with {CMD_PREFIX}exportrolepanel\n3. Restore with {CMD_PREFIX}importrolepanel\n4. Use refresh button to update panels"
                }
            },
            "📈 𝐋𝐞𝐯𝐞𝐥𝐢𝐧𝐠": {  
                "title": "📈 Leveling System Commands",
                "color": discord.Color.teal(),
                "commands": {
                    f"{CMD_PREFIX}levelsetup": "Shows All infos/settings of the leveleling system",
                    f"{CMD_PREFIX}levelsetup <channel>": "Sets the channel where the leveling messages are sent",
                    f"{CMD_PREFIX}set_level_role <level> <role>": "Assign a role to a specific level.",
                    f"{CMD_PREFIX}leaderboard": "Display the server's leveling leaderboard.",
                    f"{CMD_PREFIX}my_level": "Check your current level and XP.",
                    f"{CMD_PREFIX}set_xp <user> <xp>": "Set a user's XP manually (Bot Owner only).",
                    f"{CMD_PREFIX}reset_levels": "Reset all leveling data for the server (Bot Owner only).",
                    f"{CMD_PREFIX}set_leaderboard_channel <channel>": "Set the channel for live-updating leaderboard.",
                    f"{CMD_PREFIX}add_achievement <name> <required_level> <reward>": "Add a new achievement (Bot Owner only).",
                    f"{CMD_PREFIX}set_xp_multiplier <role> <multiplier>": "Set an XP multiplier for a role (Bot Owner only).",
                }
            },
            "CustomVerification": {
                "title": "🔒 Verification Commands",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}verify_user": "Verifies a user",
                    f"{CMD_PREFIX}verify_setup_help": "Shows all the settings for the verification system",
                    f"{CMD_PREFIX}verify_user_setup":"Setup the verification system",

                }       
            },
            "🔒 𝐕𝐞𝐫𝐢𝐟𝐢𝐜𝐚𝐭𝐢𝐨𝐧": {
                "title": "🔒 Verification Commands",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}verifysetup": "Lets Admins Setup verification Button",

                }
            },
            "🤖 𝐁𝐨𝐭 𝐕𝐞𝐫𝐢𝐟𝐢𝐜𝐚𝐭𝐢𝐨𝐧": {
                "title": "🤖 Bot Verification Commands",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}botlogs #channel": "Sets the logging channel for unauthorized bot joins",
                    f"{CMD_PREFIX}botlogs": "Disables the bot join logging",
                    f"{CMD_PREFIX}whitelisted": "Displays a list of all whitelisted bots with names and IDs",
                    f"{CMD_PREFIX}whitelist_bot <bot_id>": "Adds a bot to the whitelist (Owner Only) | To get a bot's ID: Enable Developer Mode in Discord Settings > App Settings > Advanced, then right-click the bot and select 'Copy ID', or check the bot logs channel when the bot attempts to join"
                }
            },
            "⭐ 𝐑𝐚𝐭𝐢𝐧𝐠": {
                "title": "⭐ Rating System Commands",
                "color": discord.Color.gold(),
                "commands": {
                    f"{CMD_PREFIX}ratingsetup": "Create interactive rating panels with customizable stars/numbers/percentages",
                    f"{CMD_PREFIX}seerating": "View all rating panels with statistics and management options",
                    f"{CMD_PREFIX}ratingrefresh <panel_id>": "Refresh statistics for a specific rating panel",
                    f"{CMD_PREFIX}importrating <JSON file>": "Import rating configurations from a JSON file (attach the file)",
                    f"{CMD_PREFIX}exportrating": "Export all rating configurations to a JSON file",
                    "Features": "• Star Ratings (1-5)\n• Number Ratings (1-10)\n• Percentage Ratings (0-100%)\n• Real-time statistics\n• Visual vote tracking\n• One-click voting"
                    
                }
            },
            "𝐀𝐈 𝐒𝐲𝐬𝐭𝐞𝐦": {
                "title": "🤖 AI System Commands",
                "color": discord.Color.purple(),
                "commands": {
                    f"{CMD_PREFIX}ai_info": "Get information about the New Chat AI system",
                    f"{CMD_PREFIX}ai": "Opens the AI Command Center with all available features",
                    f"{CMD_PREFIX}ai chat <message>": "Interactive chat with context memory",
                    f"{CMD_PREFIX}ai create <prompt>": "Generate images with style control",
                    f"{CMD_PREFIX}ai analyze <text>": "Deep content analysis",
                    f"{CMD_PREFIX}ai predict <scenario>": "AI-powered predictions",
                    f"{CMD_PREFIX}ai settings": "Configure AI behavior (Model, Personality, Response Style)",
                    "Models": "• GPT-4 (Premium quality)\n• GPT-3.5 (Balanced)\n• GPT-3.5 Instruct (Fast)",
                    "Features": "• Context-aware conversations\n• Multiple personality modes\n• Customizable response styles\n• Image generation\n• Advanced text analysis"
                }
            },
            "TempChannels": {
                    "title": "Temp Channels",
                    "color": discord.Color.red(),
                    "commands": {
                            f"{CMD_PREFIX}setuptempchannel": "Creates a button panel for users to create temporary channels",

                }
            },
            "profile": {
                "title": "Profile/Social Commands",
                "color": discord.Color.green(),
                "commands": {
                    f"{CMD_PREFIX}p setup": "setup your own profile",
                    f"{CMD_PREFIX}p <userid>": "view a user's profile",

                }
            },
            "advertisements": {
                "title": "Advertisement System Commands",
                "color": discord.Color.gold(),
                "commands": {
                    
                    f"{CMD_PREFIX}serverad post": "Create your server advertisement",
                    f"{CMD_PREFIX}serverad bump": "Bump your ad to increase visibility",
                    f"{CMD_PREFIX}serverad preview": "Preview your current advertisement",
                    f"{CMD_PREFIX}serverad stats": "View your ad performance metrics",
                    f"{CMD_PREFIX}serverad serverad template": "Get the advertisement template",
                    f"{CMD_PREFIX}serverad serverad edit": "Modify your existing advertisement",
                    f"{CMD_PREFIX}ad_search [query]": "Find ads by name or tags",
                    f"{CMD_PREFIX}serverad rename_channel": "Customize your ad channel name",

                    f"{CMD_PREFIX}move_ad [msgid] [channel]": "[MOD] Move ads between channels",
                    f"{CMD_PREFIX}ad_channel_stats": "[MOD] View channel statistics",
                    f"{CMD_PREFIX}ad_cleanup": "[MOD] Remove expired advertisements",

                    f"{CMD_PREFIX}setup_ad_category": "[ADMIN] Create new ad category",
                    f"{CMD_PREFIX}serverad allow @user #channel": "[ADMIN] Grant posting permissions",
                    f"{CMD_PREFIX}ad_settings": "[ADMIN] Configure advertisement system",
                    f"{CMD_PREFIX}ad_stats": "[ADMIN] View system statistics",
                    f"{CMD_PREFIX}ad_blacklist [user]": "[ADMIN] Block users from advertising",
                    f"{CMD_PREFIX}ad_audit": "[ADMIN] Run system health check",
                    f"{CMD_PREFIX}ad_restore [user]": "[ADMIN] Recover deleted ads"
                    }
                },
                "Analytics": {
                    "title": "Analytics Commands",
                    "color": discord.Color.blue(),
                    "commands": {
                        f"{CMD_PREFIX}analytics": "View analytics for yourself/server | Working Fully",

                        f"{CMD_PREFIX}analytics <user>": "View analytics for a specific user | Not Tested Fully!" ,

                        f"{CMD_PREFIX}analytics import": "Import analytics data from JSON | Buggy",
                        f"{CMD_PREFIX}analytics export": "Export analytics data to JSON | Buggy",

                }
            }
        }



        category = category_info[select.values[0]]
        
        embed = EmbedBuilder(
            category["title"],
            "Detailed command information"
        ).set_color(category["color"])
        
        commands = list(category["commands"].items())
        
        for cmd, desc in commands[:24]:
            embed.add_field(cmd, desc, inline=False)
        
        remaining = len(commands) - 24
        footer_text = "🔹 Required <> | Optional []"
        if remaining > 0:
            footer_text += f" | {remaining} more commands available - Use !help {category['title']} for full list"
        
        embed.set_footer(footer_text)
        await interaction.response.edit_message(embed=embed.build(), view=self)

class HelpSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.readability_file = 'readability_settings.json'

    async def get_readability_setting(self, guild_id: str) -> bool:
        try:
            with open(self.readability_file, 'r') as f:
                settings = json.load(f)
                return settings.get(guild_id, False)
        except FileNotFoundError:
            return False

    @commands.command(name='panel')
    async def help_command(self, ctx):
        embed = EmbedBuilder(
            "⚡ Command Center - TheZ",
            "Welcome to the interactive command center!\nExplore our features below"
        ).set_color(discord.Color.brand_green())
        
        embed.set_thumbnail(ctx.guild.icon.url)
        
        stats = f"🤖 Serving {len(self.bot.guilds)} servers\n"
        stats += f"👥 Watching {sum(g.member_count for g in self.bot.guilds)} users\n"
        stats += f"📊 Version: {ZygnalBot_Version}"
        embed.add_field(name="📈 Bot Statistics", value=stats, inline=False)
        
        tips = f"• Curious for A Newer Version? use {CMD_PREFIX}checkupdate | (optional) force\n"
        tips += "• Use category buttons below to explore\n"
        tips += "• Some features require special permissions\n"
        tips += f"• {CMD_PREFIX}setprefix <prfix> | to change prefix \n"
        tips += "• Check out Zygnals Website: https://zygnalbot.de \n"
        tips += "• Need help? Join our support server"
        embed.add_field(name="💡 Quick Tips", value=tips, inline=False)
        
        embed.add_field(name="━━━━━━━━━━━━━━━", value="", inline=False)
        
        features = "🛡️ Advanced Moderation\n"
        features += "⚙️ Server Management\n"
        features += "🎮 Fun & Games\n"
        features += "📊 Analytics & More"
        embed.add_field(name="✨ Key Features", value=features, inline=False)
        
        embed.add_field(
            name="⚡ Powered By",
            value="**ZygnalBot** © 2025 *TheHolyOneZ*",
            inline=False
        )
        
        embed.set_footer(
            text="Security • Moderation • Entertainment", 
            icon_url=ctx.guild.icon.url
        )
        
        view = HelpView()
        
        await ctx.send(embed=embed.build(), view=view)
        
        if await self.get_readability_setting(str(ctx.guild.id)):
            for _ in range(7):
                await ctx.send("\u200b")

class HelpViewTwo(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=60)

    @discord.ui.select(
        placeholder="Select Feature Categorie",
        row=3,
        min_values=1,
        max_values=1,
        options=[
            discord.SelectOption(label="🔗 URL Shortener", description="Create and manage short URLs", emoji="✂️"),
            discord.SelectOption(label="Password Generator", description="Generate strong passwords", emoji="🛡️"),
            discord.SelectOption(label="Morse Code System", description="Morse Code System CMDS", emoji="📡"),
            discord.SelectOption(label="ASCII Commands", description="ASCII convert text to ascii", emoji="🔤"),
            discord.SelectOption(label="Network/ip Cmds", description="Network Commands", emoji="🌍"),
            discord.SelectOption(label="File/Download Cmds", description="File and download Commands", emoji="📂"),
           discord.SelectOption(label="All Elements (Element Table 118)", description="All Element table commands", emoji="⚛️"),
           discord.SelectOption(label="Hack Commands (Fun)", description="Funny Hack Commands", emoji="💻"),
           discord.SelectOption(label="Anti-Ghost Ping System", description="AntiGhost-Ping System", emoji="🔒"),
           discord.SelectOption(label="ANTRIPHOIC", description="ANTRIPHOIC|Claude AI | NOTE ADVANCED SETTINGS IN WORK", emoji="🤖"),
           discord.SelectOption(label="Love", description="Love/Relation cmds", emoji="❤️"),
           discord.SelectOption(label="Violence-Fun", description="Violence cmds | but funny", emoji="🔫"),
           discord.SelectOption(label="Riot API", description="Riot API cmds", emoji="🌐"),
           discord.SelectOption(label="BlackJack Game", description="BlackJack Game cmds", emoji="🃏"),
           discord.SelectOption(label="Clear Channel System", description="Clear Channel System cmds", emoji="🧹"),
           discord.SelectOption(label="AntiNuke System", description="AntiNuke System", emoji="💣"),
           discord.SelectOption(label="Translate System", description="Translate System", emoji="🌍"),
           discord.SelectOption(label="Giveaway System", description="Giveaway System Commands", emoji="🎉"),
           discord.SelectOption(label="Custom Commands/Alias", description="Custom Commands/Alias ", emoji="🔗"),
           discord.SelectOption(label="Birthday System", description="Birthday System Commands", emoji="🎂"),
            
        ],
        custom_id="help_part2_select"
    )
    async def select_category(self, interaction: discord.Interaction, select: discord.ui.Select):
        category_info = {
            "🔗 URL Shortener": {
                "title": "🔗 URL Shortener System",
                "color": discord.Color.blue(),
                "commands": {
                    f"{CMD_PREFIX}url shorten <url>": "Create a shortened URL",
                }
            },
            "Password Generator": {
                "title": "Password Generator | Pass will be sent to your dm!",
                "color": discord.Color.purple(),
                "commands": {
                    f"{CMD_PREFIX}password": "Opens Password Generator menu",
                    f"{CMD_PREFIX}pw": "Opens Password Generator menu",
                }
            },
            "Morse Code System": {
                "title": "Morse Code System",
                "color": discord.Color.orange(),
                "commands": {
                    f"{CMD_PREFIX}morse encode <text>": "Convert text to Morse code",
                    f"{CMD_PREFIX}morse decode <morse>": " Convert Morse code to text",
                    f"{CMD_PREFIX}morse audio <text>": "Generate Morse code in audio format",
                }
            },
            "ASCII Commands": {
                "title": "ASCII Commands",
                "color": discord.Color.gold(),
                "commands": {
                    f"{CMD_PREFIX}ascii": "Opens ASCII Menu",
                    
                }
            },
            "Network/ip Cmds": {
                "title": "Network/ip Cmds",
                "color": discord.Color.gold(),
                "commands": {
                    f"{CMD_PREFIX}iplookup <ip address/domain>": "Gives u info about ip (Enhanced)",
                    f"{CMD_PREFIX}urlchecker": "Opens Url checker UI/menu",
                 
                }
            },
            "File/Download Cmds": {
                "title": "File/Download cmds",
                "color": discord.Color.gold(),
                "commands": {
                    f"{CMD_PREFIX}convert <size|number> <unit>": "Convert size to another unit/s and gives u all infos about it good for large small files where are many numbers",
                    f"{CMD_PREFIX}identify <attach file> ": " File type indentifier",
                    f"{CMD_PREFIX}downloadcalc <Size to download> <Download speed | MBS>": "Tells u the time to download a file",
                }
            },
            "All Elements (Element Table 118)": {
                "title": "Element Table",
                "color": discord.Color.gold(),
                "commands": {
                    f"{CMD_PREFIX}element ": "Gives u info about all elements/Opens a Interactive Element table",
                    f"{CMD_PREFIX}element <element>": "Gives u info about element",
                }
            },
            "Hack Commands (Fun)": {
                "title": "Hack Commands (Fun)",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}hack <target>": "Hack a target",
                    f"{CMD_PREFIX}decrypt <message>": "Decrypt a message",
                    f"{CMD_PREFIX}matrix": "Matrix effect",
                    f"{CMD_PREFIX}scan <target>": "Scan a target",
                }
            },
            "Anti-Ghost Ping System": {
                "title": "Anti-Ghost Ping System",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}toggleghost <on/off>": "command toggles the Antighost mode for ghost ping detection",
                    f"{CMD_PREFIX}ghoststrict <on/off>": "command toggles the strict mode for ghost ping detection",
                    f"{CMD_PREFIX}setghostlogs <#channel|channel>": " to set up the logging channel",
                    "Mute System": "Info: If a person tries to ghost ping people the system will mute him for 30 min after 3 attempts of ghost pinging"
                }
            },
            "ANTRIPHOIC": {
                "title": "ANTRIPHOIC",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}claude": "Opens ANTRIPHOIC UI/menu | uses Claude-2 only at the moment!",
                }
            },
            "Love": {
                "title": "Love",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}hug @user": "Hugs a user",
                    f"{CMD_PREFIX}kiss @user": "Kiss a user",
                    f"{CMD_PREFIX}love @user": "Spreads love and affection with sparkly effects",
                    f"{CMD_PREFIX}cuddle @user": "Cuddles a user with a animation",
                    f"{CMD_PREFIX}pat @user": "Pat a user with a cute animation",
                    f"{CMD_PREFIX}loverate @user1 @user2": "Rate a user's love level",
                }
            },
            "Violence-Fun": {
                "title": "Shoot-Fun",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}shoot @user [body part]": "Shoot at users body part",
                    f"{CMD_PREFIX}sniper @user": "Shoot at user with a sniper",
                    f"{CMD_PREFIX}tactical-nuke @user": "Shoot at user with a tactical nuke",
                    f"{CMD_PREFIX}beatup @user": "Beat up a user",
                    f"{CMD_PREFIX}fighttodeath @user": "Fight to death with a user",
                    f"{CMD_PREFIX}techroast @user": "Tech roast a user",
                    f"{CMD_PREFIX}2v1fight @teamuser @target": "2v1 fight with a user",
                }
            },
            "Riot API": {
                "title": "Riot API",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}lol ": "LoL api menu",
                    f"{CMD_PREFIX}val": "Valorant api menu",
                    f"{CMD_PREFIX}tft": "teamfight tactics api menu"
                }
            },
            
            "BlackJack Game": {
                "title": "BlackJack Game",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}blackjack <bet> <multiplayer>": "Host starts a game Multiplayer=True example: !blackjack 100 True",
                    f"{CMD_PREFIX}jackadd <user> <amount>": "Adds money to a user",
                    f"{CMD_PREFIX}jacktransfer <user> <amount>": "Transfers money to a user",
                    f"{CMD_PREFIX}jackbalance": "Shows your balance",

                }
            },
            "Clear Channel System": {
                "title": "Clear Channel System",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}clear_channel <channel/id> <duration h,d,s,m>": "Sets up automatic clearing every duration",
                    f"{CMD_PREFIX}clear_channel <channel>": "disables automatic clearing for this channel",
                    f"{CMD_PREFIX}clear_channel": "shows if automatic clearing is enabled for this channel",
                }
            },
            "AntiNuke System": {
                "title": "AntiNuke System",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}antinuke": "Opens a menu to set up the AntiNuke System",
                    f"{CMD_PREFIX}an": "Opens a menu to set up the AntiNuke System",
                    f"{CMD_PREFIX}listprotected": "Shows a list of protcted roles",
                    f"{CMD_PREFIX}addprotected <role>": "Adds a role to the list of protected roles",
                    f"{CMD_PREFIX}removeprotected <role>": "Removes a role from the list of protected roles",
                    f"{CMD_PREFIX}setalertchannel <channel>": "Sets the alert channel",
                }
            },
            "Translate System": {
                "title": "Translate System",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}translate": "opens a translate menu",
                }
            },
            "Giveaway System": {
                "title": "Giveaway System",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}giveaway": "Opens a giveaway Panel",
                    }

                },
            "Custom Commands/Alias": {
                "title": "Custom Commands/Alias",
                "color": discord.Color.red(),
                "commands": {
                    f"{CMD_PREFIX}alias":  "To get a full list of commands for aliases",
                    f"{CMD_PREFIX}alias create": "Create a new alias for an existing command",
                    f"{CMD_PREFIX}alias delete <alias>": "Delete an existing alias",
                    f"{CMD_PREFIX}alias list": "List all existing aliases",
                    f"{CMD_PREFIX}alias info <alias>": "Get information about an existing alias",
                    f"{CMD_PREFIX}custom": "To get a full list for custom commands",
                    f"{CMD_PREFIX}custom create": "Create a new custom command",
                    f"{CMD_PREFIX}custom delete <command>": "Delete an existing custom command",
                    f"{CMD_PREFIX}custom list": "List all existing custom commands",
                    f"{CMD_PREFIX}custom info <command>": "Get information about an existing custom command",
                    }
                },
                "Birthday System": {
                    "title": "Birthday System",
                    "color": discord.Color.red(),
                    "commands": {
                        f"{CMD_PREFIX}birthday": "Opens a birthday menu",
                        f"{CMD_PREFIX}birthday_set ": "form to set your birthday",
                        f"{CMD_PREFIX}view_birthday": "view all birthdays",
                        f"{CMD_PREFIX}remove_birthday": "remove your birthday",
                        f"{CMD_PREFIX}list_birthdays": "view all birthdays",
                        f"{CMD_PREFIX}birthday_setup": "Lets Admins Setup the Birthday System",
                        f"{CMD_PREFIX}birthday_add [@user] [month] [day] [year]": "Manually add a birthday for a user",
                        f"{CMD_PREFIX}birthday_post [#channel]": "Post the birthday registration embed",
                        f"{CMD_PREFIX}birthday_customize": "Customize the registration embed appearance",
                        f"{CMD_PREFIX}birthday_settings": "View the birthday settings",
                        f"{CMD_PREFIX}birthday_channel #channel": "Set the channel for birthday announcements",
                        f"{CMD_PREFIX}set_birthday_role [role_id]": "Set the role given to users on their birthday",
                        f"{CMD_PREFIX}set_announcement_message [text]": "Set the message for birthday announcements",
                        f"{CMD_PREFIX}birthday_enable": "Enable the birthday system",
                        f"{CMD_PREFIX}birthday_disable": "Disable the birthday system",
                        f"{CMD_PREFIX}remove_user_birthday [user_id]": "remove a user's birthday",
                        f"{CMD_PREFIX}toggle_birthday_system true/false": "Enabled/Disable Birthday System",
                }
            }
        }

        category = category_info[select.values[0]]
        embed = EmbedBuilder(
            category["title"],
            "Available Commands:"
        ).set_color(category["color"])
        
        for cmd, desc in category["commands"].items():
            embed.add_field(cmd, desc, inline=False)
            
        embed.set_footer("🔹 Required <> | Optional []")
        await interaction.response.edit_message(embed=embed.build(), view=self)

    @discord.ui.button(label="Part Three →", style=ButtonStyle.success, custom_id="help_part3_button", emoji="🌟", row=4)
    async def show_part3(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = EmbedBuilder(
            "🌟 Part Three",
            "Explore even more advanced features"
        ).set_color(discord.Color.brand_red())
        
        view = HelpViewThree()
        await interaction.response.edit_message(embed=embed.build(), view=view)

    @discord.ui.button(label="← Back to Main Panel", style=ButtonStyle.primary, custom_id="back_main", emoji="◀️", row=4)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        view = HelpView()
        embed = EmbedBuilder(
            "⚡ Command Center - TheZ",
            "Select a category below to view available commands"
        ).set_color(discord.Color.blue())
        await interaction.response.edit_message(embed=embed.build(), view=view)

class HelpViewThree(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=60)

    @discord.ui.select(
        placeholder="Select Feature Category",
        row=3,
        min_values=1,
        max_values=1,
        options=[
            discord.SelectOption(label="NoteBook", description="All Notebook Commands", emoji="📖"),
            discord.SelectOption(label="Cogs & Update Manager", description="Cogs & Update Manager", emoji="🛠️"),
            discord.SelectOption(label="TheZ's Alg", description="Sorting Algothm Commands", emoji="🧮"),
            discord.SelectOption(label="Extra Config/Server/Bot Stuff", description="Extra Stuff", emoji="🛠️"),
            discord.SelectOption(label="Rule Management", description="Create/Manage Rule Embeds and Rules itself", emoji="📜"),
            discord.SelectOption(label="Extension Loader", description="Extension AutoLoader Cog", emoji="🧩")
        
        ],
        custom_id="help_part3_select"
    )
    async def select_category(self, interaction: discord.Interaction, select: discord.ui.Select):
        category_info = {
            "NoteBook": {
                "title": " 📖 NoteBook",
                "color": discord.Color.purple(),
                "commands": {
                    f"{CMD_PREFIX}notebook or {CMD_PREFIX}nb": "Open the notebook menu",
                    f"{CMD_PREFIX}bm <message id> you can also use {CMD_PREFIX}save <message id>": "Bookmark a message",
                }
            },
            "Cogs & Update Manager": {
                "title": "🛠️ Cogs & Update Manager",
                "color": discord.Color.green(),
                "commands": {
                    f"{CMD_PREFIX}checkupdate": "Shows you If there is a new update",
                    f"{CMD_PREFIX}checkupdate force": "Force check for updates",
                    f"{CMD_PREFIX}updatehelp": "Shows you a Help Embed for Update Commands",
                    f"{CMD_PREFIX}coghelp": "Shows you a Help Embed for Cog Commands/management",

                    
                    }
                },
                "TheZ's Alg": {
                    "title": "🧮 TheZ's Alg",
                    "color": discord.Color.gold(),
                    "commands": {
                        f"{CMD_PREFIX}zsort_help": "Opens a Help Embed for TheZ's Alg",
                        f"{CMD_PREFIX}zsort <number(1 2 3 4 5..)>": "Sorts a list of numbers",
                        f"{CMD_PREFIX}zsort_json <attach json with numbers>": "Sorts a json file with numbers",
                        f"{CMD_PREFIX}zsort_txt <attach txt with numbers>": "Sorts a txt file with numbers",
                        f"{CMD_PREFIX}zsort_csv <attach csv with numbers>": "Sorts a csv file with numbers",
                        f"{CMD_PREFIX}zsort_benchmark <number of elements>": "Benchmarks TheZ's Alg"
                    }
                },
                "Extra Config/Server/Bot Stuff": {
                    "title": "Just Extras",
                    "color": discord.Color.blurple(),
                    "commands": {
                        f"{CMD_PREFIX}sync_here": "Sync Commands to the guild",
                        f"{CMD_PREFIX}config": "See config panel (in dev)",
                        "/config": "for the same config panel as said above"
                    }
                },
                "Rule Management": {
                    "title": "Rule Management",
                    "color": discord.Color.gold(),
                    "commands": {
                        f"{CMD_PREFIX}rule_help setup": "opens the setup menu",
                        f"{CMD_PREFIX}rule_help view": "View the current rules",
                        f"{CMD_PREFIX}rule_help manage": "Manage existing rules | MENU",
                        f"{CMD_PREFIX}rule_help theme": "Customize rule appearance",
                        "NOTE": f"Everything Above Is Configurable with {CMD_PREFIX}rule_help setup\n",
                        f"{CMD_PREFIX}rule_help import": "Import rules from another channe | Not Tested",
                        f"{CMD_PREFIX}rule_help export": "Export rules to a file"

                }
            },
            "Extension Loader": {
                "title": "🧩 Extension Loader",
                "color": discord.Color.blurple(),
                "commands": {
                    f"{CMD_PREFIX}mp": "Opens Extension Marketplace",
                    f"{CMD_PREFIX}marketplace": "Opens Extension Marketplace",
                    f"{CMD_PREFIX}extension": "Extension Management Control Panel",
                    f"{CMD_PREFIX}ext": "Extension Management Control Panel (alias)",
                    f"{CMD_PREFIX}extension list": "List all available and loaded extensions",
                    f"{CMD_PREFIX}extension load <name>": "Load a specific extension",
                    f"{CMD_PREFIX}extension unload <name>": "Unload a specific extension",
                    f"{CMD_PREFIX}extension reload <name>": "Reload a specific extension",
                    f"{CMD_PREFIX}extension reloadall": "Reload all currently loaded extensions"
                }
            }
        }



        category = category_info[select.values[0]]
        embed = EmbedBuilder(
            category["title"],
            "Available Commands:"
        ).set_color(category["color"])
        
        for cmd, desc in category["commands"].items():
            embed.add_field(cmd, desc, inline=False)
            
        embed.set_footer("🔹 Required <> | Optional []")
        await interaction.response.edit_message(embed=embed.build(), view=self)

    @discord.ui.button(label="← Back to Part Two", style=ButtonStyle.primary, custom_id="back_part2", emoji="◀️", row=4)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = EmbedBuilder(
            "✨ Part Two",
            "Discover additional powerful tools"
        ).set_color(discord.Color.brand_green())
        
        view = HelpViewTwo()
        await interaction.response.edit_message(embed=embed.build(), view=view)


class ReadabilityButton(discord.ui.Button):
    def __init__(self, cog):
        super().__init__(
            style=discord.ButtonStyle.secondary,
            label="Toggle Readability",
            custom_id="readability_toggle"
        )
        self.cog = cog

    async def callback(self, interaction: discord.Interaction):
        guild_id = str(interaction.guild.id)
        try:
            with open(self.cog.readability_file, 'r') as f:
                settings = json.load(f)
        except FileNotFoundError:
            settings = {}

        settings[guild_id] = not settings.get(guild_id, False)
        
        with open(self.cog.readability_file, 'w') as f:
            json.dump(settings, f)

        if settings[guild_id]:
            for _ in range(7):
                await interaction.channel.send("\u200b")

        await interaction.response.send_message(
            f"Readability mode: {'Enabled' if settings[guild_id] else 'Disabled'}", 
            ephemeral=True
        )

class AutoMod(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.spam_check = {}  
        self.caps_threshold = 0.7  
        self.spam_threshold = 5  
        self.spam_interval = 5  
        self.spam_timeout_minutes = 10  
        self.link_whitelist = set()  
        self.banned_words = set()  
        self.link_filter_enabled = True
        self.load_config() 
        self.caps_enabled = True
        self.badwords_enabled = True

        self.banned_regex = {word: re.compile(rf'\b{re.escape(word)}\b', re.IGNORECASE) for word in self.banned_words}


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def togglelinks(self, ctx):
        self.link_filter_enabled = not self.link_filter_enabled
        status = "enabled" if self.link_filter_enabled else "disabled"
        
        embed = discord.Embed(
            title="🔗 Anti-Link Filter",
            description=f"Link filtering is now **{status}**",
            color=discord.Color.green() if self.link_filter_enabled else discord.Color.red()
        )
        await ctx.send(embed=embed)

    def load_config(self):
        self.banned_words = {
        "nga", "btc",   
        "hurensohn", "hure", "hurre", "hur3", "hur3ns0hn", "h.u.r.e", "h_u_r_e", 
        "h-u-r-e", "h.u.r.e.n.s.o.h.n", "h_u_r_e_n_s_o_h_n", "h-u-r-e-n-s-o-h-n", 
        "hur3n50hn", "huhrensohn", "hurns0hn", "hurenson", "hurens0hn", "huurensohn", 
        "hureens0hn", "hur3nsohn", "hu-rensohn", "h***ensohn", "hurenzohn", 
        "hurenzoon", "h.uhrensohn", "h@rensohn", "hu~~rensohn", "hurens0*h", 
        "hurenson~", "hu-r3n50hn",
        "schlampe", "schl4mp3", "schl4mpe", "schl.4.mp3", "schl_4_mp3", 
        "schl-4-mp3", "schlamp@", "schlam.p3", "sch|ampe", "schla.mpe", 
        "schl**ampe", "sch|4mp3", "sch~lampe", "schlamp3!", "schlampe-", 
        "sch4mpe", "schl#mp3", "schlamp#", "s-chlampe", "sch|4mp3",
        "fotze", "f0tz3", "f.o.t.z.e", "f_o_t_z_e", "f-o-t-z-e", "f0tz3nkn3cht", 
        "fotz3", "f0t.z3", "fo_tz3", "f*tz3", "fötze", "fö.tze", "fot~ze", 
        "f0~~tz3", "fo~tze", "fotz#", "fot_z3", "f0tz3n~knecht", 
        "arschloch", "4rschl0ch", "arschl0ch", "4rschloch", "4r5chl0ch", 
        "4r5chl0ch", "arsch|och", "ar-schloch", "arsch.loch", "ar.sch.l0ch", 
        "arsch~loch", "arsch-l0ch", "arschl#ch", "ars~hloch", "arsc.hloch", 
        "schwuchtel", "schwul", "schw.u.l", "schw_u_l", "schw-u-l", "schwuul", 
        "schw~ul", "schwül", "schwu~~l", "sch~wuchtel", "schwu|chtel", "schwucht@l", 
        "schw@ul", "sch~wul", "schwu|l", 
        "nazi", "naz1", "n4z1", "n.a.z.i", "n_a_z_i", "n-a-z-i", "n4z1st", 
        "na~~zi", "n~azi", "na!!zi", "na.z.i", "n-a~zi", "n4zi!", 
        "heil", "h31l", "h.e.i.l", "h_e_i_l", "h-e-i-l", "h31l3r", 
        "hitler", "h1tl3r", "hitl3r", "h1tler", "h1.tl3r", "h1_tl3r", 
        "h|tl3r", "hi~tler", "h***ler", "h@tl3r", "hi!tler", 
        "wichser", "w1chs3r", "w1chser", "wichs3r", "w1.chs3r", "w1_chs3r", 
        "wi-chser", "w|chs3r", "wi~chser", "w!chser", "w*chs3r", "wi.chs3r", 
        "spast", "sp4st", "sp.4.st", "sp_4_st", "sp-4-st", "sp4st1", 
        "sp.ast", "sp~ast", "sp@st", "sp~~ast", "s-p4st", "sp**st", 
        "kanake", "k4n4k3", "k4nake", "kan4ke", "k4n.4k3", "k4n_4k3", 
        "ka.nake", "kan~ake", "kan@ke", "k@nake", "k4n4k3!", "ka**ke", 
        "missgeburt", "m1ssgeburt", "missg3burt", "m1ssg3burt", "m1ssg3.burt", 
        "mi~ssgeburt", "mis|geburt", "miss~geburt", "missg3b~urt", "m1ss-g3burt", 
        "nutte", "n0tt3", "nutt3", "n0tte", "n.u.t.t.e", "n_u_t_t_e", 
        "nut~te", "nutt@e", "n~utte", "nutte!", "nu~~tte", "nu.t.te", 
        "fick", "f1ck", "f.i.c.k", "f_i_c_k", "f-i-c-k", "f1ck3n", 
        "ficken", "f1ck3n", "f1cken", "fick3n", "f1.ck3n", "f1_ck3n", 
        "fi~cken", "fick**", "fi~~ck3n", "fi*cken", 
        "scheisse", "sch31ss3", "scheiss3", "sche1sse", "sch.31ss3", 
        "sch~eisse", "sch#isse", "schei~~sse", "sch3iss3", "sche***sse", 
        "fotzenknecht", "f0tz3nkn3cht", "fotz3nknecht", "f0tzenknecht", 
        "fo~~tzenknecht", "fotzen~knecht", "fotzenk~~necht", "fo**knecht", 
        "drecksau", "dr3cks4u", "drecks4u", "dr3cksau", "dr3.cks4u", 
        "dreck~~sau", "dre~cksau", "drecks4u!", "dr3cks@u", 
        "drecksfotze", "dr3cksf0tz3", "drecksf0tze", "dr3cksfotze", 
        "dr~ecksfotze", "drecksf~otze", "dr3~cksfotze", 
        "whore", "wh0re", "whoree", "whör", "wh0r3", "w.h.o.r.e", "w_h_o_r_e",
        "wh0r3h0und", "wh0r3.h0und", "wh0r3_h0und", "wh0r3-h0und", 
        "who.re", "wh*r3", "wh@re", "wh~ore", "whor3", "wh0r@", "wh***re", 
        "wh.re", "who_r3", "who--re", "who~~re", "wh*r3h0und", "wh0_r3h0und",
        "bitch", "b1tch", "b!tch", "b*tch", "b1tch3s", "b!tches", "b17ch", 
        "b.i.t.c.h", "b_i_t_c_h", "b-i-t-c-h", "b1.t.ch", "b1_t_ch", 
        "bitch3s", "b!tch3s", "b1**h", "b*tch3", "bi**h", "bi.t.ch", "b!t.ch",
        "b*ches", "bitc#h", "bi7ch", "bi***h", "b_1tch", "b*t@ches", "b!7ch", 
        "cunt", "kunt", "c*nt", "cxnt", "cvnt", "cuntz", "kuntz", "c0nt", 
        "c.u.n.t", "c_u_n_t", "c-u-n-t", "c0.nt", "c0_nt", "c0-nt", 
        "c.nt", "cu.nt", "k_nt", "kun.t", "cu~nt", "cun7", "c@n7", "k*nt", 
        "slut", "sl*t", "sl4t", "slutz", "sl0t", "slvt", "sl_t", "s1ut", 
        "s.l.u.t", "s_l_u_t", "s-l-u-t", "sl.ut", "sl_ut", "sl-ut", 
        "s1ut", "sl~ut", "sl_tt", "s-l~ut", "slvvut", "sl@t", "s!ut", 
        "faggot", "f4gg0t", "f4ggot", "fag", "f4g", "f@g", "f@gg0t", 
        "f.a.g.g.o.t", "f_a_g_g_o_t", "f-a-g-g-o-t", "f4.gg0t", 
        "f.g.g.o.t", "fa~~g", "f4got", "fa.ggot", "f*g", "fa@@t", "fa!got", 
        "retard", "ret4rd", "r3t4rd", "r3tard", "r3t@rd", "ret@rd", 
        "r.e.t.a.r.d", "r_e_t_a_r_d", "r-e-t-a-r-d", "r3.t4rd", 
        "ret@rded", "r-tard", "re**rd", "re~tard", "r3tard", "r.t~rd", 
        "pussy", "pussies", "p*ssy", "p*ss", "puss1", "p0ssy", "pvssy", 
        "p.u.s.s.y", "p_u_s_s_y", "p-u-s-s-y", "p0.ssy", "p0_ssy", 
        "pussycat", "p*ss!es", "p0ussy", "pu~~ssy", "pu$s", "pu.ssy", 
        "dick", "d1ck", "d!ck", "d*ck", "d1ckhead", "dickhead", "d1ckh34d", 
        "d.i.c.k", "d_i_c_k", "d-i-c-k", "d1.ck", "d1_ck", "d1-ck", 
        "d1cky", "d!cks", "dickz", "di.ck", "dic~k", "di*c", "dic#k", 
        "cock", "c0ck", "cxck", "c*ck", "c0cks", "c0ckz", "cocksucker", 
        "c.o.c.k", "c_o_c_k", "c-o-c-k", "c0.ck", "c0_ck", "c0-ck", 
        "cocks", "co~ck", "c**ks", "c0c*k", "cx*ck", "c@ck", "co~cks",
        "s*upid", 
        "penis", "p3n1s", "pen1s", "p3nis", "p3n!s", "pen!s", "p3n15", 
        "p.e.n.i.s", "p_e_n_i_s", "p-e-n-i-s", "p3.n1s", "p3_n1s", 
        "p.nis", "p3n@s", "pen*s", "p3~~nis", "p3ni$", "pe!nis", "pen!5", 
        "WHORE", "BITCH", "CUNT", "SLUT", "FAGGOT", "RETARD", "PUSSY", 
        "DICK", "COCK", "PENIS", "WH0RE", "B1TCH", "C*NT", "SL*UT", 
        "F@GGOT", "RE**ARD", "P*SSY", "D!CK", "C*CK", "P3N1S",
        "putain", "put1n", "put@in", "put@1n", "putaine", "put@ine", "put@1ne",
        "p.u.t.a.i.n", "p_u_t_a_i_n", "p-u-t-a-i-n", "put.1n", "put_1n", 
        "put*ain", "p!utain", "pu**ain", "p#tain", "p~utain", "pûtain", 
        "putăin", "putäin", "pu&tain", "p.u.tain", "pu|tain", "p-u-t-4-i-n", 
        "pu++ain", "put@!", "putin@", "put@ne", "pu7ain", "put@1n!", 
        "salope", "sal0pe", "s@l0pe", "s@lope", "s@l0p3", "sal0p3", "s@lop3", 
        "s.a.l.o.p.e", "s_a_l_o_p_e", "s-a-l-o-p-e", "s@l.0pe", "s@l_0pe", 
        "sal*pe", "s!lope", "s@l0pe", "s4l0p3", "sälöpe", "sä|ope", "sal0p@", 
        "sal~~ope", "sa|ope", "sa!!pe", "sa---lope", "s@lop@", "s@lo&pe", 
        "connard", "c0nnard", "conn@rd", "c0nn@rd", "c0nn4rd", "c0nn@rd", 
        "c.o.n.n.a.r.d", "c_o_n_n_a_r_d", "c-o-n-n-a-r-d", "c0nn.@rd", 
        "con**ard", "conn@r!", "çonnard", "çønnard", "con~~nard", "co#nard", 
        "conn|ard", "co--nnard", "con.n@rd", "cónnard", "cónnärd", "ç0nn4rd", 
        "merde", "m3rd3", "m3rde", "m3rd3", "m@rd3", "m@rde", "m3rd@", 
        "m.e.r.d.e", "m_e_r_d_e", "m-e-r-d-e", "m3.rd3", "m3_rd3", 
        "me**de", "m3**d3", "me@rde", "mer.d3", "mer_d@", "mêrde", 
        "mérde", "mërdè", "m~~erde", "mèrde", "mérd@", "m3r@de", 
        "enculé", "encu1é", "encu1e", "encu*é", "encülé", "encul@", "encu1@", 
        "en.c.u.l.é", "en_c_u_l_é", "en-cu-lé", "en-cu**é", "encu|é", 
        "bâtard", "batard", "b4tard", "b@tard", "b4t@rd", "bätärd", "ba**ard", 
        "bordel", "b0rd3l", "bord3l", "b0rd@l", "b0rdel", "bord*l", "bor~~del", 
        "pute", "pu**e", "p@ute", "pu~te", "pu_te", "pu-t-e", "pu.te", 
        "foutre", "f0utr3", "f@utre", "foutr@", "fout~re", "fo!tre", "foutr3", 
        "p..utain", "s@l***pe", "c~onnard", "me!rd@", "fo~~utre", "bat~~ard", 
        "enc~~ulé", "bo~~rdel", "pu**t@ine", "m3**rd3", "pu--t-ai-ne", 
        "encul@d", "encu1-@", "c#onnard", "m€rde", "sa|op@", "putain*", 
        "f**tre", "p.ut.in", "s_a_l.o_pe", "conn~ard", "m.rd@", "en_cu&lé", 
        "pute", "putte", "poutain", "poutine", "pootain", "sallop", "salaupe", 
        "merdre", "merrde", "merdd", "connars", "conart", "connar", 
        "enculéé", "encule", "encûlé", "encoulé", "bâtars", "batards", "batar", 
        "vazy", "vasi", "vasie", "va chier", "va te faire", "vaff", "fauteuil", 
        "PUTAIN", "PUT@IN", "SALOPE", "CONNARD", "MERDE", "ENCULÉ", "BÂTARD", 
        "BORDEL", "PUTE", "FOUTRE", "S@LOPE", "C*NNARD", "M3RDE", "ENCUL3", 
        "EN_CU_LÉ", "BA**ARD", "FOU_TRE", "PU-TE", "ME-RDE", "VAFFANCULO",
        "puttana", "putt4n4", "putt@n@", "putt@n4", "putt4n@", "putt4n4",
        "p.u.t.t.a.n.a", "p_u_t_t_a_n_a", "p-u-t-t-a-n-a", "putt.4n4", 
        "p*uttana", "p!uttana", "pu**tana", "p@uttana", "putta!na", "pu.t.t.a.n.a",
        "put.tana", "putt_a_na", "p--u-t-t-a-n-a", "p~u~t~t~a~n~a", 
        "puttan4", "pút.tànà", "pu##ana", "puttan@", "puʇʇanɐ",
        "cazzo", "c4zz0", "c@zz0", "c@zzo", "c4zzo", "c@zz0", "c4zz0",
        "c.a.z.z.o", "c_a_z_z_o", "c-a-z-z-o", "c4.zz0", "c4_zz0", 
        "càzzò", "cäzzö", "c*zzo", "ca##o", "c@zzo!", "çazzo", 
        "ca_zzo", "c-a.z.z-o", "c~azz0", "k4zz0", "căzzô", "ç@zz0",
        "stronzo", "str0nz0", "str0nzo", "str0nz@", "str0nz4", "str0nz0",
        "s.t.r.o.n.z.o", "s_t_r_o_n_z_o", "s-t-r-o-n-z-o", "str0.nz0", 
        "stronz0", "str0n.z.o", "st-r-on-z-o", "str0n*z@", "s~tronzo", 
        "strömzø", "st_ronz0", "s-t_r_o-n-z-o", "ştronzo", "str0nz#", 
        "merda", "m3rd@", "m3rd4", "m.e.r.d.a", "m_e_r_d_a", "m-e-r-d-a", "m3rda",
        "figa", "f1g@", "f1ga", "f.i.g.a", "f_i_g_a", "f-iga", "fig@", "fi**a",
        "bastardo", "b4st@rd0", "b4stardo", "b.a.s.t.a.r.d.o", "b_a_s_t_a_r_d_o",
        "vaffanculo", "v4ff4ncul0", "v@ff@nculo", "vaff@nculo", "vaffancul@", 
        "pezzo di m3rd@", "pezzo_di_merda", "p.e.z.z.o.d.i.m.e.r.d.a", "pezzo.d.m.", 
        "co****ne", "c0*****e", "co--gli**ne", "çoglione", "c-o-g-l-i-o-n-e", 
        "zoccola", "z0ccol@", "z0ccola", "z.o.c.c.o.l.a", "z_o_c_c_o_l_a", 
        "figliodiputtana", "figli0diputt4n@", "figli0_diputt@n@", 
        "vaf*****ulo", "vaff@*********", "c****0 di m***a", 
        "p._utt4n@", "c.4_zz0", "s_t**nzo", "me$$da", "fi@@a", "va~~fan~~culo", 
        "str**nz@", "put&@n@", "fig.o~", "bas***do", "za!ccola", "pe##o", 
        "vaff_~anculo", "c0gl!ion#", "c.o.g.l.-o.n.e", "pez*dimerda", 
        "potana", "pottana", "puttna", "putna", "pzzo", "strunzo", "stronza", 
        "strozno", "strozo", "bastard@", "merd@", "merdino", "vafan", "vafanc", 
        "vafa!", "fanculo", "fan****lo", "fu***", "cul0", "culo!", "cul@", "kulo",
        "figh@", "figha", "fi*ha", "f1gh@", "figh3", "ma****", "mannaggia", 
        "mann@ggia", "mann***ia", "mannagg1a",
        "Puttana", "PUTTANA", "PUTT4N4", "PUTT@n@", "PUTT@n4", "PUTT@N@", 
        "CAZZO", "C4ZZO", "C@ZZO", "C.A.Z.Z.O", "C-A-Z-Z-O", "MERDA", "FIGA",
        "STRONZO", "Vaffanculo", "COGLIONE", "ZOCCOLA", "BASTARDO", "CUL0",
        "FAN****LO", "FI@HA", "POTANA", "VAFFA",
        "馬鹿", "バカ", "死ね", "クソ", "カス", "ちんこ", "まんこ", "おっぱい",
        "baka", "b4k4", "b@k@", "b@k4", "b4k@", "b@k@", "b4k4", "b@k4",
        "b.a.k.a", "b_a_k_a", "b-a-k-a", "b4.k4", "b4_k4", "b4-k4",
        "kuso", "kus0", "ku50", "kus@", "ku5@", "kus0", "ku50", "kus@",
        "k.u.s.o", "k_u_s_o", "k-u-s-o", "kus.0", "kus_0", "kus-0",
        "baka-san", "baka-chan", "baka-kun", "baka-sama", "baka desu", 
        "baka da", "baka ne", "baka yo", "baka baka", "baka na", "baka janai",
        "baka mitai", "baka sugiru", "baka deshou", "baka desho", 
        "baka hontou", "baka shinde", "baka shine", "baka yarou", "baka mono",
        "kusotare", "kusogaki", "kuso yarou", "kuso baka", "kuso shine",
        "kuso janai", "kuso mitai", "kuso desu", "kuso da", "kuso yo",
        "kuso kuso", "kuso mono", "kuso ne", "kuso sugiru", "kusottare",
        "kuso baka shine", "kuso yarou shine", "kusoyarou baka",
        "kusoyarou shine", "kusottare shine", "kusoyarou baka shine",
        "baka kuso", "baka kusoyarou", "baka kusottare", "baka shine yo",
        "baka kuso shine", "baka kusoyarou shine", "baka kusottare shine",
        "chinko", "chinkokun", "chinkochan", "chinko shine", "chinko baka",
        "chinko kuso", "chinko yarou", "chinko shine yo", "chinko shine ne",
        "chinko sugiru", "chinko yarou baka", "chinko baka shine",
        "manman", "manmanko", "mankosu", "mankoyarou", "manko shine",
        "manko baka", "manko kuso", "manko yarou", "manko shine yo",
        "manko shine ne", "manko sugiru", "manko yarou baka", "manko baka shine",
        "manko kusoyarou", "manko kusottare", "oppai", "oppai yarou", 
        "oppai baka", "oppai kuso", "oppai shine", "oppai baka shine", 
        "oppai kusoyarou", "oppai kusottare", "oppai sugiru", 
        "oppai yarou baka", "oppai baka shine", "oppai kusoyarou shine",
        "shine", "shine yo", "shine ne", "shine baka", "shine kuso",
        "shine yarou", "shine desu", "shine na", "shine mitai", 
        "shine sugiru", "shine janai", "shine yarou baka", "shine baka kuso",
        "shine kusoyarou", "shine kusottare", "shine baka shine",
        "kusoyarou", "kusoyarou shine yo", "kusoyarou shine ne",
        "kusoyarou shine baka", "kusoyarou shine kuso", "kusoyarou baka shine",
        "kusottare shine", "kusottare shine yo", "kusottare shine ne",
        "kusottare shine baka", "kusottare shine kuso", "kusottare baka shine",
        "baka yarou shine", "baka yarou shine yo", "baka yarou shine ne",
        "baka yarou shine baka", "baka yarou shine kuso", "baka yarou kuso shine",
        "baka yarou kusoyarou", "baka yarou kusottare", "baka yarou baka shine",
        "baka yarou kuso shine baka", "baka yarou kusoyarou shine",
        "baka yarou kusottare shine", "baka yarou kuso baka shine",
        "baka yarou kuso baka shine yo", "baka yarou kuso baka shine ne",
        "baka yarou kuso baka shine sugiru", "baka yarou kuso baka shine desu",
        "baka yarou kuso baka shine janai", "baka yarou kuso baka shine mitai",
        "baka yarou kuso baka shine hontou",
        "n1gg4", "n1gg3r", "n1663r", "n166a", "n1664", "nigg4", "nigg3r",
        "n.i.g.g.4", "n_i_g_g_4", "n-i-g-g-4", "n1.gg4", "n1_gg4",
        "f.u.c.k", "f_u_c_k", "f-u-c-k", "f.v.c.k", "f_v_c_k", "f-v-c-k",
        "fvck", "phuck", "phvck", "fück", "fuck", "f*ck", "f**k", "fuk",
        "fucc", "fukk", "fuking", "fucking", "fvcking", "phucking",
        "motherfucker", "mothafucka", "muthafucka", "mtherfcker",
        "mthrfckr", "motherfckr", "mothafckr", "mthafckr", "mtherfker",
        "n1ggar", "n1gger", "niggah", "niggar", "niggur", "niggarz", "niggahz",
        "nigga", "nigger", "btch", "bitch", "b1tch", "b1tchz", "b1tchaz",
        "n1ggah", "niggaz", "n1ggaz", "nigguh", "n1gguh", "nigguz", "n1gguz",
        "fukc", "fukkk", "fukkin", "fukker", "fukerz", "fukken", "fukingz",
        "fuckz", "fuckinn", "fuckinnz", "fuckers", "fuckersz", "fuckar",
        "fuckah", "fvckz", "fvcukk", "fvcukz", "fvckah", "fvckar", "fvckez",
        "phuk", "phukk", "phucker", "phuckar", "phuckah", "phukerz",
        "phucken", "phukking", "phukers", "fukz", "fukah", "fukkez", "fukers",
        "motherfuck", "mthrfuck", "mtherfuk", "mtherfuckah", "mtherfuckar",
        "mthafucka", "muthafukah", "mthrfkkr", "mtherfkerz", "motherfkkr",
        "muthrfcker", "mthafker", "motherfkerz", "mtherfkkr", "mtherfukah",
        "fukcinn", "fuckinnah", "fuckahzz", "fuckarzz", "fvcah", "fvcar",
        "fvcuck", "fvckahz", "fukinnzz", "phuckinn", "phukin", "phuckk",
        "phukinzz", "phuckkk", "phuckerzz", "phukingg", "mothafker", "mthafkr",
        "muthafkr", "mthrfck", "mothrfckr", "mthafcker", "mthrfkerz",
        "motherfkrz", "mthrfuckk", "mtherfukker", "mthrfukkerz", "motherfker",
        "mtherfkrz", "mthafukker", "mthrfker", "mthrfkrr", "motherfukkerz",
        "fuckinnn", "fukcinnn", "fukkerz", "fukinnzz", "fvckinn", "fvckinnz",
        "phuckah", "phuckahz", "fvcker", "fvckerz", "phukahz", "phukinzz",
        "phuckeninn", "phuckerinn", "phukerszz", "fukking", "fuckinggg",
        "fuckkinnz", "fuckinz", "fuckennz", "fvcukinnz", "fukahnn", "fvcahz",
        "fvcahh", "fvckarh", "fukkerinn", "fuckkerinn", "fuckennn", "fukennz",
        "fvcukinn", "fvcukkinn", "phvcukk", "phvcukkah", "fvckinnnn",
        "fvckennnn", "fvckennz", "phukenn", "phuckeninnzz", "fukcah", "phukah",
        "fukinnnzz", "fuckarrr", "fvckarrr", "phuckarrr", "phukenarrr",
        "phukckk", "phvckk", "fvckarzz", "fuckarz", "fuckinnzzz", "fvckinnz",
        "phukz", "fukkzzz", "fukkahz", "phukkahzz", "mtherfkr", "mtherfkkr",
        "mthrfkkrz", "mthrfkrz", "mthrfkkrr", "mthrfuckkrr", "mtherfkkrr",
        "motherfkkrr", "motherfkrr", "motherfuckahrr", "motherfkkrz",
        "mthrfukkrz", "mthrfuckarrr", "mthrfkerinn", "motherfkerinn",
        "motherfuckerinn", "mthrfkerah", "mtherfukkerzz", "motherfukkerinnzz",
        "mthrfkerahzz", "fukkz", "fuckkz", "fvckzz", "fvckahzz", "phvcah",
        "phvcukz", "fvcckzz", "fvcckah", "fukkkah", "phukahzz", "phvcukah",
        "phvcukahzz", "phukckkzz", "phvcukenn", "fukenn", "fuckkinnzz", 
        "fvckennzz", "phuckar", "phuckarrrzz", "fukinnnnz", "fvckinnnnz", 
        "phuckinnzz", "phuckerinnzz", "fvccahnn", "fvccahh", "fvccukzz",
        "fvccennzz", "fvccenn", "fvccukennzz", "fvccahz", "phuckennzz",
        "fvccahnnzz", "fukahz", "phukahh", "phvcukahh", "fvccahinnzz", 
        "fvccahkk", "phuckkkinn", "phvcukinn", "phvcukinnzz", "fvccukahh", 
        "fvcckerzz", "fvcckerinnzz", "phvcahzz", "fvccennnnz",
        "kys", "k y s", "k.y.s", "k_y_s", "k-y-s", "k.y.s.", "k_y_s_",
        "kill yourself", "k1ll y0urs3lf", "k!ll y0urs3lf", "k1ll y0urs3lf",
        "k.i.l.l.y.o.u.r.s.e.l.f", "k_i_l_l_y_o_u_r_s_e_l_f",
        "suicide", "su1c1d3", "su1c1de", "suic1de", "su1cide", "su!c!de",
        "s.u.i.c.i.d.e", "s_u_i_c_i_d_e", "s-u-i-c-i-d-e", "su1.c1d3",
        "self harm", "s3lf h4rm", "s3lf.h4rm", "s3lf_h4rm", "s3lf-h4rm",
        "s.e.l.f.h.a.r.m", "s_e_l_f_h_a_r_m", "s-e-l-f-h-a-r-m",
        "kys now", "kys immediately", "kys today", "kys please", "kys fast",
        "kill_urself", "kill_ur_self", "kill-yourself-now", "kill yourself fast",
        "kill yourself today", "just kill yourself", "why not kys", "go kys now",
        "you should kys", "how to kys", "kys tutorial", "suicide now", 
        "do suicide", "go do suicide", "commit suicide", "suicide guide",
        "suicide fast", "suicide quickly", "suicide tonight", "suicide tomorrow",
        "suicide for sure", "s u i c i d e", "sui cide", "suicide plans",
        "plan suicide", "suicide instructions", "suicide advice",
        "suicide methods", "suicide help", "how to self harm", 
        "self_harm_now", "self harm tutorial", "commit self harm", 
        "self harm guide", "self harm plan", "start self harm", 
        "self harm immediately", "self harm today", "self harm please",
        "self harm now", "you should self harm", "just self harm", 
        "self harm instructions", "self harm advice", "self harm tips",
        "how to commit self harm", "self_harm_tutorial", "self harm tonight",
        "go self harm", "self harm methods", "self harm fast", 
        "self_harm_quickly", "self harm quickly", "commit_self_harm",
        "self harm tomorrow", "self harm suggestions", "ways to self harm",
        "steps to self harm", "suicide plans now", "self harm guide online",
        "why not suicide", "learn suicide", "find suicide tips",
        "kill your self", "kill yourself today", "kill yourself tips",
        "kys easily", "kys guide", "how to kys quickly", 
        "kys suggestions", "kys steps", "how to kys instructions",
        "kys easily today", "kys methods online", "kys safely",
        "self harm safely", "self harm today fast", "commit self harm tonight",
        "self harm immediately tips", "suicide now guide", 
        "suicide fast steps", "commit suicide tomorrow", 
        "do suicide plans", "just suicide", "you should suicide now",
        "go and suicide", "kys faster", "kys slower", "kill your self today",
        "suicide now tutorial", "suicide now advice", "why suicide is good",
        "how suicide works", "self harm is okay", "start self harming now",
        "self_harm_help", "self harm techniques", "self harm advice online",
        "kys instructions online", "suicide tips fast", "suicide now tutorial",
        "commit self harm tutorial", "start_kys", "kys help", "kys now please",
        "suicide please", "help me suicide", "suicide suggestions",
        "kys planning", "kys execution", "suicide execution", "suicide tonight",
        "commit_suicide_fast", "plan your suicide", "how to kys properly",
        "suicide guide instructions", "how to commit_self_harm",
        "self harm advice safely", "how to end it all", "end your life now",
        "suicide today", "learn how to kys", "you should kys now",
        "kys_step_by_step", "ways to end it", "self_harm_online",
        "go harm yourself", "just go kys", "suicide plans fast",
        "commit_suicide_instructions", "kill_your_self_guide", "end it tutorial",
        "self harm method", "method for self harm", "suicide execution guide",
        "suicide execution tips", "suicide execution methods",
        "kys_today", "kill_your_self_fast", "suicide fast tonight",
        "self harm tonight plans", "commit self harm fast guide",
        "suicide tomorrow plans", "harm yourself safely", 
        "harm yourself guide", "harm yourself tips", 
        "harm yourself methods", "harm yourself fast", 
        "harm yourself now tutorial", "how to harm yourself easily", 
        "suicide step guide", "suicide instruction plans", 
        "suicide_tips", "suicide safely guide", "self harm safely tips",
        "harm yourself now", "why harm yourself", "why not self harm",
        "harm yourself techniques", "harm yourself execution",
        "harm yourself tools", "tools for suicide", "tools for harm",
        "suicide techniques safely", "harm yourself fast online", 
        "tools for self harm", "harm yourself instructions", 
        "commit_harm", "commit_self_harm_steps", "suicide safely tutorial",
        "free nitro", "fr33 n1tr0", "free.nitro", "fr33.n1tr0", "fr33_n1tr0",
        "f.r.e.e.n.i.t.r.o", "f_r_e_e_n_i_t_r_o", "f-r-e-e-n-i-t-r-o",
        "steam gift", "st34m g1ft", "steam.gift", "st34m.g1ft", "st34m_g1ft",
        "s.t.e.a.m.g.i.f.t", "s_t_e_a_m_g_i_f_t", "s-t-e-a-m-g-i-f-t",
        "robux generator", "r0bux g3n3r4t0r", "robux.generator",
        "r.o.b.u.x.g.e.n.e.r.a.t.o.r", "r_o_b_u_x_2_g_e_n_e_r_a_t_o_r",
        "free_nitro_code", "free nitro giveaway", "free nitro bot",
        "get free nitro", "nitro giveaway free", "free nitro now",
        "steam_gift_card", "steam gift codes", "steam_gift_now",
        "free_steam_gift", "robux free generator", "robux gift generator",
        "robux free codes", "robux generator free", "robux generator online",
        "free_nitro_code_2023", "free_nitro_generator", "nitro free discord",
        "free discord nitro", "nitro discount free", "discord gift nitro",
        "steam_discount_gift", "steam freebie gift", "free_robux_now",
        "robux free access", "robux generator new", "robux generator giveaway",
        "robux hack generator", "free_robux_bot", "discord_free_gift",
        "discord_nitro_bot", "get_free_robux", "robux_online_tool",
        "discord_code_generator", "discord_nitro_free", "steam_gift_online",
        "steam_card_gift", "steam_card_discount", "robux_hack_tool",
        "robux_promo_codes", "robux_gift_online", "robux_tool_generator",
        "free_gift_online", "discord_promo_bot", "steam_promo_codes",
        "steam_code_hack", "free_steam_codes", "robux_promo_tool",
        "robux_access_generator", "get_steam_card", "free_gift_steam",
        "nitro_giveaway_bot", "discord_promo_code", "free_bot_gift",
        "nitro_code_promo", "steam_bot_codes", "nitro_hack_tool",
        "get_promo_nitro", "steam_gift_key", "steam_gift_discount",
        "robux_key_generator", "free_promo_code", "discord_tool_bot",
        "free_nitro_access", "robux_key_hack", "promo_code_generator",
        "free_steam_access", "gift_code_online", "nitro_online_tool",
        "steam_access_gift", "robux_online_access", "nitro_bot_generator",
        "get_robux_now", "free_promo_generator", "robux_gift_discount",
        "robux_promo_key", "robux_gift_code", "nitro_card_promo",
        "steam_online_gift", "free_steam_discount", "gift_bot_robux",
        "robux_bot_tool", "discord_promo_codes", "steam_gift_code_now",
        "robux_card_tool", "promo_tool_robux", "steam_gift_bot",
        "robux_tool_now", "robux_online_bot", "robux_gift_tool",
        "steam_code_promo", "free_key_nitro", "free_robux_code",
        "discord_hack_gift", "robux_tool_card", "promo_tool_discount",
        "nitro_discount_tool", "robux_hack_codes", "steam_discount_code",
        "free_gift_tool", "robux_code_tool", "discord_card_generator",
        "free_tool_gift", "robux_key_discount", "robux_discount_bot",
        "free_tool_card", "steam_key_promo", "nitro_tool_bot",
        "nitro_gift_codes", "steam_key_generator", "free_promo_gift",
        "free_bot_promo", "gift_card_online", "robux_access_promo",
        "free_key_discount", "free_key_tool", "nitro_promo_discount",
        "nitro_gift_online", "nitro_key_codes", "robux_discount_tool",
        "steam_bot_gift", "nitro_discount_bot", "steam_promo_tool",
        "discord_promo_generator", "nitro_bot_key", "robux_card_promo",
        "steam_tool_discount", "robux_discount_codes", "nitro_key_online",
        "steam_card_key", "promo_gift_code", "gift_tool_online",
        "gift_key_promo", "nitro_online_access", "steam_discount_bot",
        "nitro_giveaway_tool", "promo_access_bot", "robux_code_promo",
        "gift_code_promo", "free_nitro_promo", "gift_access_tool",
        "free_nitro_key", "nitro_card_codes", "free_access_tool",
        "steam_giveaway_bot", "promo_code_bot", "robux_promo_bot",
        "promo_card_tool", "free_access_promo", "steam_access_code",
        "free_gift_key", "promo_discount_tool", "promo_discount_bot",
        "promo_key_bot", "promo_key_tool", "promo_gift_tool",
        "discount_gift_bot", "promo_bot_discount", "promo_access_tool",
        "gift_card_promo", "nitro_gift_discount", "free_discount_code",
        "discord_promo_gift", "promo_code_discount", "promo_key_code",
        "discount_bot_key", "discount_tool_code", "promo_bot_card",
        "promo_key_promo", "discount_key_promo", "gift_card_access",
        "promo_code_online", "gift_key_online", "promo_code_access",
        "promo_access_code", "discount_bot_tool", "promo_code_card",
        "promo_discount_card", "gift_discount_tool", "promo_card_key",
        "promo_key_access", "discount_access_bot", "promo_discount_access",
        "promo_code_key", "promo_discount_key", "promo_key_online",
        "gift_key_card", "discount_promo_bot", "promo_giveaway_card",
        "promo_bot_online", "gift_tool_discount", "discount_giveaway_tool",
        "promo_code_giveaway", "promo_tool_access", "promo_key_discount",
        "discount_card_tool", "gift_bot_discount", "promo_key_gift",
        "discount_key_gift", "promo_gift_access", "promo_card_access",
        "promo_discount_gift", "promo_giveaway_access", "promo_key_tool",
        "discount_gift_access", "promo_tool_key", "promo_card_discount",
        "promo_discount_code", "promo_card_tool", "discount_card_key",
        "promo_key_generator", "promo_tool_online", "promo_tool_gift",
        "promo_discount_bot", "promo_gift_code", "discount_key_tool",
        "promo_access_card", "promo_tool_discount", "promo_bot_access",
        "promo_discount_tool", "promo_key_tool", "promo_discount_access",
        "promo_code_tool", "promo_card_key", "promo_key_online",
        "promo_tool_card", "promo_discount_key", "promo_access_tool",
        "🖕", "promo",
        }
        
    
    async def check_banned_words(self, message):
        
        if not self.badwords_enabled:
            return False
        if message.author.bot:
            return False 
        if message.webhook_id:
            webhook_logger = self.bot.get_cog('WebhookLogger')
            if webhook_logger and message.webhook_id == webhook_logger.webhook_id:
                return False
                
        if message.embeds:
            for embed in message.embeds:
                if embed.footer and 'Webhook ID:' in embed.footer.text:
                    return False

        BOT_OWNER_ID = os.getenv("BOT_OWNER_ID", "0")
        if not BOT_OWNER_ID or not BOT_OWNER_ID.isdigit():
            raise ValueError("Invalid BOT_OWNER_ID in .env file. It must be a numeric Discord ID.")

        BOT_OWNER_ID = int(BOT_OWNER_ID)

        if message.author.id == BOT_OWNER_ID:
            return False

        content_to_check = [message.content.lower()]
        
        if message.embeds:
            for embed in message.embeds:
                if embed.description:
                    content_to_check.append(embed.description.lower())
                if embed.title:
                    content_to_check.append(embed.title.lower())
                for field in embed.fields:
                    content_to_check.append(field.name.lower())
                    content_to_check.append(field.value.lower())

        for content in content_to_check:
            for word, pattern in self.banned_regex.items():
                if pattern.search(content):
                    await asyncio.sleep(1)  
                    await message.delete()
                    if not message.webhook_id:
                        await self.send_warning(message.channel, message.author, "banned_words")
                    return True
        return False

        
    @commands.Cog.listener()
    async def on_message(self, message):
   
        if isinstance(message.channel, discord.DMChannel):
            return

        await self.check_message(message)

    async def check_message(self, message):
        if message.guild is None:
            return False    

        if message.author.bot:
            return False    
        checks = [
            self.check_links,        
            self.check_banned_words, 
            self.check_caps,         
            self.check_spam          
        ]

        for check in checks:
            try:
                action = await check(message)
                if action:
                    return
            except Exception as e:
                print(f"AutoMod Check Error in {check.__name__}: {e}")

    async def check_spam(self, message):
        if not isinstance(message.author, discord.Member):
            return False
            
        author_id = message.author.id
        current_time = time.time()

        if author_id not in self.spam_check:
            self.spam_check[author_id] = {"messages": 1, "last_message": current_time}
            return False

        if current_time - self.spam_check[author_id]["last_message"] > 5:
            self.spam_check[author_id] = {"messages": 1, "last_message": current_time}
            return False

        self.spam_check[author_id]["messages"] += 1
        
        if self.spam_check[author_id]["messages"] >= 5:
            try:
                await message.author.timeout(duration=timedelta(minutes=self.spam_timeout_minutes), reason="Spam detection")
                await self.send_warning(message.channel, message.author, "spam")
                return True
            except discord.Forbidden:
                await message.channel.send("⚠️ Unable to timeout user - missing permissions.")
                return False

        self.spam_check[author_id]["last_message"] = current_time
        return False


    async def check_caps(self, message):
        if not self.caps_enabled:
            return False
        if len(message.content) < 8:
            return False

        caps_ratio = sum(1 for c in message.content if c.isupper()) / len(message.content)
        if caps_ratio > self.caps_threshold:
            await message.delete()
            await self.send_warning(message.channel, message.author, "caps")
            return True
        return False

    async def check_links(self, message):
        if not self.link_filter_enabled:  
            return False
        if message.author.bot:
            return False
        BOT_OWNER_ID = os.getenv('BOT_OWNER_ID')

        if not BOT_OWNER_ID or not BOT_OWNER_ID.isdigit():
            raise ValueError("Invalid BOT_OWNER_ID in .env file. It must be a numeric Discord ID.")

        BOT_OWNER_ID = int(BOT_OWNER_ID)

        if message.author.id == BOT_OWNER_ID:
            return False
        
        if message.author.id == BOT_OWNER_ID or message.author.id == self.bot.user.id:
            return False

        content_to_check = [message.content.lower()]

        if message.embeds:
            for embed in message.embeds:
                if embed.description:
                    content_to_check.append(embed.description.lower())
                if embed.title:
                    content_to_check.append(embed.title.lower())
                if embed.footer and embed.footer.text:
                    content_to_check.append(embed.footer.text.lower())
                if embed.author and embed.author.name:
                    content_to_check.append(embed.author.name.lower())
                for field in embed.fields:
                    content_to_check.append(field.name.lower())
                    content_to_check.append(field.value.lower())

        code_blocks = re.findall(r'```(?:\w+\n)?([^`]+)```', message.content, re.DOTALL)
        content_to_check.extend(block.lower() for block in code_blocks)

        link_patterns = [
            'http://', 'https://',
            'discord.gg', 'discord.com/invite',
            '.gg/', 'discord.me',
            'discordapp.com/invite',
            'invite.gg', 'dsc.gg',
            'd.gg', 'discord.link',
            'dis.gd', 'discord.io',
            'discord.st', 'invite.ink',
            'discord.media',
            'discord.new',
            'dsc.gg/',
            'invite/',
            'discord.com/servers'
        ]

        for content in content_to_check:
            if any(pattern in content for pattern in link_patterns):
                if not any(allowed in content for allowed in self.link_whitelist):
                    try:
                        await asyncio.sleep(1)
                        await message.delete()
                        if message.webhook_id:
                            print(f"Deleted webhook message with unauthorized links in {message.guild.name}")
                        else:
                            await self.send_warning(message.channel, message.author, "unauthorized Discord invites or links")
                        return True
                    except discord.errors.NotFound:
                        pass
                    except discord.errors.Forbidden:
                        print(f"Missing permissions to delete message in {message.guild.name}")
                    break
        return False


    async def send_warning(self, channel, user, violation_type):
        warnings = {
            "spam": "⚠️ Excessive message spam detected.",
            "caps": "⚠️ Excessive use of capital letters detected.",
            "links": "⚠️ Unauthorized links are not permitted.",
            "banned_words": "⚠️ Inappropriate language detected."
        }

        embed = EmbedBuilder(
            "🛡️ AutoMod Warning",
            warnings.get(violation_type, "Rule violation detected.")
        ).set_color(discord.Color.orange())
        
        embed.add_field("User", user.mention)
        embed.add_field("Violation", violation_type.title())
        embed.add_field("Action Taken", "Message Deleted", inline=False)
        
        try:
            await channel.send(embed=embed.build(), delete_after=10)
        except discord.errors.Forbidden:
            print(f"Missing permissions to send warning in {channel.name}")


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def automod(self, ctx, setting: str = None, value: str = None, timeout_minutes: int = None):
        
        if timeout_minutes is None:
            timeout_minutes = self.spam_timeout_minutes

        if setting is None:
            embed = EmbedBuilder(
                "⚙️ AutoMod Settings Panel",
                "Here are the current AutoMod settings and available commands:"
            ).set_color(discord.Color.blue())

            embed.add_field("Spam Threshold", f"{self.spam_threshold} messages in {self.spam_interval} seconds")
            embed.add_field("Spam Timeout", f"{self.spam_timeout_minutes} minutes")
            embed.add_field("Caps Threshold", f"{self.caps_threshold * 100}%")

            whitelist_display = "\n".join(list(self.link_whitelist)[:5]) if self.link_whitelist else "None"
            embed.add_field("Whitelisted Links (First 5)", whitelist_display)



            commands_explanation = (
                "**Commands:**\n"
                "- `!automod caps_threshold <value>`\n"
                "  - Set the maximum allowed percentage of caps in a message (0.0-1.0).\n"
                "- `!automod spam_threshold <value> [timeout_minutes]`\n"
                "  - Set the number of messages allowed before spam detection and the timeout duration.\n"
                "- `!automod add_banned_word <word>`\n"
                "  - Add a word to the banned words list.\n"
                "- `!automod add_whitelist <url>`\n"
                "  - Add a URL to the link whitelist.\n"
                "- `!automod`\n"
                "  - Display the current AutoMod settings and available commands."
                "- `!togglelinks`\n"
                "  - Toggle the link detection feature on or off."
                "- `!togglecaps`\n"
                "  - Toggle the caps detection feature on or off."
                "- `!togglelinks`\n"
                "  - Toggle the link detection feature on or off."
                "- `!togglebadwords`\n"
                "  - Toggle the banned words feature on or off."
            )

            embed.add_field("Available Commands", commands_explanation)


            await ctx.send(embed=embed.build())
            return

        settings = {
            'caps_threshold': float,
            'spam_threshold': int,
            'add_banned_word': str,
            'add_whitelist': str
        }

        if setting not in settings:
            return await ctx.send("Invalid setting!")

        try:
            if setting == 'spam_threshold':
                self.spam_check = {}
                self.spam_threshold = int(value)
                self.spam_timeout_minutes = timeout_minutes

                embed = EmbedBuilder(
                    "⚙️ AutoMod Spam Settings Updated",
                    f"Threshold: {value} messages in {self.spam_interval} seconds\nTimeout: {timeout_minutes} minutes"
                ).set_color(discord.Color.green()).build()

            elif setting in ['add_banned_word', 'add_whitelist']:
                if setting == 'add_banned_word':
                    self.banned_words.add(value.lower())
                else:
                    self.link_whitelist.add(value.lower())
                embed = EmbedBuilder(
                    "⚙️ AutoMod Updated",
                    f"Setting `{setting}` updated with value `{value}`"
                ).set_color(discord.Color.green()).build()
            else:
                setattr(self, setting, settings[setting](value))
                embed = EmbedBuilder(
                    "⚙️ AutoMod Updated",
                    f"Setting `{setting}` updated to `{value}`"
                ).set_color(discord.Color.green()).build()

            await ctx.send(embed=embed)
        except ValueError:
            await ctx.send("Invalid value format!")


    @commands.command()
    @commands.has_permissions(administrator=True)
    async def togglecaps(self, ctx):
        
        self.caps_enabled = not getattr(self, 'caps_enabled', True)
        status = "enabled" if self.caps_enabled else "disabled"
        
        embed = discord.Embed(
            title="🔠 Caps Filter",
            description=f"Caps detection is now **{status}**",
            color=discord.Color.green() if self.caps_enabled else discord.Color.red()
        )
        await ctx.send(embed=embed)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def togglebadwords(self, ctx):
        
        self.badwords_enabled = not getattr(self, 'badwords_enabled', True)
        status = "enabled" if self.badwords_enabled else "disabled"
        
        embed = discord.Embed(
            title="🚫 Bad Words Filter",
            description=f"Bad words filter is now **{status}**",
            color=discord.Color.green() if self.badwords_enabled else discord.Color.red()
        )
        await ctx.send(embed=embed)

class WelcomeSystem(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.welcome_configs = {}

    @commands.group(invoke_without_command=True)
    @commands.has_permissions(administrator=True)
    async def welcome(self, ctx):
        embed = EmbedBuilder(
            "Welcome System Commands",
            "Available commands for welcome message configuration"
        ).set_color(discord.Color.blue())
        
        embed.add_field("!welcome message <message>", "Set welcome message\nVariables: {user}, {server}, {count}")
        embed.add_field("!welcome color <color>", "Set embed color (e.g. red, blue, green)")
        embed.add_field("!welcome banner <url>", "Set welcome banner image/gif")
        embed.add_field("!welcome test", "Preview current welcome message")
        embed.add_field("!welcome reset", "Reset to default message")
        embed.add_field("!welcome channel #channel", "Set welcome channel")
      
        
        await ctx.send(embed=embed.build())

    @welcome.command(name="message")
    @commands.has_permissions(administrator=True)
    async def set_message(self, ctx, *, message: str):
       
        if ctx.guild.id not in self.welcome_configs:
            self.welcome_configs[ctx.guild.id] = {}
            
        self.welcome_configs[ctx.guild.id]["message"] = message
        
        preview = message.replace("{user}", ctx.author.mention)
        preview = preview.replace("{server}", ctx.guild.name)
        preview = preview.replace("{count}", str(len(ctx.guild.members)))
        
        embed = EmbedBuilder(
            "✅ Welcome Message Set",
            "New welcome message configured"
        ).set_color(discord.Color.green())
        
        embed.add_field("Preview", preview)
        await ctx.send(embed=embed.build())

    @welcome.command(name="color")
    @commands.has_permissions(administrator=True)
    async def set_color(self, ctx, color: str):
       
        colors = {
            "red": discord.Color.red(),
            "blue": discord.Color.blue(),
            "green": discord.Color.green(),
            "gold": discord.Color.gold(),
            "purple": discord.Color.purple()
        }
        
        if color.lower() not in colors:
            valid_colors = ", ".join(colors.keys())
            return await ctx.send(f"Valid colors: {valid_colors}")
            
        if ctx.guild.id not in self.welcome_configs:
            self.welcome_configs[ctx.guild.id] = {}
            
        self.welcome_configs[ctx.guild.id]["color"] = colors[color.lower()]
        
        embed = EmbedBuilder(
            "🎨 Welcome Color Set",
            f"Welcome message color set to {color}"
        ).set_color(colors[color.lower()]).build()
        
        await ctx.send(embed=embed)

    @welcome.command(name="test")
    @commands.has_permissions(administrator=True)
    async def test_welcome(self, ctx):
        
        config = self.welcome_configs.get(ctx.guild.id, {})
        message = config.get("message", f"Welcome {'{user}'} to {'{server}'}!")
        color = config.get("color", discord.Color.brand_green())
        banner_url = config.get("banner_url")
        
        preview = message.replace("{user}", ctx.author.mention)
        preview = preview.replace("{server}", ctx.guild.name)
        preview = preview.replace("{count}", str(len(ctx.guild.members)))
        
        embed = EmbedBuilder(
            "👋 Welcome Preview",
            preview
        ).set_color(color)
        
        embed.add_field("Member Count", f"#{len(ctx.guild.members)}")
        embed.add_field("Account Created", ctx.author.created_at.strftime("%B %d, %Y"))
        embed.add_field("Join Position", f"#{len(ctx.guild.members)}", inline=True)
        
        embed.set_thumbnail(ctx.author.avatar.url if ctx.author.avatar else ctx.author.default_avatar.url)
        
        if banner_url:
            embed.set_image(url=banner_url)
        
        important_channels = []
        rules_channel = discord.utils.get(ctx.guild.channels, name="rules")
        info_channel = discord.utils.get(ctx.guild.channels, name="information")
        roles_channel = discord.utils.get(ctx.guild.channels, name="roles")

        if rules_channel:
            important_channels.append(f"📜 Rules: {rules_channel.mention}")
        if info_channel:
            important_channels.append(f"ℹ️ Information: {info_channel.mention}")
        if roles_channel:
            important_channels.append(f"🎭 Roles: {roles_channel.mention}")

        if important_channels:
            embed.add_field("Important Channels", "\n".join(important_channels), inline=False)
        
        await ctx.send(embed=embed.build())

    @welcome.command(name="channel")
    @commands.has_permissions(administrator=True)
    async def set_channel(self, ctx, channel: discord.TextChannel):
        if ctx.guild.id not in self.welcome_configs:
            self.welcome_configs[ctx.guild.id] = {}
            
        self.welcome_configs[ctx.guild.id]["channel_id"] = channel.id
        
        embed = EmbedBuilder(
            "📝 Welcome Channel Set",
            f"Welcome messages will be sent to {channel.mention}"
        ).set_color(discord.Color.green()).build()
        
        await ctx.send(embed=embed)

    @welcome.command(name="reset")
    @commands.has_permissions(administrator=True)
    async def reset_welcome(self, ctx):
        if ctx.guild.id in self.welcome_configs:
            del self.welcome_configs[ctx.guild.id]
            
        embed = EmbedBuilder(
            "🔄 Welcome Reset",
            "Welcome message configuration has been reset to default"
        ).set_color(discord.Color.blue()).build()
        
        await ctx.send(embed=embed)

    @commands.Cog.listener()
    async def on_member_join(self, member):
        config = self.welcome_configs.get(member.guild.id, {})
        channel_id = config.get("channel_id")
        welcome_channel = member.guild.get_channel(channel_id) if channel_id else discord.utils.get(member.guild.channels, name="welcome")

        if welcome_channel:
            message = config.get("message", f"Welcome {member.mention} to {member.guild.name}!")
            color = config.get("color", discord.Color.brand_green())
            banner_url = config.get("banner_url")

            message = message.replace("{user}", member.mention)
            message = message.replace("{server}", member.guild.name)
            message = message.replace("{count}", str(len(member.guild.members)))

            embed = EmbedBuilder(
                "👋 Welcome to the Server!",
                message
            ).set_color(color)

            embed.add_field("Member Count", f"#{len(member.guild.members)}")
            embed.add_field("Account Created", member.created_at.strftime("%B %d, %Y"))
            embed.add_field("Join Position", f"#{len(member.guild.members)}", inline=True)
            
            embed.set_thumbnail(member.avatar.url if member.avatar else member.default_avatar.url)
            
            if banner_url:
                embed.set_image(url=banner_url)

            important_channels = []
            rules_channel = discord.utils.get(member.guild.channels, name="rules")
            info_channel = discord.utils.get(member.guild.channels, name="information")
            roles_channel = discord.utils.get(member.guild.channels, name="roles")

            if rules_channel:
                important_channels.append(f"📜 Rules: {rules_channel.mention}")
            if info_channel:
                important_channels.append(f"ℹ️ Information: {info_channel.mention}")
            if roles_channel:
                important_channels.append(f"🎭 Roles: {roles_channel.mention}")

            if important_channels:
                embed.add_field("Important Channels", "\n".join(important_channels), inline=False)

            await welcome_channel.send(embed=embed.build())

            server_management_cog = self.bot.get_cog("ServerManagement")
            if server_management_cog and hasattr(server_management_cog, "autorole_dict"):
                autorole_dict = server_management_cog.autorole_dict
                if member.guild.id in autorole_dict:
                    role_id = autorole_dict[member.guild.id]
                    role = member.guild.get_role(role_id)
                    if role:
                        try:
                            await member.add_roles(role)
                            print(f"✅ Assigned role '{role.name}' to {member.name}")
                        except discord.Forbidden:
                            print(f"❌ Insufficient permissions to assign role '{role.name}' to {member.name}")
                        except discord.HTTPException as e:
                            print(f"⚠️ HTTP Exception: {e}")
                    else:
                        print(f"❌ Role ID {role_id} not found in guild {member.guild.name}")

    @welcome.command(name="banner")
    @commands.has_permissions(administrator=True)
    async def set_banner(self, ctx, banner_url: str = None):
        if ctx.guild.id not in self.welcome_configs:
            self.welcome_configs[ctx.guild.id] = {}
            
        if banner_url or ctx.message.attachments:
          
            url = banner_url or ctx.message.attachments[0].url
            
            valid_extensions = ['.png', '.jpg', '.jpeg', '.gif']
            is_discord_cdn = 'cdn.discordapp.com' in url
            is_valid_extension = any(ext in url.lower() for ext in valid_extensions)
            
            if is_discord_cdn or is_valid_extension:
                self.welcome_configs[ctx.guild.id]["banner_url"] = url
                
                embed = EmbedBuilder(
                    "🖼️ Welcome Banner Set",
                    "New welcome banner configured"
                ).set_color(discord.Color.green())
                embed.set_image(url=url)
                
                await ctx.send(embed=embed.build())
            else:
                await ctx.send("❌ Invalid image format. Please use PNG, JPG, or GIF")
        else:
            
            self.welcome_configs[ctx.guild.id].pop("banner_url", None)
            await ctx.send("✅ Welcome banner has been removed")

class ReactionRoles(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @discord.ui.button(label="🎮 Gamer", style=discord.ButtonStyle.blurple, custom_id="role_gamer")
    async def gamer_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.toggle_role(interaction, "Gamer")

    @discord.ui.button(label="🎵 Music", style=discord.ButtonStyle.green, custom_id="role_music")
    async def music_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.toggle_role(interaction, "Music")

    @discord.ui.button(label="🎨 Artist", style=discord.ButtonStyle.red, custom_id="role_artist")
    async def artist_role(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.toggle_role(interaction, "Artist")

    async def toggle_role(self, interaction: discord.Interaction, role_name: str):
        role = discord.utils.get(interaction.guild.roles, name=role_name)
        if not role:
            role = await interaction.guild.create_role(name=role_name)

        if role in interaction.user.roles:
            await interaction.user.remove_roles(role)
            embed = EmbedBuilder(
                "Role Removed",
                f"Removed {role.mention} role"
            ).set_color(discord.Color.red()).build()
        else:
            await interaction.user.add_roles(role)
            embed = EmbedBuilder(
                "Role Added",
                f"Added {role.mention} role"
            ).set_color(discord.Color.green()).build()

        await interaction.response.send_message(embed=embed, ephemeral=True)

class DesignStudioView(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=300)
        self.cog = cog

    @discord.ui.button(label="Color Theme", style=discord.ButtonStyle.blurple, emoji="🎨")
    async def color_theme(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(ColorThemeModal(self.cog))

    @discord.ui.button(label="Button Styles", style=discord.ButtonStyle.green, emoji="🔘")
    async def button_styles(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(ButtonStyleModal(self.cog))

    @discord.ui.button(label="Layout Options", style=discord.ButtonStyle.gray, emoji="📐")
    async def layout(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(LayoutModal(self.cog))

    @discord.ui.button(label="Edit Text", style=discord.ButtonStyle.primary, emoji="✏️")
    async def edit_text(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(TextEditModal(self.cog))


class CreateRoleGroupModal(discord.ui.Modal, title="Create Role Group"):
    group_name = discord.ui.TextInput(
        label="Group Name",
        placeholder="Enter a name for this role group",
        required=True
    )
    role_ids = discord.ui.TextInput(
        label="Role IDs",
        placeholder="Enter role IDs separated by commas",
        required=True
    )
    description = discord.ui.TextInput(
        label="Description",
        placeholder="Describe what this group is for",
        required=False,
        style=discord.TextStyle.paragraph
    )

    def __init__(self, cog, guild_id, panel_id):
        super().__init__()
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Role group created!", ephemeral=True)

class ExclusiveRolesModal(discord.ui.Modal, title="Set Exclusive Roles"):
    group_id = discord.ui.TextInput(
        label="Group ID",
        placeholder="Enter the group ID to make exclusive",
        required=True
    )
    exclusive = discord.ui.TextInput(
        label="Exclusive",
        placeholder="Type 'yes' to make roles exclusive",
        required=True
    )

    def __init__(self, cog, guild_id, panel_id):
        super().__init__()
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Exclusive roles set!", ephemeral=True)

class EditGroupModal(discord.ui.Modal, title="Edit Role Group"):
    group_id = discord.ui.TextInput(
        label="Group ID",
        placeholder="Enter the group ID to edit",
        required=True
    )
    new_name = discord.ui.TextInput(
        label="New Name",
        placeholder="Enter new group name",
        required=False
    )
    new_roles = discord.ui.TextInput(
        label="New Role IDs",
        placeholder="Enter new role IDs (comma separated)",
        required=False
    )

    def __init__(self, cog, guild_id, panel_id):
        super().__init__()
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Group updated successfully!", ephemeral=True)

class GroupConfigView(discord.ui.View):
    def __init__(self, cog, guild_id, panel_id):
        super().__init__(timeout=300)
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    @discord.ui.button(label="Create Group", style=discord.ButtonStyle.green, emoji="➕", row=0)
    async def create_group(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(CreateRoleGroupModal(self.cog, self.guild_id, self.panel_id))

    @discord.ui.button(label="Edit Group", style=discord.ButtonStyle.blurple, emoji="✏️", row=0)
    async def edit_group(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(EditGroupModal(self.cog, self.guild_id, self.panel_id))

    @discord.ui.button(label="Exclusive Roles", style=discord.ButtonStyle.gray, emoji="🔒", row=0)
    async def set_exclusive(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(ExclusiveRolesModal(self.cog, self.guild_id, self.panel_id))

    @discord.ui.button(label="Role Requirements", style=discord.ButtonStyle.red, emoji="🔑", row=1)
    async def set_requirements(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(RoleRequirementsModal(self.cog, self.guild_id, self.panel_id))

class RolePanelSettingsView(discord.ui.View):
    def __init__(self, bot):
        super().__init__(timeout=300)
        self.bot = bot
        self.settings = {
            "security": {
                "permission_checks": True,
                "hierarchy_enabled": True,
                "abuse_prevention": True,
                "rate_limit": 60,  # seconds
                "role_conflicts": []
            },
            "config": {
                "global_cooldown": 300,  # seconds
                "verification_required": False,
                "logging_enabled": True,
                "backup_enabled": True
            }
        }

    @discord.ui.button(label="Security Settings", style=discord.ButtonStyle.primary)
    async def security_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        security_view = SecuritySettingsView(self.settings["security"])
        embed = discord.Embed(title="Role Panel Security Settings", color=discord.Color.blue())
        embed.add_field(name="Permission Checks", 
                       value=f"Status: {'✅ Enabled' if self.settings['security']['permission_checks'] else '❌ Disabled'}", 
                       inline=False)
        embed.add_field(name="Role Hierarchy", 
                       value=f"Status: {'✅ Enabled' if self.settings['security']['hierarchy_enabled'] else '❌ Disabled'}", 
                       inline=False)
        embed.add_field(name="Anti-Abuse System", 
                       value=f"Status: {'✅ Enabled' if self.settings['security']['abuse_prevention'] else '❌ Disabled'}", 
                       inline=False)
        embed.add_field(name="Rate Limiting", 
                       value=f"Current: {self.settings['security']['rate_limit']} seconds", 
                       inline=False)
        await interaction.response.send_message(embed=embed, view=security_view, ephemeral=True)

    @discord.ui.button(label="Configuration", style=discord.ButtonStyle.primary)
    async def config_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        config_view = ConfigSettingsView(self.settings["config"])
        embed = discord.Embed(title="Role Panel Configuration", color=discord.Color.green())
        embed.add_field(name="Global Cooldowns", 
                       value=f"Current: {self.settings['config']['global_cooldown']} seconds", 
                       inline=False)
        embed.add_field(name="Verification Requirements", 
                       value=f"Status: {'✅ Enabled' if self.settings['config']['verification_required'] else '❌ Disabled'}", 
                       inline=False)
        embed.add_field(name="Logging Settings", 
                       value=f"Status: {'✅ Enabled' if self.settings['config']['logging_enabled'] else '❌ Disabled'}", 
                       inline=False)
        embed.add_field(name="Backup Options", 
                       value=f"Status: {'✅ Enabled' if self.settings['config']['backup_enabled'] else '❌ Disabled'}", 
                       inline=False)
        await interaction.response.send_message(embed=embed, view=config_view, ephemeral=True)

    @discord.ui.button(label="Save Settings", style=discord.ButtonStyle.success)
    async def save_settings(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await self.bot.db.rolepanel.update_one(
                {"guild_id": interaction.guild_id},
                {"$set": self.settings},
                upsert=True
            )
            await interaction.response.send_message("✅ Settings saved successfully!", ephemeral=True)
            if self.settings["config"]["logging_enabled"]:
                log_channel = self.bot.get_channel(self.settings.get("log_channel_id"))
                if log_channel:
                    embed = discord.Embed(
                        title="Role Panel Settings Updated",
                        description="Settings have been updated by " + str(interaction.user),
                        color=discord.Color.green(),
                        timestamp=datetime.now()
                    )
                    await log_channel.send(embed=embed)
                    
        except Exception as e:
            await interaction.response.send_message("❌ Error saving settings: " + str(e), ephemeral=True)

    @discord.ui.button(label="Reset Defaults", style=discord.ButtonStyle.danger)
    async def reset_defaults(self, interaction: discord.Interaction, button: discord.ui.Button):
        confirm_view = ConfirmView()
        await interaction.response.send_message(
            "Are you sure you want to reset all settings to defaults?", 
            view=confirm_view, 
            ephemeral=True
        )
        
        await confirm_view.wait()
        if confirm_view.value:
            self.settings = {
                "security": {
                    "permission_checks": True,
                    "hierarchy_enabled": True,
                    "abuse_prevention": True,
                    "rate_limit": 60,
                    "role_conflicts": []
                },
                "config": {
                    "global_cooldown": 300,
                    "verification_required": False,
                    "logging_enabled": True,
                    "backup_enabled": True
                }
            }
            await interaction.followup.send("Settings reset to defaults!", ephemeral=True)
        else:
            await interaction.followup.send("Reset cancelled.", ephemeral=True)

class SecuritySettingsView(discord.ui.View):
    def __init__(self, security_settings):
        super().__init__(timeout=300)
        self.settings = security_settings

    @discord.ui.button(label="Toggle Permission Checks", style=discord.ButtonStyle.secondary, row=0)
    async def toggle_permissions(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["permission_checks"] = not self.settings["permission_checks"]
        await self.update_security_embed(interaction)

    @discord.ui.button(label="Toggle Role Hierarchy", style=discord.ButtonStyle.secondary, row=0)
    async def toggle_hierarchy(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["hierarchy_enabled"] = not self.settings["hierarchy_enabled"]
        await self.update_security_embed(interaction)

    @discord.ui.button(label="Toggle Anti-Abuse", style=discord.ButtonStyle.secondary, row=1)
    async def toggle_abuse(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["abuse_prevention"] = not self.settings["abuse_prevention"]
        await self.update_security_embed(interaction)

    @discord.ui.button(label="Set Rate Limit", style=discord.ButtonStyle.primary, row=1)
    async def set_rate_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = RateLimitModal()
        await interaction.response.send_modal(modal)

    async def update_security_embed(self, interaction: discord.Interaction):
        embed = discord.Embed(title="Role Panel Security Settings", color=discord.Color.blue())
        embed.add_field(name="Permission Checks", value=f"Status: {'✅ Enabled' if self.settings['permission_checks'] else '❌ Disabled'}")
        embed.add_field(name="Role Hierarchy", value=f"Status: {'✅ Enabled' if self.settings['hierarchy_enabled'] else '❌ Disabled'}")
        embed.add_field(name="Anti-Abuse System", value=f"Status: {'✅ Enabled' if self.settings['abuse_prevention'] else '❌ Disabled'}")
        embed.add_field(name="Rate Limiting", value=f"Current: {self.settings['rate_limit']} seconds")
        await interaction.response.edit_message(embed=embed, view=self)

class ConfigSettingsView(discord.ui.View):
    def __init__(self, config_settings):
        super().__init__(timeout=300)
        self.settings = config_settings

    @discord.ui.button(label="Set Cooldown", style=discord.ButtonStyle.primary, row=0)
    async def set_cooldown(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = CooldownModal()
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Toggle Verification", style=discord.ButtonStyle.secondary, row=0)
    async def toggle_verification(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["verification_required"] = not self.settings["verification_required"]
        await self.update_config_embed(interaction)

    @discord.ui.button(label="Toggle Logging", style=discord.ButtonStyle.secondary, row=1)
    async def toggle_logging(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["logging_enabled"] = not self.settings["logging_enabled"]
        await self.update_config_embed(interaction)

    @discord.ui.button(label="Toggle Backup", style=discord.ButtonStyle.secondary, row=1)
    async def toggle_backup(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.settings["backup_enabled"] = not self.settings["backup_enabled"]
        await self.update_config_embed(interaction)

    async def update_config_embed(self, interaction: discord.Interaction):
        embed = discord.Embed(title="Role Panel Configuration", color=discord.Color.green())
        embed.add_field(name="Global Cooldowns", value=f"Current: {self.settings['global_cooldown']} seconds")
        embed.add_field(name="Verification Requirements", value=f"Status: {'✅ Enabled' if self.settings['verification_required'] else '❌ Disabled'}")
        embed.add_field(name="Logging Settings", value=f"Status: {'✅ Enabled' if self.settings['logging_enabled'] else '❌ Disabled'}")
        embed.add_field(name="Backup Options", value=f"Status: {'✅ Enabled' if self.settings['backup_enabled'] else '❌ Disabled'}")
        await interaction.response.edit_message(embed=embed, view=self)

class RateLimitModal(discord.ui.Modal, title="Set Rate Limit"):
    rate_limit = discord.ui.TextInput(
        label="Rate Limit (in seconds)",
        placeholder="Enter rate limit duration...",
        min_length=1,
        max_length=4,
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            value = int(self.rate_limit.value)
            if 1 <= value <= 3600:
                await interaction.response.send_message(f"Rate limit set to {value} seconds", ephemeral=True)
            else:
                await interaction.response.send_message("Rate limit must be between 1 and 3600 seconds", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Please enter a valid number", ephemeral=True)

class ConfirmView(discord.ui.View):
    def __init__(self):
        super().__init__()
        self.value = None

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = True
        self.stop()
        await interaction.response.defer()

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary)
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = False
        self.stop()
        await interaction.response.defer()

class CooldownModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Set Global Cooldown")  # Add title here
        self.cooldown = discord.ui.TextInput(
            label="Cooldown (in seconds)",
            placeholder="Enter cooldown duration...",
            min_length=1,
            max_length=4
        )
        self.add_item(self.cooldown)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            cooldown = int(self.cooldown.value)
            await interaction.response.send_message(f"Cooldown set to {cooldown} seconds", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Please enter a valid number", ephemeral=True)


class RoleRequirementsModal(discord.ui.Modal, title="Role Requirements"):
    target_role = discord.ui.TextInput(
        label="Target Role ID",
        placeholder="Enter the role ID that needs requirements",
        required=True
    )
    required_roles = discord.ui.TextInput(
        label="Required Role IDs",
        placeholder="Enter role IDs needed to get this role (comma separated)",
        required=True
    )
    level_requirement = discord.ui.TextInput(
        label="Level Requirement (Optional)",
        placeholder="Minimum level needed (if using leveling system)",
        required=False
    )

    def __init__(self, cog, guild_id, panel_id):
        super().__init__()
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    async def on_submit(self, interaction: discord.Interaction):
        target = self.target_role.value
        requirements = self.required_roles.value.split(',')
        
        if not self.cog.role_configs.get(self.guild_id, {}).get('role_requirements'):
            self.cog.role_configs[self.guild_id]['role_requirements'] = {}
            
        self.cog.role_configs[self.guild_id]['role_requirements'][target] = {
            'required_roles': requirements,
            'level_requirement': self.level_requirement.value if self.level_requirement.value else None
        }
        
        self.cog.save_configs()
        await interaction.response.send_message("Role requirements have been set!", ephemeral=True)


class SettingsView(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=300)
        self.cog = cog

    @discord.ui.button(label="📝 Queue Manager", style=ButtonStyle.blurple, row=0)
    async def queue_manager(self, interaction: discord.Interaction, button: discord.ui.Button):
        queue_embed = discord.Embed(title="Queue Manager", color=discord.Color.blue())
        queue_view = QueueView(self.cog)
        await interaction.response.send_message(embed=queue_embed, view=queue_view, ephemeral=True)

    @discord.ui.button(label="🎵 Join/Move", style=ButtonStyle.green, row=1)
    async def join_voice(self, interaction: discord.Interaction, button: discord.ui.Button):
        member = interaction.guild.get_member(interaction.user.id)
        if member and member.voice and member.voice.channel:
            if not interaction.guild.voice_client:
                await member.voice.channel.connect()
                await interaction.response.send_message(f"✅ Connected to {member.voice.channel.name}", ephemeral=True)
            else:
                await interaction.guild.voice_client.move_to(member.voice.channel)
                await interaction.response.send_message(f"✅ Moved to {member.voice.channel.name}", ephemeral=True)
        else:
            await interaction.response.send_message("Join a voice channel first!", ephemeral=True)

class ColorThemeModal(discord.ui.Modal, title="Color Theme Settings"):
    theme_choice = discord.ui.TextInput(
        label="Theme Color",
        placeholder="modern, classic, minimal, or custom",
        required=True
    )
    custom_color = discord.ui.TextInput(
        label="Custom Color (hex)",
        placeholder="#000000 (only if using custom theme)",
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        theme = self.theme_choice.value.lower()
        await interaction.response.send_message(f"Theme updated to: {theme}", ephemeral=True)

class AnimatedButton(discord.ui.Button):
    def __init__(self, style=None, animation_type=None, **kwargs):
        super().__init__(**kwargs)
        self.style = style or discord.ButtonStyle.secondary
        self.animation_type = animation_type or "none"
        self.original_label = kwargs.get('label', '')
        self.original_style = self.style
        self.animations = {
            'pulse': self._pulse_effect,
            'fade': self._fade_effect,
            'bounce': self._bounce_effect,
            'shimmer': self._shimmer_effect,
            'rainbow': self._rainbow_effect,
            'wave': self._wave_effect,
            'blink': self._blink_effect,
            'slide': self._slide_effect,
            'glow': self._glow_effect,
            'spin': self._spin_effect
        }

    async def callback(self, interaction: discord.Interaction):
        if self.animation_type != "none":
            await interaction.response.defer()
            animation_func = self.animations.get(self.animation_type)
            if animation_func:
                await animation_func(interaction)
                self.style = self.original_style
                self.label = self.original_label
                await interaction.message.edit(view=self.view)
        
        await super().callback(interaction)
    async def _pulse_effect(self, interaction):
        styles = [ButtonStyle.primary, ButtonStyle.success, ButtonStyle.secondary]
        for style in styles:
            self.style = style
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.5)

    async def _fade_effect(self, interaction):
        labels = [self.label + "⠀", self.label + "⠈", self.label]
        for label in labels:
            self.label = label
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.3)

    async def _bounce_effect(self, interaction):
        positions = ["↑" + self.label, "↓" + self.label, self.label]
        for pos in positions:
            self.label = pos
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.2)

    async def _shimmer_effect(self, interaction):
        sparkles = ["✨", "⭐", "🌟", "💫"]
        for sparkle in sparkles:
            self.label = f"{sparkle} {self.label} {sparkle}"
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.4)

    async def _rainbow_effect(self, interaction):
        colors = [0xFF0000, 0xFFA500, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3]
        embed = interaction.message.embeds[0]
        for color in colors:
            embed.color = color
            await interaction.message.edit(embed=embed)
            await asyncio.sleep(0.3)

    async def _wave_effect(self, interaction):
        frames = ["⋮", "⋰", "⋯", "⋱"]
        for frame in frames:
            self.label = f"{frame} {self.label} {frame}"
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.3)

    async def _blink_effect(self, interaction):
        for _ in range(3):
            self.disabled = True
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.2)
            self.disabled = False
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.2)

    async def _slide_effect(self, interaction):
        spaces = ["⠀" * i + self.label + "⠀" * (5-i) for i in range(6)]
        for space in spaces:
            self.label = space
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.2)

    async def _glow_effect(self, interaction):
        styles = [ButtonStyle.secondary, ButtonStyle.success, ButtonStyle.primary]
        emojis = ["✨", "🌟", "💫", "⭐"]
        for style, emoji in zip(styles, emojis):
            self.style = style
            self.emoji = emoji
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.4)

    async def _spin_effect(self, interaction):
        spin_frames = ["◜", "◝", "◞", "◟"]
        for frame in spin_frames:
            self.label = f"{frame} {self.label} {frame}"
            await interaction.message.edit(view=self.view)
            await asyncio.sleep(0.2)

class ButtonStyleModal(discord.ui.Modal, title="Button Style Settings"):
    style_choice = discord.ui.TextInput(
        label="Button Style",
        placeholder="default, primary, success, or danger",
        required=True
    )
    animation_choice = discord.ui.TextInput(
        label="Animation Style",
        placeholder="pulse, grow, fade, bounce, or none",
        required=False,
        default="none"
    )
    custom_color = discord.ui.TextInput(
        label="Custom Color (optional)",
        placeholder="Enter hex color code (#RRGGBB)",
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        style = self.style_choice.value.lower()
        animation = self.animation_choice.value.lower() if self.animation_choice.value else "none"
        
        guild_id = str(interaction.guild_id)
        if guild_id not in self.cog.role_configs:
            self.cog.role_configs[guild_id] = {}
        
        self.cog.role_configs[guild_id]["button_style"] = style
        self.cog.role_configs[guild_id]["animation"] = animation
        
        if self.custom_color.value:
            self.cog.role_configs[guild_id]["custom_color"] = self.custom_color.value
        
        self.cog.save_configs()
        
        await interaction.response.send_message(
            "Button style updated! Use the Refresh button to see your changes.", 
            ephemeral=True
        )

class LayoutModal(discord.ui.Modal, title="Layout Settings"):
    layout_type = discord.ui.TextInput(
        label="Layout Type",
        placeholder="grid, list, or compact",
        required=True
    )
    columns = discord.ui.TextInput(
        label="Number of Columns",
        placeholder="1-5 (for grid layout)",
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        layout = self.layout_type.value.lower()
        await interaction.response.send_message(f"Layout updated to: {layout}", ephemeral=True)

class TextEditModal(discord.ui.Modal, title="Edit Text Settings"):
    title_text = discord.ui.TextInput(
        label="Panel Title",
        placeholder="Enter new panel title",
        required=False
    )
    description = discord.ui.TextInput(
        label="Panel Description",
        placeholder="Enter new description",
        style=discord.TextStyle.paragraph,
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Text settings updated!", ephemeral=True)

class RoleLimitsModal(discord.ui.Modal, title="Role Limits"):
    max_roles = discord.ui.TextInput(
        label="Maximum Roles",
        placeholder="Enter max number of roles per user (0 for unlimited)",
        required=True
    )
    exclusive_groups = discord.ui.TextInput(
        label="Exclusive Groups",
        placeholder="Enter role groups (comma separated)",
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Role limits updated!", ephemeral=True)

class VerificationSettingsModal(discord.ui.Modal, title="Verification Settings"):
    require_verification = discord.ui.TextInput(
        label="Require Verification",
        placeholder="yes/no",
        required=True
    )
    verification_role = discord.ui.TextInput(
        label="Required Role ID",
        placeholder="Enter role ID required for access",
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Verification settings updated!", ephemeral=True)

class CooldownSettingsModal(discord.ui.Modal, title="Cooldown Settings"):
    cooldown_time = discord.ui.TextInput(
        label="Cooldown Duration",
        placeholder="Enter cooldown in seconds",
        required=True
    )
    bypass_roles = discord.ui.TextInput(
        label="Bypass Role IDs",
        placeholder="Enter role IDs that bypass cooldown (comma separated)",
        required=False
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("Cooldown settings updated!", ephemeral=True)

class EditPanelModal(discord.ui.Modal, title="Edit Role Panel"):
    panel_id = discord.ui.TextInput(
        label="Panel ID",
        placeholder="Enter the panel ID to edit",
        required=True
    )
    
    new_title = discord.ui.TextInput(
        label="New Title",
        placeholder="Enter new panel title...",
        required=False
    )
    
    new_description = discord.ui.TextInput(
        label="New Description",
        placeholder="Enter new description...",
        required=False,
        style=discord.TextStyle.paragraph
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        guild_id = str(interaction.guild_id)
        panel = self.cog.role_configs[guild_id].get(self.panel_id.value)
        
        if panel:
            if self.new_title.value:
                panel["title"] = self.new_title.value
            if self.new_description.value:
                panel["description"] = self.new_description.value
            
            self.cog.save_configs()
            await interaction.response.send_message("Panel updated successfully!", ephemeral=True)
        else:
            await interaction.response.send_message("Panel not found!", ephemeral=True)

class DeletePanelModal(discord.ui.Modal, title="Delete Role Panel"):
    panel_id = discord.ui.TextInput(
        label="Panel ID",
        placeholder="Enter the panel ID to delete",
        required=True
    )
    
    confirmation = discord.ui.TextInput(
        label="Confirmation",
        placeholder="Type 'DELETE' to confirm",
        required=True
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        if self.confirmation.value != "DELETE":
            await interaction.response.send_message("Deletion cancelled.", ephemeral=True)
            return

        guild_id = str(interaction.guild_id)
        if self.panel_id.value in self.cog.role_configs[guild_id]:
            del self.cog.role_configs[guild_id][self.panel_id.value]
            self.cog.save_configs()
            await interaction.response.send_message("Panel deleted successfully!", ephemeral=True)
        else:
            await interaction.response.send_message("Panel not found!", ephemeral=True)

class RoleManager(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.role_configs = {}
        self.role_panel_configs = {}
        self.current_settings = {}  # In-memory settings
        self.load_configs()
        self.color_options = {
            "Red": discord.Color.red(),
            "Blue": discord.Color.blue(),
            "Green": discord.Color.green(),
            "Purple": discord.Color.purple(),
            "Gold": discord.Color.gold()
        }
        self.style_options = {
            "Default": discord.ButtonStyle.secondary,
            "Primary": discord.ButtonStyle.primary,
            "Success": discord.ButtonStyle.success,
            "Danger": discord.ButtonStyle.danger
        }

    def update_settings(self, guild_id, settings):
        self.current_settings[str(guild_id)] = settings
        return True

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def rolepanel_json(self, ctx):
        if not hasattr(self, 'role_panel_configs'):
            self.role_panel_configs = {}

        embed = discord.Embed(
            title="🎨 Advanced JSON Panel Creator",
            description="Create beautiful role panels using Discohook.org format!\n\n**Features:**\n• Multiple Embeds Support\n• Full Discohook Compatibility\n• Rich Formatting\n• Custom Fields & Images\n• Hex Color Support\n• Per-Embed Buttons",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="📝 Getting Started",
            value="• Click 'Show Examples' for templates\n• Use 'Upload JSON' to create your panel\n• Support for multiple embeds\n• Custom button placement",
            inline=False
        )
        
        embed.add_field(
            name="🎨 Available Styles",
            value="• Button Styles: PRIMARY, SECONDARY, SUCCESS, DANGER\n• Colors: Hex (#FF7AC6) or Decimal (16711680)\n• Groups: For exclusive role sets",
            inline=False
        )

        view = AdvancedJsonPanelView(self)
        view.guild_id = ctx.guild.id  
        view.message = await ctx.send(embed=embed, view=view)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def exportrolepanel(self, ctx):
        guild_id = str(ctx.guild.id)
        if guild_id not in self.role_configs or not self.role_configs[guild_id]:
            return await ctx.send("No role panels found to export!")
        
        config_data = self.role_configs[guild_id]
        file_content = json.dumps(config_data, indent=4)
        
        file = discord.File(
            io.StringIO(file_content),
            filename=f"role_panel_config_{ctx.guild.name}.json"
        )
        await ctx.send("Here's your role panel configuration:", file=file)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def importrolepanel(self, ctx):
        if not ctx.message.attachments:
            return await ctx.send("Please attach a JSON configuration file!")
            
        attachment = ctx.message.attachments[0]
        if not attachment.filename.endswith('.json'):
            return await ctx.send("Please provide a valid JSON file!")
            
        try:
            config_data = json.loads(await attachment.read())
            guild_id = str(ctx.guild.id)
            self.role_configs[guild_id] = config_data
            self.save_configs()
            
            await ctx.send("✅ Role panel configuration imported successfully! Use the refresh button in !rolepanel to update the panels.")
        except json.JSONDecodeError:
            await ctx.send("❌ Invalid JSON file format!")

    def load_configs(self):
        try:
            with open('role_configs.json', 'r', encoding='utf-8') as f:
                self.role_configs = json.load(f)
        except FileNotFoundError:
            self.role_configs = {}

    def save_configs(self):
        with open('role_configs.json', 'w', encoding='utf-8') as f:
            json.dump(self.role_configs, f, indent=4)

    @commands.command()
    @commands.has_permissions(administrator=True)
    async def rolepanel(self, ctx):
        embed = discord.Embed(
            title="🎮 Ultimate Role Management Suite",
            description="Create stunning role selection menus with advanced features!",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="🎨 Design Features",
            value="• Custom Panel Themes\n• Animated Buttons\n• Custom Emojis\n• Multiple Layouts\n• Dynamic Colors\n• Custom Icons",
            inline=True
        )
        
        embed.add_field(
            name="⚙️ Advanced Options",
            value="• Role Requirements\n• Group Roles\n• Temporary Roles\n• Role Limits\n• Role Categories\n• Role Chains",
            inline=True
        )
        
        embed.add_field(
            name="🔒 Security Features",
            value="• Permission Checks\n• Role Hierarchy\n• Anti-Abuse System\n• Rate Limiting\n• Role Conflicts",
            inline=False
        )

        await ctx.send(embed=embed, view=RoleManagerMainView(self))


class RoleManagerMainView(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=300)
        self.cog = cog
        self.current_page = 0

    @discord.ui.button(label="Create Panel", style=discord.ButtonStyle.green, emoji="✨", row=0)
    async def create_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(CreatePanelModal(self.cog))

    @discord.ui.button(label="Manage Panels", style=discord.ButtonStyle.blurple, emoji="📋", row=0)
    async def manage_panels(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.show_panel_manager(interaction)

    @discord.ui.button(label="Design Studio", style=discord.ButtonStyle.gray, emoji="🎨", row=0)
    async def design_studio(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="🎨 Design Studio",
            description="Customize your role panel appearance",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Design Features",
            value="• Custom Panel Themes\n• Animated Buttons\n• Custom Emojis\n• Multiple Layouts\n• Dynamic Colors\n• Custom Icons",
            inline=False
        )
        embed.add_field(
            name="Available Themes",
            value="• Modern\n• Classic\n• Minimal\n• Custom",
            inline=True
        )
        embed.add_field(
            name="Layout Options",
            value="• Grid\n• List\n• Compact\n• Custom",
            inline=True
        )
        await interaction.response.send_message(embed=embed, view=DesignStudioView(self.cog), ephemeral=True)

    @discord.ui.button(label="Role Groups", style=discord.ButtonStyle.primary, emoji="📑", row=0)
    async def manage_groups(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="Role Group Management",
            description="Create and manage role groups for better organization",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Advanced Options",
            value="• Role Requirements\n• Group Roles\n• Temporary Roles\n• Role Limits\n• Role Categories\n• Role Chains",
            inline=False
        )
        embed.add_field(
            name="Group Features",
            value="• Exclusive Roles\n• Role Hierarchy\n• Role Dependencies\n• Auto Roles",
            inline=True
        )
        await interaction.response.send_message(
            embed=embed,
            view=GroupConfigView(self.cog, str(interaction.guild_id), "main"),
            ephemeral=True
        )


    @discord.ui.button(label="Refresh Panels", style=discord.ButtonStyle.success, emoji="🔄", row=1)
    async def refresh_panels(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        guild_id = str(interaction.guild_id)
        panels = self.cog.role_configs.get(guild_id, {})
        
        for panel_id, panel_data in panels.items():
            try:
                channel_id = int(panel_data.get("channel", 0))
                channel = interaction.guild.get_channel(channel_id)
                
                if channel:
                    async for message in channel.history(limit=50):
                        if message.author == interaction.guild.me and message.embeds:
                            await message.delete()

                    embed = discord.Embed(
                        title=panel_data["title"],
                        description=panel_data["description"],
                        color=self.get_theme_color(panel_data.get("theme", "modern"))
                    )
                    await channel.send(embed=embed, view=DeployedRoleView(self.cog, guild_id, panel_id))
                    
            except (ValueError, KeyError, AttributeError):
                continue

        await interaction.followup.send("All role panels have been refreshed!", ephemeral=True)


    def get_theme_color(self, theme):
        theme_colors = {
            "modern": discord.Color.blue(),
            "classic": discord.Color.gold(),
            "minimal": discord.Color.light_grey(),
            "custom": discord.Color.purple()
        }
        return theme_colors.get(theme, discord.Color.blue())

    async def show_panel_manager(self, interaction):
        panels = self.cog.role_configs.get(str(interaction.guild_id), {})
        if not panels:
            await interaction.response.send_message("No panels exist yet! Create one first.", ephemeral=True)
            return

        embed = discord.Embed(
            title="📋 Panel Manager",
            description="Manage your existing role panels",
            color=discord.Color.blue()
        )

        for panel_id, panel in panels.items():
            embed.add_field(
                name=f"Panel: {panel['title']}",
                value=f"ID: {panel_id}\nChannel: <#{panel['channel']}>\nRoles: {len(panel.get('roles', []))}\nStyle: {panel.get('style', {}).get('theme', 'Default')}",
                inline=False
            )

        await interaction.response.send_message(
            embed=embed,
            view=PanelManagerView(self.cog, panels),
            ephemeral=True
        )
    async def show_design_studio(self, interaction):
        embed = discord.Embed(
            title="🎨 Design Studio",
            description="Customize your role panel appearance",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Available Customizations",
            value="• Theme Selection\n• Button Styles\n• Layout Options\n• Color Schemes\n• Animation Settings\n• Custom Icons",
            inline=False
        )
        await interaction.response.send_message(embed=embed, view=DesignStudioView(self.cog), ephemeral=True)

    async def show_settings(self, interaction):
        embed = discord.Embed(
            title="⚙️ Settings",
            description="Configure global role panel settings",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Global Settings",
            value="• Permission Management\n• Rate Limits\n• Verification Requirements\n• Logging Options\n• Backup Settings",
            inline=False
        )
        await interaction.response.send_message(embed=embed, view=SettingsView(self.cog), ephemeral=True)

class CreatePanelModal(discord.ui.Modal, title="Create Role Panel"):
    title_input = discord.ui.TextInput(
        label="Panel Title",
        placeholder="Enter an attractive title for your panel...",
        max_length=256,
        required=True
    )
    
    description = discord.ui.TextInput(
        label="Panel Description", 
        placeholder="Describe what this role panel is for...",
        style=discord.TextStyle.paragraph,
        required=True
    )
    
    channel_id = discord.ui.TextInput(
        label="Channel ID",
        placeholder="Enter the channel ID for the panel",
        required=True
    )
    
    theme = discord.ui.TextInput(
        label="Theme & Style",
        placeholder="modern, classic, minimal, or custom",
        required=False,
        default="modern"
    )
    
    roles_config = discord.ui.TextInput(
        label="Initial Roles",
        placeholder="Role IDs separated by commas",
        required=False,
        style=discord.TextStyle.paragraph
    )

    def __init__(self, cog):
        super().__init__()
        self.cog = cog

    async def on_submit(self, interaction: discord.Interaction):
        
        panel_data = {
            "title": self.title_input.value,
            "description": self.description.value,
            "channel": self.channel_id.value,
            "theme": self.theme.value.lower(),
            "roles": [],
            "settings": {
                "requires_verification": False,
                "cooldown": 0,
                "max_roles": 0,
                "exclusive_groups": []
            },
            "style": {
                "color": "blue",
                "button_style": "default",
                "layout": "grid",
                "animations": True
            }
        }

        guild_id = str(interaction.guild_id)
        if guild_id not in self.cog.role_configs:
            self.cog.role_configs[guild_id] = {}
        
        panel_id = str(len(self.cog.role_configs[guild_id]) + 1)
        self.cog.role_configs[guild_id][panel_id] = panel_data
        self.cog.save_configs()

        await interaction.response.send_message(
            "Panel created! Let's configure the roles and settings:",
            view=PanelConfigView(self.cog, guild_id, panel_id),
            ephemeral=True
        )

class PanelConfigView(discord.ui.View):
    def __init__(self, cog, guild_id, panel_id):
        super().__init__(timeout=300)
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    @discord.ui.button(label="Add Roles", style=discord.ButtonStyle.green, emoji="➕", row=0)
    async def add_roles(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AddRoleModal(self.cog, self.guild_id, self.panel_id))

    @discord.ui.button(label="Role Groups", style=discord.ButtonStyle.blurple, emoji="📑", row=0)
    async def configure_groups(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.show_group_config(interaction)

    @discord.ui.button(label="Preview", style=discord.ButtonStyle.gray, emoji="👁️", row=1)
    async def preview_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        panel = self.cog.role_configs[self.guild_id][self.panel_id]
        preview_embed = discord.Embed(
            title=panel["title"],
            description=panel["description"],
            color=self.get_theme_color(panel.get("theme", "modern"))
        )
        await interaction.response.send_message(
            embed=preview_embed,
            view=PreviewRoleView(self.cog, self.guild_id, self.panel_id),
            ephemeral=True
        )

    @discord.ui.button(label="Deploy", style=discord.ButtonStyle.success, emoji="🚀", row=1)
    async def deploy_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.deploy_to_channel(interaction)

    def get_theme_color(self, theme):
        theme_colors = {
            "modern": discord.Color.blue(),
            "classic": discord.Color.gold(),
            "minimal": discord.Color.light_grey(),
            "custom": discord.Color.purple()
        }
        return theme_colors.get(theme, discord.Color.blue())
    
    async def show_group_config(self, interaction):
        panel = self.cog.role_configs[self.guild_id][self.panel_id]
        embed = discord.Embed(
            title="📑 Role Groups Configuration",
            description="Manage role groups and requirements",
            color=discord.Color.blue()
        )
        await interaction.response.send_message(embed=embed, view=GroupConfigView(self.cog, self.guild_id, self.panel_id), ephemeral=True)

    async def deploy_to_channel(self, interaction):
        panel = self.cog.role_configs[self.guild_id][self.panel_id]
        channel = interaction.guild.get_channel(int(panel["channel"]))
        
        if not channel:
            await interaction.response.send_message("Target channel not found!", ephemeral=True)
            return
        
        embed = discord.Embed(
            title=panel["title"],
            description=panel["description"],
            color=self.get_theme_color(panel.get("theme", "modern"))
        )
        
        await channel.send(embed=embed, view=DeployedRoleView(self.cog, self.guild_id, self.panel_id))
        await interaction.response.send_message("Panel deployed successfully!", ephemeral=True)


class PanelManagerView(discord.ui.View):
    def __init__(self, cog, panels):
        super().__init__(timeout=300)
        self.cog = cog
        self.panels = panels

    @discord.ui.button(label="Edit Panel", style=discord.ButtonStyle.blurple, emoji="✏️")
    async def edit_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(EditPanelModal(self.cog))

    @discord.ui.button(label="Delete Panel", style=discord.ButtonStyle.red, emoji="🗑️")
    async def delete_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(DeletePanelModal(self.cog))

class DeployedRoleView(discord.ui.View):
    def __init__(self, cog, guild_id, panel_id, buttons=None):
        super().__init__(timeout=None)
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id
        if buttons:
            self.setup_buttons(buttons)
        else:
            self.setup_default_buttons()

    def get_button_style(self, style_name):
        styles = {
            "default": discord.ButtonStyle.secondary,
            "primary": discord.ButtonStyle.primary,
            "success": discord.ButtonStyle.success,
            "danger": discord.ButtonStyle.danger,
            "PRIMARY": discord.ButtonStyle.primary,
            "SECONDARY": discord.ButtonStyle.secondary,
            "SUCCESS": discord.ButtonStyle.success,
            "DANGER": discord.ButtonStyle.danger
        }
        return styles.get(style_name, discord.ButtonStyle.secondary)

    def setup_default_buttons(self):
        panel = self.cog.role_configs[self.guild_id][self.panel_id]
        for role_data in panel.get("roles", []):
            self.create_button(role_data)

    def setup_buttons(self, buttons):
        for button_data in buttons:
            self.create_button(button_data)

    def create_button(self, button_data):
        style = self.get_button_style(button_data.get("style", "default"))
        button = AnimatedButton(
            style=style,
            label=button_data["label"],
            emoji=button_data.get("emoji"),
            custom_id=f"role_{button_data['id']}",
            animation_type=button_data.get("animation_type", "none")
        )
        button.callback = self.handle_role_click
        self.add_item(button)

    async def handle_role_click(self, interaction: discord.Interaction):
        custom_id = interaction.data.get('custom_id', '')
        role_id = custom_id.split("_")[1]
        member = interaction.user
        role = interaction.guild.get_role(int(role_id))

        if not role:
            await interaction.response.send_message("Role not found!", ephemeral=True)
            return

        try:
            panel = self.cog.role_configs[self.guild_id][self.panel_id]
            settings = panel.get("settings", {})
            exclusive_groups = settings.get("exclusive_groups", [])

            if role in member.roles:
                await member.remove_roles(role)
                await interaction.response.send_message(f"Removed role: {role.name}", ephemeral=True)
            else:
               
                for button_data in panel.get("roles", []):
                    if button_data.get("group") in exclusive_groups:
                        existing_role = interaction.guild.get_role(int(button_data["id"]))
                        if existing_role and existing_role in member.roles:
                            await member.remove_roles(existing_role)

                await member.add_roles(role)
                await interaction.response.send_message(f"Added role: {role.name}", ephemeral=True)

            if hasattr(interaction.message, 'edit'):
                await interaction.message.edit(view=self)

        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to manage that role!", ephemeral=True)


class PanelManagerView(discord.ui.View):
    def __init__(self, cog, panels):
        super().__init__(timeout=300)
        self.cog = cog
        self.panels = panels

    @discord.ui.button(label="Edit Panel", style=discord.ButtonStyle.blurple, emoji="✏️")
    async def edit_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(EditPanelModal(self.cog))

    @discord.ui.button(label="Delete Panel", style=discord.ButtonStyle.red, emoji="🗑️")
    async def delete_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(DeletePanelModal(self.cog))

class AddRoleModal(discord.ui.Modal, title="Add Role to Panel"):
    role_id = discord.ui.TextInput(
        label="Role ID",
        placeholder="Enter the role ID to add",
        required=True
    )
    
    button_label = discord.ui.TextInput(
        label="Button Label",
        placeholder="Text to show on the button",
        required=True
    )
    
    emoji = discord.ui.TextInput(
        label="Button Emoji",
        placeholder="Optional: Add an emoji",
        required=False
    )
    
    style = discord.ui.TextInput(
        label="Button Style",
        placeholder="default, primary, success, or danger",
        required=False,
        default="default"
    )

    def __init__(self, cog, guild_id, panel_id):
        super().__init__()
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id

    async def on_submit(self, interaction: discord.Interaction):
        role_data = {
            "id": self.role_id.value,
            "label": self.button_label.value,
            "emoji": self.emoji.value if self.emoji.value else None,
            "style": self.style.value.lower()
        }
        
        self.cog.role_configs[self.guild_id][self.panel_id]["roles"].append(role_data)
        self.cog.save_configs()
        
        await interaction.response.send_message(
            f"Role added successfully with label: {self.button_label.value}",
            ephemeral=True
        )

class PreviewRoleView(discord.ui.View):
    def __init__(self, cog, guild_id, panel_id):
        super().__init__(timeout=60)
        self.cog = cog
        self.guild_id = guild_id
        self.panel_id = panel_id
        self.setup_preview_buttons()

    def setup_preview_buttons(self):
        panel = self.cog.role_configs[self.guild_id][self.panel_id]
        for role_data in panel.get("roles", []):
            style = self.get_button_style(role_data.get("style", "default"))
            button = discord.ui.Button(
                style=style,
                label=role_data["label"],
                emoji=role_data.get("emoji"),
                disabled=True  
            )
            self.add_item(button)

    def get_button_style(self, style_name):
        styles = {
            "default": discord.ButtonStyle.secondary,
            "primary": discord.ButtonStyle.primary,
            "success": discord.ButtonStyle.success,
            "danger": discord.ButtonStyle.danger
        }
        return styles.get(style_name, discord.ButtonStyle.secondary)


class AdvancedJsonPanelView(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=300)
        self.cog = cog
        if not hasattr(self.cog, 'role_panel_configs'):
            self.cog.role_panel_configs = {}

    def convert_color(self, color_value):
        
        if isinstance(color_value, str) and color_value.startswith('#'):
            return int(color_value.strip('#'), 16)
        return color_value

    @discord.ui.button(label="Upload Discohook JSON", style=discord.ButtonStyle.green, emoji="📤")
    async def upload_json(self, interaction: discord.Interaction, button: discord.ui.Button):
       
        await interaction.response.send_message(
            "Upload your Discohook JSON file or paste the JSON content in the next message.",
            ephemeral=True
        )

        def check(m):
            
            return m.author == interaction.user and (m.attachments or m.content)

        try:
            msg = await self.cog.bot.wait_for('message', timeout=120.0, check=check)

            if msg.attachments:
                attachment = msg.attachments[0]
                if not attachment.filename.endswith('.json'):
                    return await interaction.followup.send("Please provide a valid JSON file!", ephemeral=True)
                json_data = json.loads(await attachment.read())
            else:
                json_data = json.loads(msg.content)

            guild_id = str(interaction.guild_id)
            panel_id = str(len(self.cog.role_configs.get(guild_id, {})) + 1)

            panel_data = self.convert_discohook_to_panel(json_data)

            self.cog.role_panel_configs[guild_id] = json_data

            if guild_id not in self.cog.role_configs:
                self.cog.role_configs[guild_id] = {}

            self.cog.role_configs[guild_id][panel_id] = panel_data
            self.cog.save_configs()

            channel = interaction.guild.get_channel(int(panel_data["channel"]))
            if channel:
                for embed_data in panel_data["embeds"]:
                    if "color" in embed_data:
                        embed_data["color"] = self.convert_color(embed_data["color"])
                    embed = discord.Embed.from_dict(embed_data)
                    buttons = embed_data.get("buttons", [])
                    view = DeployedRoleView(self.cog, guild_id, panel_id, buttons) if buttons else None
                    await channel.send(embed=embed, view=view)

            await interaction.followup.send("✨ Beautiful role panel created successfully!", ephemeral=True)

        except asyncio.TimeoutError:
            await interaction.followup.send("Timed out waiting for JSON.", ephemeral=True)
        except json.JSONDecodeError:
            await interaction.followup.send("Invalid JSON format! Make sure it's properly formatted.", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"An error occurred: {str(e)}", ephemeral=True)

    @discord.ui.button(label="Show Simple Example", style=discord.ButtonStyle.primary, emoji="📚")
    async def show_simple_example(self, interaction: discord.Interaction, button: discord.ui.Button):
        
        simple_example = {
            "channel_id": "YOUR_CHANNEL_ID",
            "embeds": [{
                "title": "🎮 Gaming Roles",
                "description": "Select your favorite games!",
                "color": "#FF7AC6",
                "buttons": [{
                    "id": "ROLE_ID",
                    "label": "Minecraft",
                    "emoji": "⛏️",
                    "style": "PRIMARY"
                }]
            }]
        }

        simple_example_str = json.dumps(simple_example, indent=2)

        example_embed = discord.Embed(
            title="📚 Simple Example",
            description="Here is a simple example of a role panel.",
            color=discord.Color.green()
        )
        example_embed.add_field(
            name="Example",
            value=f"```json\n{simple_example_str}\n```",
            inline=False
        )

        await interaction.response.send_message(embed=example_embed, ephemeral=True)

    import io

    @discord.ui.button(label="Show Multi-Embed Example", style=discord.ButtonStyle.primary, emoji="📚")
    async def show_multi_example(self, interaction: discord.Interaction, button: discord.ui.Button):
        
        multi_example = {
            "channel_id": "YOUR_CHANNEL_ID",
            "embeds": [
                {
                    "title": "🌟 Welcome",
                    "description": "Welcome to our server! Select your status below.",
                    "color": "#7289DA",
                    "buttons": [
                        {
                            "id": "ROLE_ID_1",
                            "label": "New Member",
                            "emoji": "✨",
                            "style": "SUCCESS"
                        },
                        {
                            "id": "ROLE_ID_2",
                            "label": "Regular",
                            "emoji": "⭐",
                            "style": "PRIMARY"
                        },
                        {
                            "id": "ROLE_ID_3",
                            "label": "Notifications",
                            "emoji": "🔔",
                            "style": "SECONDARY"
                        }
                    ]
                },
                {
                    "title": "🎮 Gaming Roles",
                    "description": "Select your favorite games!",
                    "color": "#FF4B4B",
                    "buttons": [
                        {
                            "id": "ROLE_ID_4",
                            "label": "Minecraft",
                            "emoji": "⛏️",
                            "style": "PRIMARY"
                        },
                        {
                            "id": "ROLE_ID_5",
                            "label": "Valorant",
                            "emoji": "🎯",
                            "style": "DANGER"
                        },
                        {
                            "id": "ROLE_ID_6",
                            "label": "League",
                            "emoji": "⚔️",
                            "style": "SUCCESS"
                        },
                        {
                            "id": "ROLE_ID_7",
                            "label": "Fortnite",
                            "emoji": "🎪",
                            "style": "PRIMARY"
                        }
                    ]
                }
            ]
        }

        multi_example_str = json.dumps(multi_example, indent=2)

        file = io.BytesIO(multi_example_str.encode('utf-8'))
        file.seek(0)  

        await interaction.response.send_message(
            content="📚 Here is the multi-embed JSON example as a file you can use:",
            file=discord.File(file, filename="multi_embed_example.json"),
            ephemeral=True
        )

    @discord.ui.button(label="Show Style Guide", style=discord.ButtonStyle.primary, emoji="🎨")
    async def show_style_guide(self, interaction: discord.Interaction, button: discord.ui.Button):
        
        style_guide_embed = discord.Embed(
            title="🎨 Role Panel Style Guide",
            description="Here are some guidelines to make your role panels look amazing!",
            color=discord.Color.blue()
        )

        style_guide_embed.add_field(
            name="Styling Tips",
            value="• Use hex colors (e.g., #FF7AC6) or decimal.\n"
                  "• Button styles: PRIMARY, SECONDARY, SUCCESS, DANGER.\n"
                  "• Add emojis to titles and buttons.\n"
                  "• Group related roles together.",
            inline=False
        )

        await interaction.response.send_message(embed=style_guide_embed, ephemeral=True)

    def convert_discohook_to_panel(self, json_data):
        
        return {
            "channel": str(json_data.get("channel_id", "0")),
            "embeds": json_data.get("embeds", []),
            "roles": json_data.get("roles", []),
            "settings": {
                "requires_verification": json_data.get("requires_verification", False),
                "cooldown": json_data.get("cooldown", 0),
                "max_roles": json_data.get("max_roles", 0),
                "exclusive_groups": json_data.get("exclusive_groups", [])
            },
            "style": {
                "layout": json_data.get("layout", "grid"),
                "animations": json_data.get("animations", True),
                "button_style": json_data.get("button_style", "default")
            }
        }

class UserTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.user_activity = {}

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return

        user_id = message.author.id
        if user_id not in self.user_activity:
            self.user_activity[user_id] = {
                "messages": 0,
                "last_active": None,
                "commands_used": 0
            }

        self.user_activity[user_id]["messages"] += 1
        self.user_activity[user_id]["last_active"] = datetime.now(timezone.utc)

    @commands.command()
    async def activity(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        user_data = self.user_activity.get(member.id, {
            "messages": 0,
            "last_active": None,
            "commands_used": 0
        })

        embed = EmbedBuilder(
            f"📊 Activity Stats - {member.name}",
            "User activity information"
        ).set_color(discord.Color.blue())
        
        embed.add_field("Messages Sent", str(user_data["messages"]))
        embed.add_field("Commands Used", str(user_data["commands_used"]))
        
        if user_data["last_active"]:
            embed.add_field(
                "Last Active",
                user_data["last_active"].strftime("%Y-%m-%d %H:%M:%S UTC"),
                inline=False
            )
            
        embed.set_thumbnail(member.avatar.url if member.avatar else member.default_avatar.url)
        await ctx.send(embed=embed.build())

TOKEN = os.getenv('D15C0RD_T0K3N')  # Do  NOT   hardcode your Discord Token here! 

if __name__ == "__main__":

    logging.basicConfig(                                        # Removable
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('bot.log')
        ]
    )
    @bot.event
    async def on_message(message):
        await bot.webhook_logger.log_message(message)
        await bot.process_commands(message)

    @bot.event 
    async def on_command(ctx):
        await bot.webhook_logger.log_command(ctx)

    try:
        bot.run(TOKEN)
    except discord.LoginFailure:
        logging.error("Invalid token provided")
    except Exception as e:
        logging.error(f"Error during bot startup: {e}"
